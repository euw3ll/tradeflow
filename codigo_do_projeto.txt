========================================
# Arquivo: Dockerfile
========================================

# Usa uma imagem oficial do Python como base
FROM python:3.11-slim

# Define o diretório de trabalho dentro do container
WORKDIR /app

# Copia o arquivo de dependências primeiro
COPY requirements.txt .

# Instala as dependências do Python
RUN pip install --no-cache-dir -r requirements.txt

# Copia todo o resto do código do projeto
COPY . .

# Comando que será executado quando o container iniciar, usando o script simplificado
CMD ["./start.sh"]

========================================
# Arquivo: main.py
========================================

import logging
import asyncio
from telegram import Update
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, 
    ConversationHandler, CallbackQueryHandler, ContextTypes
)
from telegram.error import TelegramError
from utils.config import TELEGRAM_TOKEN
from bot.handlers import (
    start, receive_invite_code, cancel, WAITING_CODE,
    config_api, receive_api_key, receive_api_secret, WAITING_API_KEY, WAITING_API_SECRET,
    remove_api_prompt, remove_api_action, CONFIRM_REMOVE_API,
    my_positions_handler, user_dashboard_handler, user_settings_handler,
    back_to_main_menu_handler,
    ask_entry_percent, receive_entry_percent, ASKING_ENTRY_PERCENT,
    ask_max_leverage, receive_max_leverage, ASKING_MAX_LEVERAGE,
    ask_min_confidence, receive_min_confidence, ASKING_MIN_CONFIDENCE,
    toggle_stop_strategy_handler,
    signal_filters_menu_handler, toggle_ma_filter_handler, toggle_rsi_filter_handler,
    ask_ma_period, receive_ma_period, ASKING_MA_PERIOD,
    admin_menu, list_channels_handler, select_channel_to_monitor, select_topic_to_monitor,
    admin_view_targets_handler, back_to_admin_menu_handler,
    bot_config_handler, toggle_approval_mode_handler, handle_signal_approval, 
    ask_profit_target, receive_profit_target, ASKING_PROFIT_TARGET,
    ask_loss_limit, receive_loss_limit, ASKING_LOSS_LIMIT, 
    ask_coin_whitelist, receive_coin_whitelist, ASKING_COIN_WHITELIST,
    performance_menu_handler, list_closed_trades_handler,
    prompt_manual_close_handler, execute_manual_close_handler,
    toggle_bot_status_handler,
    ask_stop_gain_trigger, receive_stop_gain_trigger, ASKING_STOP_GAIN_TRIGGER,
    ask_stop_gain_lock, receive_stop_gain_lock, ASKING_STOP_GAIN_LOCK,
    ask_circuit_threshold, receive_circuit_threshold, ASKING_CIRCUIT_THRESHOLD,
    ask_circuit_pause, receive_circuit_pause, ASKING_CIRCUIT_PAUSE,
    ask_ma_timeframe, set_ma_timeframe,
    ask_rsi_oversold, receive_rsi_oversold, ASKING_RSI_OVERSOLD,
    ask_rsi_overbought, receive_rsi_overbought, ASKING_RSI_OVERBOUGHT,
    show_risk_menu_handler, show_stopgain_menu_handler, show_circuit_menu_handler,
    back_to_settings_menu_handler, back_from_whitelist_handler
)
from database.session import init_db
from services.telethon_service import start_signal_monitor
from core.position_tracker import run_tracker

import warnings
warnings.filterwarnings("ignore", category=UserWarning, module="telegram.ext.conversationhandler")
logging.getLogger("telegram").setLevel(logging.ERROR)
logging.getLogger("telegram.ext").setLevel(logging.ERROR)

# --- Configuração do Logging ---
logging.basicConfig(
    format="%(asctime)s - [%(levelname)s] - %(name)s - %(message)s",
    level=logging.INFO
)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("telegram").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)

async def run_ptb(application: Application, queue: asyncio.Queue):
    """Inicializa e roda a aplicação python-telegram-bot."""
    application.bot_data['comm_queue'] = queue
    logger.info("Inicializando o bot do Telegram (PTB)...")
    await application.initialize()
    await application.start()
    await application.updater.start_polling()
    logger.info("✅ Bot do Telegram (PTB) ativo.")

async def on_error(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Error handler global: loga a exceção e avisa o usuário (em chat privado)."""
    logger = logging.getLogger(__name__)
    logger.error("Unhandled error", exc_info=context.error)
    try:
        if update and update.effective_chat and update.effective_chat.type == "private":
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="⚠️ Ocorreu um erro inesperado. Já registrei aqui e vou corrigir.",
            )
    except TelegramError:
        # Evita encadear erros caso o envio falhe
        pass

async def main():
    """Configura os handlers e inicia o PTB e o Telethon em paralelo."""
    init_db()
    comm_queue = asyncio.Queue()
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    await comm_queue.put(application)

    # --- Handlers de Conversa ---
    register_conv = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={ WAITING_CODE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_invite_code)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    api_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(config_api, pattern='^config_api$')],
        states={
            WAITING_API_KEY: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_api_key)],
            WAITING_API_SECRET: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_api_secret)],
        },
        # MUDANÇA: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    remove_api_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(remove_api_prompt, pattern='^remove_api_prompt$')],
        states={ CONFIRM_REMOVE_API: [CallbackQueryHandler(remove_api_action, pattern='^remove_api_confirm|remove_api_cancel$')] },
        # MUDANÇA: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    settings_entry_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_entry_percent, pattern='^set_entry_percent$')],
        states={ ASKING_ENTRY_PERCENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_entry_percent)] },
        # MUDANÇA: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    settings_leverage_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_max_leverage, pattern='^set_max_leverage$')],
        states={ ASKING_MAX_LEVERAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_max_leverage)] },
        # MUDANÇA: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    settings_confidence_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_min_confidence, pattern='^set_min_confidence$')],
        states={ ASKING_MIN_CONFIDENCE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_min_confidence)] },
        # MUDANÇA: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    profit_target_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_profit_target, pattern='^set_profit_target$')],
        states={ ASKING_PROFIT_TARGET: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_profit_target)] },
        # MUDANÇA: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    loss_limit_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_loss_limit, pattern='^set_loss_limit$')],
        states={ ASKING_LOSS_LIMIT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_loss_limit)] },
        # MUDANÇA: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    whitelist_conv = ConversationHandler(
    entry_points=[CallbackQueryHandler(ask_coin_whitelist, pattern='^set_coin_whitelist$')],
    states={
        ASKING_COIN_WHITELIST: [
            # novo: permite clicar em "Voltar" enquanto está no prompt
            CallbackQueryHandler(back_from_whitelist_handler, pattern='^back_to_settings_menu$'),
            # já existia: captura o texto enviado com a lista
            MessageHandler(filters.TEXT & ~filters.COMMAND, receive_coin_whitelist),
        ]
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    per_message=False, per_user=True,
)
    stop_gain_trigger_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_stop_gain_trigger, pattern='^set_stop_gain_trigger$')],
        states={ ASKING_STOP_GAIN_TRIGGER: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_stop_gain_trigger)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    stop_gain_lock_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_stop_gain_lock, pattern='^set_stop_gain_lock$')],
        states={ ASKING_STOP_GAIN_LOCK: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_stop_gain_lock)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    circuit_threshold_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_circuit_threshold, pattern='^set_circuit_threshold$')],
        states={ ASKING_CIRCUIT_THRESHOLD: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_circuit_threshold)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    circuit_pause_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_circuit_pause, pattern='^set_circuit_pause$')],
        states={ ASKING_CIRCUIT_PAUSE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_circuit_pause)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    ma_period_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_ma_period, pattern='^set_ma_period$')],
        states={ ASKING_MA_PERIOD: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_ma_period)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    rsi_oversold_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_rsi_oversold, pattern='^set_rsi_oversold$')],
        states={ ASKING_RSI_OVERSOLD: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_rsi_oversold)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    rsi_overbought_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_rsi_overbought, pattern='^set_rsi_overbought$')],
        states={ ASKING_RSI_OVERBOUGHT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_rsi_overbought)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )

    # Adicionando todos os handlers
    application.add_handler(register_conv)
    application.add_handler(api_conv)
    application.add_handler(remove_api_conv)
    application.add_handler(settings_entry_conv)
    application.add_handler(settings_leverage_conv)
    application.add_handler(settings_confidence_conv)
    application.add_handler(profit_target_conv)
    application.add_handler(loss_limit_conv)
    application.add_handler(whitelist_conv)
    application.add_handler(stop_gain_trigger_conv)
    application.add_handler(stop_gain_lock_conv)
    
    application.add_handler(CommandHandler("admin", admin_menu))
    application.add_handler(CallbackQueryHandler(list_channels_handler, pattern='^admin_list_channels$'))
    application.add_handler(CallbackQueryHandler(select_channel_to_monitor, pattern='^monitor_channel_'))
    application.add_handler(CallbackQueryHandler(select_topic_to_monitor, pattern='^monitor_topic_'))
    application.add_handler(CallbackQueryHandler(admin_view_targets_handler, pattern='^admin_view_targets$'))
    application.add_handler(CallbackQueryHandler(back_to_admin_menu_handler, pattern='^back_to_admin_menu$'))

    application.add_handler(CommandHandler("start", start))
    
    application.add_handler(CallbackQueryHandler(my_positions_handler, pattern='^user_positions$'))
    application.add_handler(CallbackQueryHandler(user_settings_handler, pattern='^user_settings$'))
    application.add_handler(CallbackQueryHandler(user_dashboard_handler, pattern='^user_dashboard$'))
    application.add_handler(CallbackQueryHandler(toggle_bot_status_handler, pattern='^toggle_bot_status$'))
    application.add_handler(CallbackQueryHandler(back_to_main_menu_handler, pattern='^back_to_main_menu$'))
    application.add_handler(CallbackQueryHandler(prompt_manual_close_handler, pattern='^confirm_close_'))
    application.add_handler(CallbackQueryHandler(execute_manual_close_handler, pattern='^execute_close_'))

    application.add_handler(CallbackQueryHandler(toggle_stop_strategy_handler, pattern='^set_stop_strategy$'))

    application.add_handler(CallbackQueryHandler(performance_menu_handler, pattern='^perf_'))
    
    application.add_handler(CallbackQueryHandler(list_closed_trades_handler, pattern='^list_closed_trades$'))

    application.add_handler(CallbackQueryHandler(bot_config_handler, pattern='^bot_config$'))
    application.add_handler(CallbackQueryHandler(toggle_approval_mode_handler, pattern='^toggle_approval_mode$'))

    application.add_handler(CallbackQueryHandler(handle_signal_approval, pattern=r'^(approve_signal_|reject_signal_)'))

    application.add_handler(stop_gain_lock_conv)
    application.add_handler(circuit_threshold_conv)
    application.add_handler(circuit_pause_conv)

    application.add_handler(CallbackQueryHandler(signal_filters_menu_handler, pattern='^signal_filters_menu$'))
    application.add_handler(CallbackQueryHandler(toggle_ma_filter_handler, pattern='^toggle_ma_filter$'))
    application.add_handler(CallbackQueryHandler(toggle_rsi_filter_handler, pattern='^toggle_rsi_filter$'))
    application.add_handler(ma_period_conv)

    application.add_handler(CallbackQueryHandler(ask_ma_timeframe, pattern='^ask_ma_timeframe$'))
    application.add_handler(CallbackQueryHandler(set_ma_timeframe, pattern='^set_ma_timeframe_'))
    application.add_handler(rsi_oversold_conv)
    application.add_handler(rsi_overbought_conv)

    application.add_handler(CallbackQueryHandler(show_risk_menu_handler, pattern='^settings_risk$'))
    application.add_handler(CallbackQueryHandler(show_stopgain_menu_handler, pattern='^settings_stopgain$'))
    application.add_handler(CallbackQueryHandler(show_circuit_menu_handler, pattern='^settings_circuit$'))
    application.add_handler(CallbackQueryHandler(back_to_settings_menu_handler, pattern='^back_to_settings_menu$'))

    application.add_error_handler(on_error)

    logger.info("Bot configurado. Iniciando todos os serviços...")

    await asyncio.gather(
        run_ptb(application, comm_queue),
        start_signal_monitor(comm_queue),
        run_tracker(application)
    )

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Bot desligado pelo usuário.")
    except Exception as e:
        logger.critical(f"Erro crítico não tratado: {e}", exc_info=True)

========================================
# Arquivo: start.sh
========================================

#!/bin/sh

echo "Aplicando migrações do banco de dados..."
# Este comando garante que o DB esteja sempre na versão mais recente
# alembic upgrade head

echo "Iniciando o bot TradeFlow..."
python main.py

========================================
# Arquivo: database/__init__.py
========================================



========================================
# Arquivo: database/bootstrap_schema.py
========================================

# database/bootstrap_schema.py
from sqlalchemy import text
from .session import SessionLocal

def ensure_trades_columns():
    s = SessionLocal()
    try:
        conn = s.connection()
        cols = [row[1] for row in conn.execute(text("PRAGMA table_info(trades)")).fetchall()]

        if "missing_cycles" not in cols:
            conn.execute(text(
                "ALTER TABLE trades ADD COLUMN missing_cycles INTEGER NOT NULL DEFAULT 0"
            ))

        if "last_seen_at" not in cols:
            conn.execute(text(
                "ALTER TABLE trades ADD COLUMN last_seen_at DATETIME"
            ))

        s.commit()
    except Exception:
        s.rollback()
        raise
    finally:
        s.close()

========================================
# Arquivo: database/crud.py
========================================

from .session import SessionLocal
from .models import User

def get_user_by_id(telegram_id: int):
    """Busca um usuário no banco de dados pelo seu ID do Telegram."""
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == telegram_id).first()
        return user
    finally:
        db.close()

========================================
# Arquivo: database/models.py
========================================

from sqlalchemy import (Column, Integer, String, BigInteger, Boolean, Float, JSON, DateTime, UniqueConstraint)
from sqlalchemy.orm import declarative_base
from sqlalchemy.sql import func

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)
    first_name = Column(String)
    api_key_encrypted = Column(String)
    api_secret_encrypted = Column(String)
    entry_size_percent = Column(Float, default=5.0)
    max_leverage = Column(Integer, default=10)
    min_confidence = Column(Float, default=0.0)
    approval_mode = Column(String, default='AUTOMATIC', nullable=False)
    daily_profit_target = Column(Float, default=0.0, nullable=False)
    daily_loss_limit = Column(Float, default=0.0, nullable=False)
    coin_whitelist = Column(String, default='todas', nullable=False)
    stop_strategy = Column(String(20), default='BREAK_EVEN', nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    stop_gain_trigger_pct = Column(Float, default=0.0, nullable=False)
    stop_gain_lock_pct = Column(Float, default=0.0, nullable=False)
    circuit_breaker_threshold = Column(Integer, default=0, nullable=False)
    circuit_breaker_pause_minutes = Column(Integer, default=60, nullable=False)
    long_trades_paused_until = Column(DateTime(timezone=True), nullable=True)
    short_trades_paused_until = Column(DateTime(timezone=True), nullable=True)
    is_sleep_mode_enabled = Column(Boolean, default=False, nullable=False)
    # Filtros de Análise Técnica
    is_ma_filter_enabled = Column(Boolean, default=False, nullable=False)
    ma_period = Column(Integer, default=50, nullable=False)
    ma_timeframe = Column(String(10), default='60', nullable=False) # '60' para 1 hora
    is_rsi_filter_enabled = Column(Boolean, default=False, nullable=False)
    rsi_timeframe = Column(String(10), default='60', nullable=False)
    rsi_oversold_threshold = Column(Integer, default=30, nullable=False)
    rsi_overbought_threshold = Column(Integer, default=70, nullable=False)

class InviteCode(Base):
    __tablename__ = 'invite_codes'
    id = Column(Integer, primary_key=True)
    code = Column(String, unique=True, nullable=False)
    is_used = Column(Boolean, default=False)

class MonitoredTarget(Base):
    __tablename__ = 'monitored_targets'
    id = Column(Integer, primary_key=True)
    channel_id = Column(BigInteger, nullable=False)
    channel_name = Column(String)
    topic_id = Column(BigInteger, unique=True, nullable=True)
    topic_name = Column(String)

class Trade(Base):
    __tablename__ = 'trades'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False)
    order_id = Column(String, unique=True, nullable=False)
    notification_message_id = Column(BigInteger, nullable=True)
    symbol = Column(String, nullable=False)
    side = Column(String, nullable=False)
    qty = Column(Float, nullable=False)
    entry_price = Column(Float)
    stop_loss = Column(Float)
    current_stop_loss = Column(Float)
    initial_targets = Column(JSON)
    total_initial_targets = Column(Integer, nullable=True)
    status = Column(String, default='ACTIVE')
    remaining_qty = Column(Float)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    closed_at = Column(DateTime(timezone=True), nullable=True)
    closed_pnl = Column(Float, nullable=True)
    is_breakeven = Column(Boolean, default=False, nullable=False)
    trail_high_water_mark = Column(Float, nullable=True)
    is_stop_gain_active = Column(Boolean, default=False, nullable=False)
    unrealized_pnl_pct = Column(Float, nullable=True)
    missing_cycles = Column(Integer, default=0, nullable=False)
    last_seen_at = Column(DateTime(timezone=True), nullable=True)

class PendingSignal(Base):
    __tablename__ = 'pending_signals'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False, index=True)
    symbol = Column(String, nullable=False, index=True) 
    order_id = Column(String, unique=True, nullable=False)
    signal_data = Column(JSON, nullable=False)
    notification_message_id = Column(BigInteger, nullable=True)
    __table_args__ = (UniqueConstraint('user_telegram_id', 'symbol', name='_user_symbol_uc'),)

class SignalForApproval(Base):
    __tablename__ = 'signals_for_approval'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False, index=True)
    symbol = Column(String, nullable=False)
    source_name = Column(String)
    signal_data = Column(JSON, nullable=False)
    approval_message_id = Column(BigInteger)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

========================================
# Arquivo: database/session.py
========================================

# database/session.py
import os
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from .models import Base

# --- Caminho dinâmico (Docker vs local) ---
# Docker: a imagem monta o DB em /app/data/tradeflow.db
# Local: usa ./tradeflow.db
if os.path.isdir("/app/data"):
    DATABASE_URL = "sqlite:////app/data/tradeflow.db"
else:
    DATABASE_URL = "sqlite:///./tradeflow.db"

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def init_db():
    """Cria tabelas conhecidas e garante colunas novas no 'trades'."""
    # 1) Cria tabelas definidas nos models (se não existirem)
    Base.metadata.create_all(bind=engine)

    # 2) Bootstrap de schema para colunas novas (idempotente)
    with engine.begin() as conn:
        # lista colunas atuais da tabela trades
        cols = [row[1] for row in conn.execute(text("PRAGMA table_info(trades)")).fetchall()]

        # missing_cycles
        if "missing_cycles" not in cols:
            conn.execute(text(
                "ALTER TABLE trades ADD COLUMN missing_cycles INTEGER NOT NULL DEFAULT 0"
            ))

        # last_seen_at
        if "last_seen_at" not in cols:
            conn.execute(text(
                "ALTER TABLE trades ADD COLUMN last_seen_at DATETIME"
            ))

========================================
# Arquivo: core/__init__.py
========================================



========================================
# Arquivo: core/performance_service.py
========================================

from services.bybit_service import get_closed_pnl_breakdown, get_account_info
from utils.security import decrypt_data
from database.session import SessionLocal
from database.models import Trade, User
from datetime import datetime
import logging
import asyncio

logger = logging.getLogger(__name__)

async def generate_performance_report(user_id: int, start_dt: datetime, end_dt: datetime) -> str:
    """Gera relatório de desempenho, incluindo a rentabilidade sobre o patrimônio."""
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if not user or not user.api_key_encrypted:
            return "Você precisa ter uma chave de API configurada para ver o desempenho."

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # Busca os dados de P/L e o saldo da conta em paralelo
        pnl_result, account_info = await asyncio.gather(
            get_closed_pnl_breakdown(api_key, api_secret, start_dt, end_dt),
            get_account_info(api_key, api_secret)
        )

        if not pnl_result.get("success"):
            return f"Não foi possível calcular seu desempenho: {pnl_result.get('error')}"

        total_pnl = pnl_result["total_pnl"]
        wins = pnl_result["wins"]
        losses = pnl_result["losses"]
        trades = pnl_result["trades"]
        hit_rate = (wins / trades * 100.0) if trades else 0.0
        
        # --- NOVO CÁLCULO DE RENTABILIDADE ---
        rentabilidade_str = ""
        if account_info.get("success"):
            total_equity = account_info.get("data", {}).get("total_equity", 0.0)
            if total_equity > 0:
                rentabilidade = (total_pnl / total_equity) * 100
                rentabilidade_str = f"🚀 <b>Rentabilidade:</b> {rentabilidade:+.2f}%\n\n"
        
        lucro_str = f"📈 <b>Lucro:</b> ${total_pnl:,.2f}" if total_pnl >= 0 else f"📉 <b>Prejuízo:</b> ${abs(total_pnl):,.2f}"

        msg = (
            f"<b>📊 Desempenho do Período</b>\n"
            f"<i>De {start_dt:%d/%m/%Y} a {end_dt:%d/%m/%Y}</i>\n\n"
            f"{rentabilidade_str}"
            f"{lucro_str}\n\n"
            f"🎯 <b>Taxa de Acerto:</b> {hit_rate:.2f}%\n"
            f"📦 <b>Total de Trades:</b> {trades}\n"
            f"  - Ganhos: {wins}\n"
            f"  - Perdas: {losses}\n"
        )
        return msg

    except Exception as e:
        logger.error(f"Erro ao gerar relatório de performance para {user_id}: {e}", exc_info=True)
        return "Ocorreu um erro ao gerar seu relatório."
    finally:
        db.close()


========================================
# Arquivo: core/position_tracker.py
========================================

import asyncio
import logging
import time
from telegram.ext import Application
from sqlalchemy.orm import Session
from database.session import SessionLocal
from database.models import Trade, User, PendingSignal
from services.bybit_service import (
    get_market_price, close_partial_position,
    modify_position_stop_loss, get_order_status,
    get_specific_position_size, modify_position_take_profit,
    get_last_closed_trade_info, get_open_positions_with_pnl,
    cancel_order
)
from services.notification_service import send_notification
from utils.security import decrypt_data
from sqlalchemy.sql import func
from telegram.error import BadRequest
from typing import Optional, Callable, Awaitable, Dict, Any, Set, Tuple, List

logger = logging.getLogger(__name__)

# cache em memória para evitar reedições repetidas
# chave: trade.id, valor: {"sync_notified": bool}
_SYNC_CACHE = {}

def _generate_trade_status_message(trade: Trade, status_title: str, pnl_data: dict = None, current_price: float = None) -> str:
    """Dashboard compacto e rico para a mensagem de status do trade (HTML)."""
    arrow = "⬆️" if trade.side == "LONG" else "⬇️"

    # --- Dados base ---
    entry = float(trade.entry_price or 0.0)
    curr  = float(current_price or 0.0)
    qty   = float(trade.qty or 0.0)
    rem   = float(trade.remaining_qty if trade.remaining_qty is not None else qty)

    # --- P/L ao vivo (fração → sempre formatar x100 na exibição) ---
    unreal_val = float((pnl_data or {}).get("unrealized_pnl", 0.0))
    unreal_frac = float((pnl_data or {}).get("unrealized_pnl_frac", 0.0))  # ex.: 0.015 = 1.5%
    unreal_pct = unreal_frac * 100.0

    # --- TP progress / próximo alvo ---
    total_tps = int(trade.total_initial_targets or 0)
    remaining_targets = list(trade.initial_targets or [])
    hit_tps = max(0, total_tps - len(remaining_targets))
    next_tp = remaining_targets[0] if remaining_targets else None

    # Barrinha de progresso de TPs (ex.: ■■□□ para 2/4)
    filled = "■" * min(hit_tps, total_tps)
    empty  = "□" * max(0, total_tps - hit_tps)
    tp_bar = f"{filled}{empty}" if total_tps > 0 else "—"

    # --- Stop Loss (rótulos úteis) ---
    sl = trade.current_stop_loss
    sl_badge = []
    if trade.is_breakeven:
        sl_badge.append("BE")
    if trade.is_stop_gain_active:
        sl_badge.append("LOCK")
    if trade.trail_high_water_mark is not None:
        sl_badge.append("TS")
    sl_tag = f" [{' / '.join(sl_badge)}]" if sl_badge else ""

    # --- Datas/metadata ---
    created_str = ""
    try:
        if trade.created_at:
            created_str = trade.created_at.strftime("%d/%m %H:%M")
    except Exception:
        pass

    # --- Montagem da mensagem ---
    lines = []
    lines.append(f"{arrow} <b>{trade.symbol} — {trade.side}</b>")
    if status_title:
        lines.append(f"🟦 <b>{status_title}</b>")
    lines.append("")

    # Preços e tamanhos
    lines.append(f"➡️ <b>Entrada:</b> ${entry:,.4f}")
    if curr:
        lines.append(f"📊 <b>Atual:</b> ${curr:,.4f}")
    lines.append(f"📦 <b>Qtd. Total:</b> {qty:g} | <b>Restante:</b> {rem:g}")
    notional = entry * qty
    lines.append(f"💵 <b>Notional (aprox.):</b> ${notional:,.2f}")
    lines.append("")

    # P/L
    lines.append(f"📈 <b>P/L Atual:</b> {unreal_val:+.2f} USDT ({unreal_pct:+.2f}%)")

    # Stop
    if sl:
        lines.append(f"🛡️ <b>Stop Loss:</b> ${float(sl):,.4f}{sl_tag}")
    else:
        lines.append("🛡️ <b>Stop Loss:</b> —")
    lines.append("")

    # TPs
    if total_tps > 0:
        lines.append(f"🎯 <b>TPs:</b> {hit_tps}/{total_tps}  {tp_bar}")
        if next_tp is not None:
            lines.append(f"   ↳ <i>Próximo:</i> ${float(next_tp):,.4f}")
        lines.append("")

    if created_str:
        lines.append(f"⏱ <i>Aberto em:</i> {created_str}")

    return "\n".join(lines)

async def check_pending_orders_for_user(application: Application, user: User, db: Session):
    """Verifica as ordens limite pendentes e envia notificação na execução.
    OFF: cancela todas as pendentes e encerra. ON: acompanha e promove para Trade quando 'Filled'.
    """

    pending_orders = db.query(PendingSignal).filter_by(user_telegram_id=user.telegram_id).all()
    if not pending_orders:
        return

    # 🔑 DECRIPTA UMA ÚNICA VEZ (antes do branch ON/OFF)
    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)

    # Se o bot estiver OFF, cancela todas as pendentes e sai
    if not user.is_active:
        for order in pending_orders:
            try:
                await cancel_order(api_key, api_secret, order.order_id, order.symbol)
            except Exception as e:
                logger.error(f"[tracker:OFF] Exceção ao cancelar {order.order_id} ({order.symbol}): {e}", exc_info=True)
            db.delete(order)
        db.commit()
        logger.info(f"[tracker:OFF] PendingSignals do usuário {user.telegram_id} cancelados/limpos.")
        return

    # Bot ON: segue o fluxo normal
    for order in pending_orders:
        status_result = await get_order_status(api_key, api_secret, order.order_id, order.symbol)
        if not status_result.get("success"):
            logger.error(f"Falha ao obter status da ordem {order.order_id}: {status_result.get('error')}")
            continue

        order_data = status_result.get("data") or {}
        order_status = (order_data.get("orderStatus") or "").strip()

        if order_status == 'Filled':
            logger.info(f"Ordem Limite {order.order_id} EXECUTADA para o usuário {user.telegram_id}.")
            signal_data = order.signal_data or {}
            
            qty = float(order_data.get('cumExecQty', 0.0))
            entry_price = float(order_data.get('avgPrice', 0.0))
            
            if qty <= 0 or entry_price <= 0:
                logger.warning(f"Ordem {order.order_id} Filled, mas com qty/preço zerado. Removendo.")
                db.delete(order)
                await application.bot.send_message(chat_id=user.telegram_id, text=f"ℹ️ Sua ordem limite para <b>{order.symbol}</b> foi finalizada sem execução reportada.", parse_mode='HTML')
                continue

            side = signal_data.get('order_type')
            leverage = user.max_leverage
            margin = (qty * entry_price) / leverage if leverage > 0 else 0
            stop_loss = signal_data.get('stop_loss')
            all_targets = signal_data.get('targets') or []
            take_profit_1 = all_targets[0] if all_targets else "N/A"
            num_targets = len(all_targets)
            tp_text = f"${float(take_profit_1):,.4f}" if isinstance(take_profit_1, (int, float)) else take_profit_1
            if num_targets > 1:
                tp_text += f" (de {num_targets} alvos)"
            
            message = (
                f"📈 <b>Ordem Limite Executada!</b>\n\n"
                f"  - 📊 <b>Tipo:</b> {side} | <b>Alavancagem:</b> {leverage}x\n"
                f"  - 💎 <b>Moeda:</b> {order.symbol}\n"
                f"  - 🔢 <b>Quantidade:</b> {qty:g}\n"
                f"  - 💵 <b>Preço de Entrada:</b> ${entry_price:,.4f}\n"
                f"  - 💰 <b>Margem:</b> ${margin:,.2f}\n"
                f"  - 🛡️ <b>Stop Loss:</b> ${stop_loss:,.4f}\n"
                f"  - 🎯 <b>Take Profit 1:</b> {tp_text}"
            )

            message_id_to_update = order.notification_message_id
            sent_message = None
            
            if message_id_to_update:
                try:
                    sent_message = await application.bot.edit_message_text(
                        chat_id=user.telegram_id,
                        message_id=message_id_to_update,
                        text=message,
                        parse_mode='HTML'
                    )
                except BadRequest as e:
                    logger.warning(f"Não foi possível editar a mensagem {message_id_to_update}. Enviando uma nova. Erro: {e}")
                    sent_message = await application.bot.send_message(chat_id=user.telegram_id, text=message, parse_mode='HTML')
            else:
                # Fallback para ordens antigas que não tinham o ID da mensagem salvo.
                sent_message = await application.bot.send_message(chat_id=user.telegram_id, text=message, parse_mode='HTML')

            new_trade = Trade(
                user_telegram_id=order.user_telegram_id, order_id=order.order_id,
                notification_message_id=sent_message.message_id, # Passa o ID correto para o trade
                symbol=order.symbol, side=side, qty=qty, entry_price=entry_price,
                stop_loss=stop_loss, current_stop_loss=stop_loss,
                initial_targets=all_targets,
                total_initial_targets=num_targets,
                status='ACTIVE', remaining_qty=qty
            )
            db.add(new_trade)
            logger.info("[order->trade] %s %s qty=%.6f entry=%.6f msg_id=%s",
                new_trade.symbol, new_trade.side, new_trade.qty, new_trade.entry_price,
                str(getattr(new_trade, "notification_message_id", None)))

            db.delete(order)


async def check_active_trades_for_user(application: Application, user: User, db: Session):
    """
    Verifica e gerencia os trades ativos, com edição de mensagem para atualizações.
    Regras:
    - TP só é considerado 'executado' após sucesso na redução (retCode == 0).
    - BREAK_EVEN/TRAILING_STOP podem ser ativados de duas formas:
        (A) Padrão: após o 1º TP.
        (B) Opcional por PnL: se user.be_trigger_pct / user.ts_trigger_pct > 0 (sem depender do 1º TP).
    Esses campos são opcionais no modelo; se não existirem ou forem 0/None, ignora-se o gatilho por PnL.
    - Semântica do OFF (user.is_active == False): não abre novas posições nem deixa ordens pendentes,
      mas ESTE gerenciador continua atuando normalmente nas posições abertas.
    """
    active_trades = db.query(Trade).filter(
        Trade.user_telegram_id == user.telegram_id,
        ~Trade.status.like('%CLOSED%')
    ).all()
    if not active_trades:
        return

    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)

    # Posições ao vivo + PnL
    live_pnl_result = await get_open_positions_with_pnl(api_key, api_secret)
    if not live_pnl_result.get("success"):
        logger.warning(f"[tracker] Falha temporária ao buscar P/L para {user.telegram_id}. Ignorando ciclo.")
        return

    live_pnl_map = {p['symbol']: p for p in (live_pnl_result.get('data') or [])}

    # Gatilhos opcionais por PnL (se o modelo não tiver os campos, getattr devolve 0)
    be_trigger_pct = float(getattr(user, "be_trigger_pct", 0) or 0.0)      # ativa BE quando PnL% >= X
    ts_trigger_pct = float(getattr(user, "ts_trigger_pct", 0) or 0.0)      # inicia TS quando PnL% >= Y

    for trade in active_trades:
        position_data = live_pnl_map.get(trade.symbol)
        live_position_size = float(position_data['size']) if position_data else 0.0

        message_was_edited = False
        status_title_update = ""
        current_price = 0.0

        # Cache de P/L no DB (fração, ex.: 0.015 = 1.5%)
        if position_data:
            trade.unrealized_pnl_pct = position_data.get("unrealized_pnl_frac", 0.0)

        if live_position_size > 0:
            # Preço de mercado
            price_result = await get_market_price(trade.symbol)
            if not price_result.get("success"):
                continue
            current_price = price_result["price"]

            # Dados de PnL atuais (fração → % só para comparação/exibição)
            pnl_data = live_pnl_map.get(trade.symbol) or {}
            pnl_frac = float(pnl_data.get("unrealized_pnl_frac") or 0.0)
            pnl_pct = pnl_frac * 100.0

            # --- STOP-GAIN por gatilho (independente de BE/TS) ---
            if (user.stop_gain_trigger_pct or 0) > 0 and not trade.is_stop_gain_active and not trade.is_breakeven:
                if pnl_pct >= float(user.stop_gain_trigger_pct):
                    log_prefix = f"[Stop-Gain {trade.symbol}]"
                    if trade.side == 'LONG':
                        new_sl = trade.entry_price * (1 + (float(user.stop_gain_lock_pct or 0) / 100))
                    else:
                        new_sl = trade.entry_price * (1 - (float(user.stop_gain_lock_pct or 0) / 100))

                    is_improvement = (trade.side == 'LONG' and new_sl > (trade.current_stop_loss or float('-inf'))) or \
                                     (trade.side == 'SHORT' and new_sl < (trade.current_stop_loss or float('inf')))
                    is_valid_to_set = (trade.side == 'LONG' and new_sl < current_price) or \
                                      (trade.side == 'SHORT' and new_sl > current_price)

                    if is_improvement and is_valid_to_set:
                        sl_result = await modify_position_stop_loss(api_key, api_secret, trade.symbol, new_sl, reason="lock")
                        if sl_result.get("success"):
                            trade.is_stop_gain_active = True
                            trade.current_stop_loss = new_sl
                            message_was_edited = True
                            status_title_update = f"💰 Stop-Gain Ativado (+{float(user.stop_gain_lock_pct or 0):.2f}%)"
                            logger.info(f"{log_prefix} SL → ${new_sl:.4f}")
                        else:
                            logger.error(f"{log_prefix} Falha ao mover SL (lock): {sl_result.get('error', 'desconhecido')}")

            # --- TAKE PROFIT (confirmação só após redução bem-sucedida) ---
            targets_executados_este_ciclo = []
            if trade.initial_targets:
                for target_price in list(trade.initial_targets):
                    hit = (trade.side == 'LONG' and current_price >= target_price) or \
                          (trade.side == 'SHORT' and current_price <= target_price)
                    if not hit:
                        continue

                    if not trade.total_initial_targets or trade.total_initial_targets <= 0:
                        logger.warning(f"{trade.symbol}: total_initial_targets inválido ({trade.total_initial_targets}).")
                        continue

                    qty_to_close = trade.qty / trade.total_initial_targets
                    position_idx_to_close = 1 if trade.side == 'LONG' else 2  # em one-way a Bybit ignora

                    logger.info("[tp:crossed] %s %s TP=%.4f last=%.4f -> tentando reduzir",
                                trade.symbol, trade.side, float(target_price), float(current_price))

                    close_result = await close_partial_position(
                        api_key, api_secret, trade.symbol, qty_to_close, trade.side, position_idx_to_close
                    )
                    if close_result.get("success"):
                        targets_executados_este_ciclo.append(target_price)
                        try:
                            trade.remaining_qty = (trade.remaining_qty or trade.qty) - qty_to_close
                            if trade.remaining_qty < 0:
                                trade.remaining_qty = 0.0
                        except Exception:
                            trade.remaining_qty = max(0.0, (trade.remaining_qty or 0.0) - qty_to_close)

                        message_was_edited = True
                        status_title_update = "🎯 Take Profit EXECUTADO!"
                        logger.info("[tp:executed] %s %s TP=%.4f closed=%.6f remaining=%.6f",
                                    trade.symbol, trade.side, float(target_price),
                                    float(qty_to_close), float(trade.remaining_qty or 0.0))
                    else:
                        logger.error("[tp:failed] %s %s TP=%.4f reason=%s",
                                     trade.symbol, trade.side, float(target_price),
                                     close_result.get("error", "desconhecido"))

            if targets_executados_este_ciclo:
                trade.initial_targets = [t for t in trade.initial_targets if t not in targets_executados_este_ciclo]
                message_was_edited = True
                if not status_title_update:
                    status_title_update = "🎯 Take Profit EXECUTADO!"

            # --- BREAK-EVEN ---
            be_trigger_hit = False
            if be_trigger_pct > 0 and not trade.is_breakeven:
                # Opcional: ativa BE por PnL, sem depender de 1º TP
                if pnl_pct >= be_trigger_pct:
                    desired_sl = float(trade.entry_price)
                    be_trigger_hit = True
            # Modo padrão: 1º TP move para BE / TPs seguintes avançam
            if user.stop_strategy == 'BREAK_EVEN':
                if targets_executados_este_ciclo or be_trigger_hit:
                    if targets_executados_este_ciclo:
                        tp_ref = max(targets_executados_este_ciclo) if trade.side == 'LONG' else min(targets_executados_este_ciclo)
                        if trade.is_breakeven:
                            desired_sl = float(tp_ref)  # avança para o TP atingido
                            reason = f"Break-Even Avançado (TP {tp_ref:.4f})"
                        else:
                            desired_sl = float(trade.entry_price)
                            reason = "Break-Even Ativado (1º TP)"
                    else:
                        # veio do gatilho por PnL
                        reason = f"Break-Even por PnL ({pnl_pct:.2f}%)"

                    is_improvement = (trade.side == 'LONG' and desired_sl > (trade.current_stop_loss or float('-inf'))) or \
                                     (trade.side == 'SHORT' and desired_sl < (trade.current_stop_loss or float('inf')))
                    is_valid_to_set = (trade.side == 'LONG' and desired_sl < current_price) or \
                                      (trade.side == 'SHORT' and desired_sl > current_price)

                    if is_improvement and is_valid_to_set:
                        sl_result = await modify_position_stop_loss(api_key, api_secret, trade.symbol, desired_sl, reason="be")
                        if sl_result.get("success"):
                            trade.is_breakeven = True
                            trade.current_stop_loss = desired_sl
                            message_was_edited = True
                            status_title_update = f"🛡️ {reason}"
                            logger.info("[be:set] %s %s SL=%.4f last=%.4f", trade.symbol, trade.side, desired_sl, float(current_price))
                        else:
                            logger.error("[be:failed] %s SL=%.4f reason=%s", trade.symbol, desired_sl, sl_result.get('error', 'desconhecido'))

            # --- TRAILING STOP ---
            if user.stop_strategy == 'TRAILING_STOP':
                # Começo do TS: (A) após 1º TP (padrão) ou (B) por PnL opcional
                first_tp_hit = trade.total_initial_targets is not None and \
                                 trade.initial_targets is not None and \
                               len(trade.initial_targets) < trade.total_initial_targets
                ts_started = first_tp_hit or (ts_trigger_pct > 0 and pnl_pct >= ts_trigger_pct)

                if ts_started:
                    log_prefix = f"[Trailing Stop {trade.symbol}]"
                    if not trade.is_breakeven:
                        # Primeiro passo do TS = mover para BE
                        new_sl = float(trade.entry_price)
                        sl_result = await modify_position_stop_loss(api_key, api_secret, trade.symbol, new_sl, reason="ts")
                        if sl_result.get("success"):
                            trade.is_breakeven = True
                            trade.current_stop_loss = new_sl
                            trade.trail_high_water_mark = new_sl
                            message_was_edited = True
                            status_title_update = "🛡️ Stop Movido (Break-Even)"
                            logger.info(f"{log_prefix} SL → BE (${new_sl:.4f}) (gatilho: {'TP' if first_tp_hit else f'PnL {pnl_pct:.2f}%'})")
                        else:
                            logger.error(f"{log_prefix} Falha ao mover SL para BE: {sl_result.get('error', 'desconhecido')}")
                    else:
                        # Atualiza HWM e recalcula SL "seguindo" o preço
                        if trade.trail_high_water_mark is None:
                            trade.trail_high_water_mark = trade.entry_price
                        new_hwm = trade.trail_high_water_mark
                        if trade.side == 'LONG' and current_price > new_hwm:
                            new_hwm = current_price
                        elif trade.side == 'SHORT' and current_price < new_hwm:
                            new_hwm = current_price

                        if new_hwm != trade.trail_high_water_mark:
                            logger.info(f"{log_prefix} Novo pico: ${new_hwm:.4f}")
                            trade.trail_high_water_mark = new_hwm

                        # Distância do rastro: usa SL inicial se houver; fallback 2% da entrada
                        trail_distance = abs(trade.entry_price - (trade.stop_loss or trade.entry_price * 0.98)) \
                                         if trade.stop_loss is not None else trade.entry_price * 0.02
                        potential_new_sl = new_hwm - trail_distance if trade.side == 'LONG' else new_hwm + trail_distance

                        is_improvement = (trade.side == 'LONG' and potential_new_sl > (trade.current_stop_loss or float('-inf'))) or \
                                         (trade.side == 'SHORT' and potential_new_sl < (trade.current_stop_loss or float('inf')))
                        if is_improvement:
                            is_valid_to_set = (trade.side == 'LONG' and potential_new_sl < current_price) or \
                                              (trade.side == 'SHORT' and potential_new_sl > current_price)
                            if is_valid_to_set:
                                sl_result = await modify_position_stop_loss(api_key, api_secret, trade.symbol, potential_new_sl, reason="ts")
                                if sl_result.get("success"):
                                    trade.current_stop_loss = potential_new_sl
                                    message_was_edited = True
                                    status_title_update = "📈 Trailing Stop Ajustado"
                                else:
                                    logger.error(f"{log_prefix} Falha ao mover Trailing SL: {sl_result.get('error', 'desconhecido')}")

            # --- Mensagem viva (status em aberto) ---
            if message_was_edited:
                pnl_data_for_msg = live_pnl_map.get(trade.symbol)
                msg_text = _generate_trade_status_message(trade, status_title_update, pnl_data_for_msg, current_price)
                await _send_or_edit_trade_message(application, user, trade, db, msg_text)

async def run_tracker(application: Application):
    """Função principal que roda o verificador em loop para TODOS os usuários."""
    logger.info("Iniciando Rastreador de Posições e Ordens (Modo Multiusuário)...")
    while True:
        cycle_started = time.perf_counter()
        total_users = 0
        adopted_count = 0

        db = SessionLocal()
        try:
            # --- LÓGICA DE SINCRONIZAÇÃO APRIMORADA ---
            all_api_users_for_sync = db.query(User).filter(User.api_key_encrypted.isnot(None)).all()
            for user in all_api_users_for_sync:
                total_users += 1
                sync_api_key = decrypt_data(user.api_key_encrypted)
                sync_api_secret = decrypt_data(user.api_secret_encrypted)

                # Wrapper para o detetive: usa suas credenciais e adapta o formato
                async def _fetch_closed_info(symbol: str) -> Optional[Dict[str, Any]]:
                    res = await get_last_closed_trade_info(sync_api_key, sync_api_secret, symbol)
                    if not res or not res.get("success"):
                        return None
                    d = res.get("data") or {}
                    # padroniza campos esperados pelo detetive
                    return {
                        "pnl": float(d.get("closedPnl", 0.0)) if d.get("closedPnl") is not None else None,
                        "exit_type": d.get("exitType"),
                        "exit_price": d.get("exitPrice"),
                        "closed_at": d.get("closedAt"),
                    }

                bybit_positions_result = await get_open_positions_with_pnl(sync_api_key, sync_api_secret)
                if not bybit_positions_result.get("success"):
                    logger.error(f"Sincronização: Falha ao buscar posições da Bybit para o usuário {user.telegram_id}. Pulando.")
                    continue

                bybit_list = bybit_positions_result.get("data", []) or []
                bybit_keys = {(p["symbol"], p["side"]) for p in bybit_list}
                bybit_map = {(p["symbol"], p["side"]): p for p in bybit_list}

                # [NOVO] conjunto só por símbolo (ignora side)
                bybit_symbols = {p["symbol"] for p in bybit_list}

                # [NOVO] mapa por símbolo -> se tiver mais de uma entrada do mesmo símbolo,
                # fica com a de maior tamanho absoluto (mais relevante)
                bybit_map_by_symbol: Dict[str, Dict[str, Any]] = {}
                for p in bybit_list:
                    sym = p["symbol"]
                    if sym not in bybit_map_by_symbol:
                        bybit_map_by_symbol[sym] = p
                    else:
                        prev = bybit_map_by_symbol[sym]
                        if abs(float(p.get("size") or 0)) > abs(float(prev.get("size") or 0)):
                            bybit_map_by_symbol[sym] = p

                db_active_trades = db.query(Trade).filter(
                    Trade.user_telegram_id == user.telegram_id,
                    ~Trade.status.like('%CLOSED%')
                ).all()
            
                db_pending_signals = db.query(PendingSignal).filter(
                    PendingSignal.user_telegram_id == user.telegram_id
                ).all()
                db_pending_symbols = {s.symbol for s in db_pending_signals}

                # [NOVO] Adotar órfãs por SÍMBOLO (ignora side)
                db_active_symbols = {t.symbol for t in db_active_trades}
                # db_pending_symbols você JÁ construiu acima e é um set de strings: {s.symbol for s in db_pending_signals}

                symbols_to_adopt = bybit_symbols - db_active_symbols - db_pending_symbols
                for symbol in symbols_to_adopt:
                    adopted_count += 1
                    pos = bybit_map_by_symbol.get(symbol)
                    if not pos:
                        continue  # segurança

                    side = pos.get("side")
                    entry = float(pos.get("entry", 0) or 0)
                    size = float(pos.get("size", 0) or 0)
                    curr_sl = pos.get("stop_loss") or None

                    new_trade = Trade(
                        user_telegram_id=user.telegram_id,
                        order_id=f"sync_{symbol}_{int(time.time())}",
                        symbol=symbol,
                        side=side,
                        qty=size,
                        remaining_qty=size,
                        entry_price=entry,
                        status='ACTIVE_SYNCED',
                        stop_loss=curr_sl,
                        current_stop_loss=curr_sl,
                        initial_targets=[],
                        total_initial_targets=0
                    )

                    cand = db.query(PendingSignal).filter_by(
                        user_telegram_id=user.telegram_id, symbol=symbol
                    ).order_by(PendingSignal.id.desc()).first()
                    if cand and cand.signal_data:
                        try:
                            tps = cand.signal_data.get('targets') or []
                            new_trade.initial_targets = tps
                            new_trade.total_initial_targets = len(tps)
                            if not curr_sl and cand.signal_data.get('stop_loss'):
                                new_trade.stop_loss = cand.signal_data['stop_loss']
                                new_trade.current_stop_loss = new_trade.stop_loss
                            db.delete(cand)
                            logger.info("[sync:recover-signal] %s: recuperados %d TP(s) e SL.", symbol, len(tps))
                        except Exception:
                            logger.exception("[sync:recover-signal] falhou ao mapear sinal para %s", symbol)

                    db.add(new_trade)

                    msg = (
                        f"⚠️ <b>Posição Sincronizada</b>\n"
                        f"Moeda: <b>{symbol}</b> | Lado: <b>{side}</b>\n"
                        f"A posição foi encontrada aberta na Bybit e adotada pelo bot.\n"
                        f"{'Alvos/SL recuperados.' if new_trade.total_initial_targets else 'Sem alvos conhecidos.'}"
                    )
                    await application.bot.send_message(chat_id=user.telegram_id, text=msg, parse_mode='HTML')

                # [NOVO] Fechar fantasmas com tolerância (aplica janela de 3 ciclos)
                await apply_missing_cycles_policy(
                    application=application,
                    user=user,
                    db=db,
                    db_active_trades=db_active_trades,
                    bybit_keys=bybit_keys,
                    threshold=3,  # configurável no futuro via env/setting se necessário
                    get_last_closed_trade_info=_fetch_closed_info,
                )

            duration = time.perf_counter() - cycle_started
            logger.info("[cycle] resumo: usuarios=%d, adotadas=%d, duracao=%.2fs",
            total_users, adopted_count, duration)

            db.commit()

            # --- Lógica de verificação normal ---
            all_users = db.query(User).filter(User.api_key_encrypted.isnot(None)).all()
            if all_users:
                logger.info(f"Rastreador: Verificando assets para {len(all_users)} usuário(s).")
                for user in all_users:
                    await check_pending_orders_for_user(application, user, db)
                    await check_active_trades_for_user(application, user, db)
                db.commit()
            else:
                logger.info("Rastreador: Nenhum usuário com API para verificar.")

        except Exception as e:
            logger.critical(f"Erro crítico no loop do rastreador: {e}", exc_info=True)
            db.rollback()
        finally:
            db.close()

        await asyncio.sleep(60)

async def notify_sync_status(application, user, trade, text: Optional[str] = None) -> None:
    """
    Edita o card para estado 'sincronizando' no 2º ciclo ausente.
    Evita repetir a mesma edição em ciclos seguintes.
    """
    if trade is None or not getattr(trade, "notification_message_id", None):
        return

    cache = _SYNC_CACHE.setdefault(trade.id, {"sync_notified": False})
    if cache["sync_notified"]:
        return  # já notificou este estado; não spammar

    sync_text = text or (
        "⏳ <b>Sincronizando com a corretora…</b>\n"
        "Estamos confirmando o status desta posição. O card será atualizado automaticamente."
    )
    try:
        await application.bot.edit_message_text(
            chat_id=user.telegram_id,
            message_id=trade.notification_message_id,
            text=sync_text,
            parse_mode="HTML",
        )
        cache["sync_notified"] = True
        logger.info("[sync] %s/%s marcado como 'sincronizando' (2º ciclo ausente).",
                    trade.symbol, trade.side)
    except Exception:
        logger.exception("[sync] Falha ao editar mensagem para estado 'sincronizando' (%s).", trade.symbol)

def clear_sync_flag(trade_id: int) -> None:
    """Reseta a flag de sync para quando a posição reaparece ou fecha definitivamente."""
    state = _SYNC_CACHE.get(trade_id)
    if state:
        state["sync_notified"] = False

async def confirm_and_close_trade(
    *,
    application,
    user,
    trade,
    get_last_closed_trade_info: Optional[Callable[[str], Awaitable[Optional[Dict[str, Any]]]]] = None,
    attempts: int = 3,
    delay_seconds: float = 6.0,
    fallback_text: Optional[str] = None,
) -> None:
    """
    Antes de marcar CLOSED_GHOST, tenta confirmar fechamento real.
    Se encontrar dados, edita o card com resumo e fecha; senão, usa fallback simples.
    """
    info = None
    if get_last_closed_trade_info:
        for i in range(1, attempts + 1):
            try:
                info = await get_last_closed_trade_info(trade.symbol)
                if info:
                    break
            except Exception:
                logger.exception("[close-confirm] tentativa %d falhou para %s", i, trade.symbol)
            await asyncio.sleep(delay_seconds)

        # Monta texto final (UX padronizada)
    def _fmt_money(v):
        try:
            return f"${float(v):,.2f}"
        except Exception:
            return str(v)

    side = getattr(trade, "side", "") or ""
    qty  = getattr(trade, "qty", None)
    entry = getattr(trade, "entry_price", None)

    if info:
        pnl = info.get("pnl")
        exit_type = (info.get("exit_type") or "Fechamento").strip()
        exit_price = info.get("exit_price")
        closed_at = info.get("closed_at")

        # Título amigável por tipo
        if str(exit_type).lower().startswith("take"):
            title = "🏆 Posição Fechada (Take Profit)"
        elif str(exit_type).lower().startswith("stop"):
            title = "🛡️ Posição Fechada (Stop)"
        else:
            title = "✅ Posição Fechada"

        lines = [f"<b>{title}</b> — <b>{trade.symbol}</b> {side}"]
        if qty is not None:
            lines.append(f"• Quantidade: <b>{qty:g}</b>")
        if entry is not None:
            lines.append(f"• Entrada: <b>{_fmt_money(entry)}</b>")
        if exit_price is not None:
            lines.append(f"• Saída: <b>{_fmt_money(exit_price)}</b>")
        if pnl is not None:
            pnl_prefix = "Lucro" if float(pnl) >= 0 else "Prejuízo"
            lines.append(f"• {pnl_prefix}: <b>{_fmt_money(pnl)}</b>")
        if closed_at:
            lines.append(f"• Horário: <b>{closed_at}</b>")

        final_text = "\n".join(lines)
    else:
        # Fallback neutro e informativo
        lines = [
            f"ℹ️ <b>Posição Encerrada</b> — <b>{trade.symbol}</b> {side}",
        ]
        if qty is not None:
            lines.append(f"• Quantidade: <b>{qty:g}</b>")
        if entry is not None:
            lines.append(f"• Entrada: <b>{_fmt_money(entry)}</b>")
        lines.append("• Detalhes de saída/PnL não disponíveis no momento.")
        lines.append("• O resumo pode aparecer nas próximas sincronizações.")
        final_text = "\n".join(lines)

    try:
        if getattr(trade, "notification_message_id", None):
            await application.bot.edit_message_text(
                chat_id=user.telegram_id,
                message_id=trade.notification_message_id,
                text=final_text,
                parse_mode="HTML",
            )
    except Exception:
        logger.exception("[close-confirm] Falha ao editar mensagem final para %s.", trade.symbol)

# [ATUALIZAÇÃO] política de tolerância + UX etapa 2
async def apply_missing_cycles_policy(
    application,
    user,
    db,
    db_active_trades,
    bybit_keys,
    threshold: int = 3,
    get_last_closed_trade_info: Optional[Callable[[str], Awaitable[Optional[Dict[str, Any]]]]] = None,
):
    """
    - Vistas neste ciclo: zera missing_cycles, atualiza last_seen_at e limpa flag de sync.
    - Ausentes: incrementa missing_cycles.
      * 2º ciclo: edita mensagem para '⏳ Sincronizando...'
      * >=3º ciclo: roda detetive; se confirmar, edita resumo; senão, fallback; então fecha.
    """
    bybit_symbols = {k[0] for k in bybit_keys}  # extrai só o símbolo do par (symbol, side)

    # 1) Trades vistas: reset + limpar flag de sync
    for t in db_active_trades:
        if t.symbol in bybit_symbols:
            if getattr(t, "missing_cycles", 0) != 0:
                logger.info("[sync] %s/%s visto novamente. Reset %d→0.", t.symbol, t.side, t.missing_cycles)
            t.missing_cycles = 0
            t.last_seen_at = func.now()
            if getattr(t, "id", None) is not None:
                clear_sync_flag(t.id)

    # 2) Trades ausentes
    # ignoramos side: ausente se o símbolo não está vindo da Bybit
    for t in db_active_trades:
        if t.symbol in bybit_symbols:
            continue

        prev = int(getattr(t, "missing_cycles", 0) or 0)
        t.missing_cycles = prev + 1
        logger.warning("[sync] %s/%s ausente (ciclo %d/%d).", t.symbol, t.side, t.missing_cycles, threshold)

        # 2º ciclo → mensagem neutra
        if t.missing_cycles == 2:
            await notify_sync_status(application, user, t)

            logger.info("[sync] %s/%s entrou em estado 'sincronizando' (ciclo 2/%d).", t.symbol, t.side, threshold)

        # 3º ciclo+ → detetive e fechamento
        if t.missing_cycles >= threshold:

            logger.info("[sync] %s/%s atingiu limiar de fechamento (ciclo %d/%d). Iniciando detetive…",
            t.symbol, t.side, t.missing_cycles, threshold)

            await confirm_and_close_trade(
                application=application,
                user=user,
                trade=t,
                get_last_closed_trade_info=get_last_closed_trade_info,
            )
            # marca fechado (mantém status por compatibilidade)
            t.status = "CLOSED_GHOST"
            t.closed_at = func.now()
            t.closed_pnl = t.closed_pnl or 0.0
            t.remaining_qty = 0.0
            if getattr(t, "id", None) is not None:
                clear_sync_flag(t.id)

async def _send_or_edit_trade_message(
    application: Application,
    user: User,
    trade: Trade,
    db: Session,
    text: str
) -> None:
    """
    Atualiza a 'mensagem viva' do trade de forma resiliente:
    - Se existe message_id → tenta editar.
    - Se a edição falhar (mensagem apagada/não editável) → envia nova
      e atualiza trade.notification_message_id no banco.
    """
    # 1) Tenta editar se já temos uma mensagem anterior
    if getattr(trade, "notification_message_id", None):
        try:
            await application.bot.edit_message_text(
                chat_id=user.telegram_id,
                message_id=trade.notification_message_id,
                text=text,
                parse_mode="HTML",
            )
            return  # sucesso, nada mais a fazer
        except BadRequest:
            # Qualquer falha típica de edição (apagada, muito antiga, etc.) → recriar
            pass
        except Exception:
            # Falha inesperada → também tenta recriar como fallback
            pass

    # 2) Não havia mensagem ou edição falhou → envia nova
    new_msg = await application.bot.send_message(
        chat_id=user.telegram_id,
        text=text,
        parse_mode="HTML",
    )
    trade.notification_message_id = new_msg.message_id
    logger.info("[msg:new] %s/%s nova_msg_id=%s",
            trade.symbol, trade.side, str(trade.notification_message_id))

    # 3) Persiste o novo ID no banco
    try:
        db.commit()
    except Exception:
        db.rollback()
        raise


========================================
# Arquivo: core/trade_manager.py
========================================

import os
import asyncio
import logging
import pytz
import pandas as pd
import pandas_ta as ta
from typing import Tuple
from telegram.ext import Application
from sqlalchemy.orm import Session
from database.session import SessionLocal
from database.models import User, Trade, PendingSignal, SignalForApproval
from services.bybit_service import (
    place_order, get_account_info,
    place_limit_order, cancel_order,
    get_order_history,
    get_historical_klines
)
from services.notification_service import send_notification
from utils.security import decrypt_data
from utils.config import ADMIN_ID
from bot.keyboards import signal_approval_keyboard
from services.signal_parser import SignalType
from core.whitelist_service import is_coin_in_whitelist
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)


async def _avaliar_sinal(signal_data: dict, user_settings: User) -> Tuple[bool, str]:
    """
    Avalia um sinal com base na confiança mínima e nos filtros de análise técnica (MA e RSI), se ativos.
    """
    # Filtro 1: Confiança Mínima (lógica existente)
    min_confidence = user_settings.min_confidence
    signal_confidence = signal_data.get('confidence', 0.0)
    if signal_confidence is not None and signal_confidence < min_confidence:
        motivo = f"Confiança ({signal_confidence:.2f}%) é menor que o seu mínimo ({min_confidence:.2f}%)"
        return False, motivo

    # --- INÍCIO DA NOVA LÓGICA DE FILTROS TÉCNICOS ---
    
    # Se nenhum filtro técnico estiver ativo, aprova o sinal aqui
    if not user_settings.is_ma_filter_enabled and not user_settings.is_rsi_filter_enabled:
        return True, "Sinal aprovado pelos seus critérios."

    symbol = signal_data.get("coin")
    side = signal_data.get("order_type")
    
    # Unifica a busca de dados se os timeframes forem os mesmos para MA e RSI
    required_timeframes = set()
    if user_settings.is_ma_filter_enabled:
        required_timeframes.add(user_settings.ma_timeframe)
    if user_settings.is_rsi_filter_enabled:
        required_timeframes.add(user_settings.rsi_timeframe)

    hist_data_map = {}
    for tf in required_timeframes:
        klines_result = await get_historical_klines(symbol=symbol, interval=tf, limit=200)
        if not klines_result.get("success"):
            logger.warning(f"Não foi possível obter dados históricos para {symbol} no timeframe {tf}. Filtros para este timeframe serão ignorados.")
            hist_data_map[tf] = None
            continue
        
        # Converte os dados para um DataFrame do Pandas
        df = pd.DataFrame(klines_result['data'], columns=['startTime', 'open', 'high', 'low', 'close', 'volume', 'turnover'])
        df['close'] = pd.to_numeric(df['close']) # Garante que os preços são numéricos
        hist_data_map[tf] = df

    # Filtro 2: Média Móvel (MA)
    if user_settings.is_ma_filter_enabled:
        df_ma = hist_data_map.get(user_settings.ma_timeframe)
        if df_ma is not None:
            ma_period = user_settings.ma_period
            df_ma.ta.sma(length=ma_period, append=True) # Calcula e adiciona a coluna da MA
            
            latest_close = df_ma['close'].iloc[0]
            latest_ma = df_ma[f'SMA_{ma_period}'].iloc[0]

            if side == 'LONG' and latest_close < latest_ma:
                return False, f"Rejeitado por Média Móvel (preço {latest_close:.4f} < MA {latest_ma:.4f})"
            if side == 'SHORT' and latest_close > latest_ma:
                return False, f"Rejeitado por Média Móvel (preço {latest_close:.4f} > MA {latest_ma:.4f})"

    # Filtro 3: Índice de Força Relativa (RSI)
    if user_settings.is_rsi_filter_enabled:
        df_rsi = hist_data_map.get(user_settings.rsi_timeframe)
        if df_rsi is not None:
            oversold = user_settings.rsi_oversold_threshold
            overbought = user_settings.rsi_overbought_threshold
            df_rsi.ta.rsi(append=True) # Calcula e adiciona a coluna do RSI
            
            latest_rsi = df_rsi['RSI_14'].iloc[0]

            if side == 'LONG' and latest_rsi > overbought:
                return False, f"Rejeitado por RSI (RSI {latest_rsi:.2f} > Sobrecompra {overbought})"
            if side == 'SHORT' and latest_rsi < oversold:
                return False, f"Rejeitado por RSI (RSI {latest_rsi:.2f} < Sobrevenda {oversold})"
    
    # --- FIM DA NOVA LÓGICA ---

    return True, "Sinal aprovado pelos seus critérios e filtros técnicos."

async def _execute_trade(signal_data: dict, user: User, application: Application, db: Session, source_name: str):
    """Executa uma ordem a MERCADO, busca os detalhes da execução e envia uma notificação detalhada."""
    if not user.is_active:
        await application.bot.send_message(
            chat_id=user.telegram_id,
            text="⏸️ Bot está PAUSADO: não abrirei novas posições. (As posições abertas seguem sendo gerenciadas.)"
        )
        return
    
    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)
    
    account_info = await get_account_info(api_key, api_secret)
    if not account_info.get("success"):
        await application.bot.send_message(chat_id=user.telegram_id, text=f"❌ Falha ao buscar seu saldo Bybit para operar {signal_data['coin']}.")
        return

    balance_data = account_info.get("data", {})
    balance = float(balance_data.get('available_balance_usdt', 0))

    order_result = await place_order(api_key, api_secret, signal_data, user, balance)
    
    if order_result.get("success"):
        order_data = order_result['data']
        order_id = order_data['orderId']
        
        await asyncio.sleep(2)
        final_order_data_result = await get_order_history(api_key, api_secret, order_id)
        if not final_order_data_result.get("success"):
            await application.bot.send_message(chat_id=user.telegram_id, text=f"⚠️ Ordem {signal_data['coin']} enviada, mas falha ao confirmar detalhes. Verifique na corretora.")
            return
        final_order_data = final_order_data_result['data']
        
        symbol = signal_data['coin']
        side = signal_data['order_type']
        leverage = user.max_leverage
        qty = float(final_order_data.get('cumExecQty', 0))
        entry_price = float(final_order_data.get('avgPrice', 0))
        
        if qty == 0 or entry_price == 0:
            await application.bot.send_message(chat_id=user.telegram_id, text=f"⚠️ Ordem {symbol} enviada, mas a execução reportou quantidade/preço zerado.")
            return
            
        margin = (qty * entry_price) / leverage if leverage > 0 else 0
        stop_loss = signal_data['stop_loss']
        
        all_targets = signal_data.get('targets') or []
        num_targets = len(all_targets)

        # COMENTÁRIO: Lógica de formatação dos TPs foi refatorada para listar todos os alvos.
        tp_text_lines = []
        if all_targets:
            tp_text_lines.append("  - 🎯 <b>Alvos (TPs):</b>")
            for i, target in enumerate(all_targets, 1):
                price = float(target)
                tp_text_lines.append(f"    - T{i}: ${price:,.4f}")
        else:
            tp_text_lines.append("  - 🎯 <b>Take Profit:</b> N/A")
        tp_text = "\n".join(tp_text_lines)

        confidence_text = ""
        signal_confidence = signal_data.get('confidence')
        if signal_confidence is not None:
            confidence_text = f"  - 🟢 <b>Confiança:</b> {signal_confidence:.2f}%\n"

        message = (
            f"📈 <b>Ordem a Mercado Aberta!</b>\n\n"
            f"{confidence_text}"
            f"  - 📊 <b>Tipo:</b> {side} | <b>Alavancagem:</b> {leverage}x\n"
            f"  - 💎 <b>Moeda:</b> {symbol}\n"
            f"  - 🔢 <b>Quantidade:</b> {qty:g}\n"
            f"  - 💵 <b>Preço de Entrada:</b> ${entry_price:,.4f}\n"
            f"  - 💰 <b>Margem:</b> ${margin:,.2f}\n"
            f"  - 🛡️ <b>Stop Loss:</b> ${stop_loss:,.4f}\n"
            f"{tp_text}"
        )
        sent_message = await application.bot.send_message(chat_id=user.telegram_id, text=message, parse_mode='HTML')

        new_trade = Trade(
            user_telegram_id=user.telegram_id, order_id=order_id,
            notification_message_id=sent_message.message_id,
            symbol=symbol, side=side, qty=qty, entry_price=entry_price,
            stop_loss=stop_loss, current_stop_loss=stop_loss,
            initial_targets=all_targets,
            total_initial_targets=num_targets,
            status='ACTIVE',
            remaining_qty=qty
        )
        db.add(new_trade)
        logger.info(f"Trade {order_id} para o usuário {user.telegram_id} salvo no DB com dados de execução.")

async def process_new_signal(signal_data: dict, application: Application, source_name: str):
    """Processa um novo sinal, verificando a preferência de cada usuário individualmente."""
    signal_type = signal_data.get("type")
    symbol = signal_data.get("coin")
    db = SessionLocal()
    try:
        if signal_type == SignalType.CANCELAR:
            # --- INÍCIO DA LÓGICA DE CANCELAMENTO CORRIGIDA ---
            logger.info(f"Recebido sinal de cancelamento para {symbol}. Buscando ordens pendentes...")
            
            pending_orders_to_cancel = db.query(PendingSignal).filter(PendingSignal.symbol == symbol).all()

            if not pending_orders_to_cancel:
                logger.info(f"Nenhuma ordem limite pendente encontrada para {symbol}. Nenhuma ação necessária.")
                return

            logger.info(f"Encontradas {len(pending_orders_to_cancel)} ordem(ns) pendente(s) para {symbol} para cancelar.")
            
            for pending in pending_orders_to_cancel:
                user = db.query(User).filter(User.telegram_id == pending.user_telegram_id).first()
                if not user or not user.api_key_encrypted:
                    logger.warning(f"Não foi possível encontrar usuário ou chaves de API para a ordem pendente ID:{pending.id}. Pulando.")
                    continue

                api_key = decrypt_data(user.api_key_encrypted)
                api_secret = decrypt_data(user.api_secret_encrypted)

                cancel_result = await cancel_order(
                    api_key=api_key,
                    api_secret=api_secret,
                    order_id=pending.order_id,
                    symbol=pending.symbol
                )

                if cancel_result.get("success"):
                    logger.info(f"Ordem {pending.order_id} ({symbol}) cancelada com sucesso para o usuário {user.telegram_id}.")
                    db.delete(pending)
                    await application.bot.send_message(
                        chat_id=user.telegram_id,
                        text=f"ℹ️ Sua ordem limite pendente para <b>{symbol}</b> foi cancelada pela fonte do sinal.",
                        parse_mode='HTML'
                    )
                else:
                    error_msg = cancel_result.get("error", "Erro desconhecido")
                    logger.error(f"Falha ao cancelar ordem {pending.order_id} ({symbol}) para o usuário {user.telegram_id}. Erro: {error_msg}")
                    await application.bot.send_message(
                        chat_id=user.telegram_id,
                        text=f"⚠️ Falha ao tentar cancelar sua ordem limite para <b>{symbol}</b>. Verifique na corretora.\n<b>Motivo:</b> {error_msg}",
                        parse_mode='HTML'
                    )
            
            db.commit()
            return

        elif signal_type in [SignalType.MARKET, SignalType.LIMIT]:
            all_users = db.query(User).filter(User.api_key_encrypted.isnot(None)).all()
            if not all_users:
                logger.info("Nenhum usuário com API para processar o sinal.")
                return

            logger.info(f"Sinal para {symbol} recebido. Verificando preferências de {len(all_users)} usuário(s)...")

            for user in all_users:
                if user.is_sleep_mode_enabled:
                    br_timezone = pytz.timezone("America/Sao_Paulo")
                    now_br = datetime.now(br_timezone).time()
                    
                    # O bot fica offline das 00:00 (incluso) até 07:00 (excluso)
                    if 0 <= now_br.hour < 7:
                        logger.info(f"Sinal para {symbol} ignorado para o usuário {user.telegram_id} devido ao Modo Dormir ativo.")
                        continue # Pula para o próximo usuário

                # 1. Verifica se há uma pausa ativa para a direção do sinal
                signal_side = signal_data.get('order_type')
                is_paused = False
                if signal_side == 'LONG' and user.long_trades_paused_until and datetime.utcnow() < user.long_trades_paused_until:
                    is_paused = True
                elif signal_side == 'SHORT' and user.short_trades_paused_until and datetime.utcnow() < user.short_trades_paused_until:
                    is_paused = True
                
                if is_paused:
                    logger.info(f"Sinal de {signal_side} para {symbol} ignorado para o usuário {user.telegram_id} devido à pausa do disjuntor.")
                    continue

                # 2. Se não estiver pausado, verifica se o gatilho de perdas é atingido
                if user.circuit_breaker_threshold > 0:
                    losing_trades_count = db.query(Trade).filter(
                        Trade.user_telegram_id == user.telegram_id,
                        Trade.side == signal_side,
                        Trade.status == 'ACTIVE',
                        Trade.unrealized_pnl_pct < 0
                    ).count()

                    if losing_trades_count >= user.circuit_breaker_threshold:
                        logger.warning(f"DISJUNTOR ATIVADO para {signal_side} para o usuário {user.telegram_id}. ({losing_trades_count} perdas ativas)")
                        
                        # Ativa a pausa
                        pause_until = datetime.now(pytz.utc) + timedelta(minutes=user.circuit_breaker_pause_minutes)
                        if signal_side == 'LONG':
                            user.long_trades_paused_until = pause_until
                        else: # SHORT
                            user.short_trades_paused_until = pause_until
                        
                        # Notifica o usuário
                        await application.bot.send_message(
                            chat_id=user.telegram_id,
                            text=f"🚨 <b>Disjuntor de Performance Ativado!</b> 🚨\n\n"
                                 f"Detectamos {losing_trades_count} operações de <b>{signal_side}</b> em prejuízo.\n"
                                 f"Para sua segurança, novas operações de <b>{signal_side}</b> estão pausadas por {user.circuit_breaker_pause_minutes} minutos.",
                            parse_mode='HTML'
                        )
                        continue # Rejeita o sinal atual

                # Adiciona uma verificação para ver se o bot do usuário está ativo.
                if not user.is_active:
                    logger.info(f"Sinal para {symbol} ignorado para o usuário {user.telegram_id} porque o bot está pausado.")
                    continue

                # 1. Avalia o sinal contra os filtros do usuário
                aprovado, motivo = await _avaliar_sinal(signal_data, user)
                if not aprovado:
                    logger.info(f"Sinal para {symbol} ignorado para o usuário {user.telegram_id}: {motivo}")
                    continue
                
                # 2. Verifica a whitelist do usuário
                if not is_coin_in_whitelist(symbol, user.coin_whitelist):
                    logger.info(f"Sinal para {symbol} ignorado para o usuário {user.telegram_id} devido à whitelist.")
                    continue

                # 3. Verifica o modo de aprovação individual do usuário
                if user.approval_mode == 'AUTOMATIC':
                    logger.info(f"Usuário {user.telegram_id} em modo AUTOMÁTICO. Executando trade para {symbol}.")
                    if signal_type == SignalType.MARKET:
                        await _execute_trade(signal_data, user, application, db, source_name)
                    elif signal_type == SignalType.LIMIT:
                        await _execute_limit_order_for_user(signal_data, user, application, db)

                elif user.approval_mode == 'MANUAL':
                    logger.info(f"Usuário {user.telegram_id} em modo MANUAL. Enviando sinal para sua aprovação.")
                    
                    new_signal_for_approval = SignalForApproval(
                        user_telegram_id=user.telegram_id,  # <-- Agora salva o ID do usuário correto
                        symbol=symbol,
                        source_name=source_name,
                        signal_data=signal_data
                    )
                    db.add(new_signal_for_approval)
                    db.commit() # Commit para obter o ID

                    signal_details = (
                        f"<b>Sinal Recebido para Aprovação</b>\n\n"
                        f"<b>Moeda:</b> {signal_data['coin']}\n"
                        f"<b>Tipo:</b> {signal_data['order_type']}\n<b>Entrada:</b> {signal_data['entries'][0]}\n"
                        f"<b>Stop:</b> {signal_data['stop_loss']}\n<b>Alvo 1:</b> {signal_data['targets'][0]}\n\n"
                        f"O sinal passou nos seus filtros. Você aprova a entrada?"
                    )
                    sent_message = await application.bot.send_message(
                        chat_id=user.telegram_id, # <-- Envia para o usuário específico
                        text=signal_details, parse_mode='HTML',
                        reply_markup=signal_approval_keyboard(new_signal_for_approval.id)
                    )
                    new_signal_for_approval.approval_message_id = sent_message.message_id
        
        db.commit()
    finally:
        db.close()

async def _execute_limit_order_for_user(signal_data: dict, user: User, application: Application, db: Session):
    """Função auxiliar para posicionar uma ordem limite para um único usuário."""
    if not user.is_active:
        await application.bot.send_message(
            chat_id=user.telegram_id,
            text="⏸️ Bot está PAUSADO: não abrirei novas posições. (As posições abertas seguem sendo gerenciadas.)"
        )
        return

    symbol = signal_data.get("coin")
    existing_pending = db.query(PendingSignal).filter_by(user_telegram_id=user.telegram_id, symbol=symbol).first()
    if existing_pending:
        await application.bot.send_message(chat_id=user.telegram_id, text=f"ℹ️ Você já tem uma ordem limite pendente para <b>{symbol}</b>.", parse_mode='HTML')
        return

    entries = (signal_data.get('entries') or [])[:2]
    if not entries:
        logger.warning(f"Sinal LIMIT para {symbol} sem preços de entrada válidos.")
        return

    limit_price = float(min(entries)) if (signal_data.get('order_type') or '').upper() == 'LONG' else float(max(entries))
    signal_data['limit_price'] = limit_price

    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)
    account_info = await get_account_info(api_key, api_secret)
    if not account_info.get("success"):
        logger.error(f"Falha ao buscar saldo para usuário {user.telegram_id} ao posicionar LIMIT em {symbol}.")
        return

    balance = float(account_info.get("data", {}).get('available_balance_usdt', 0))
    limit_order_result = await place_limit_order(api_key, api_secret, signal_data, user, balance)

    if limit_order_result.get("success"):
        order_id = limit_order_result["data"]["orderId"]
        
        # COMENTÁRIO: Lógica de formatação dos TPs foi refatorada para listar todos os alvos.
        all_targets = signal_data.get('targets') or []
        tp_text_lines = []
        if all_targets:
            tp_text_lines.append("  - 🎯 <b>Alvos (TPs):</b>")
            for i, target in enumerate(all_targets, 1):
                price = float(target)
                tp_text_lines.append(f"    - T{i}: ${price:,.4f}")
        else:
            tp_text_lines.append("  - 🎯 <b>Take Profit:</b> N/A")
        tp_text = "\n".join(tp_text_lines)
        
        confidence_text = ""
        signal_confidence = signal_data.get('confidence')
        if signal_confidence is not None:
            confidence_text = f"  - 🟢 <b>Confiança:</b> {signal_confidence:.2f}%\n"

        message = (
            f"✅ <b>Ordem Limite Posicionada!</b>\n\n"
            f"{confidence_text}"
            f"  - 📊 <b>Tipo:</b> {signal_data.get('order_type')} | <b>Alavancagem:</b> {user.max_leverage}x\n"
            f"  - 💎 <b>Moeda:</b> {symbol}\n"
            f"  - 🎯 <b>Preço de Entrada:</b> ${limit_price:,.4f}\n"
            f"  - 🛡️ <b>Stop Loss:</b> ${signal_data.get('stop_loss'):,.4f}\n"
            f"{tp_text}\n\n"
            f"👀 Monitorando a execução…"
        )
   
        sent_message = await application.bot.send_message(chat_id=user.telegram_id, text=message, parse_mode='HTML')
        
        db.add(PendingSignal(
            user_telegram_id=user.telegram_id, 
            symbol=symbol, 
            order_id=order_id, 
            signal_data=signal_data,
            notification_message_id=sent_message.message_id
        ))
    else:
        error = limit_order_result.get('error') or "Erro desconhecido"
        await application.bot.send_message(chat_id=user.telegram_id, text=f"❌ Falha ao posicionar sua ordem limite para <b>{symbol}</b>.\n<b>Motivo:</b> {error}", parse_mode='HTML')


========================================
# Arquivo: core/whitelist_service.py
========================================

import logging
from typing import Set

logger = logging.getLogger(__name__)

# --- CATEGORIAS DE MOEDAS ---
# Usamos Sets para performance e para evitar duplicatas.
# As listas foram expandidas para incluir o máximo de ativos relevantes dentro das categorias originais.

# Moedas "blue chips" clássicas, de altíssima capitalização.
BLUECHIPS: Set[str] = {
    'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT'
}

# Moedas de grande capitalização e projetos estabelecidos (Layer 1 e Layer 2)
ALTCOINS_L1_L2: Set[str] = {
    'ADAUSDT', 'ALGOUSDT', 'APTUSDT', 'ARBUSDT', 'ATOMUSDT', 'AVAXUSDT', 'DOTUSDT', 
    'EGLDUSDT', 'EOSUSDT', 'ETCUSDT', 'FTMUSDT', 'HBARUSDT', 'ICPUSDT', 'IMXUSDT', 
    'INJUSDT', 'KASUSDT', 'KSMUSDT', 'LTCUSDT', 'MATICUSDT', 'MINAUSDT', 'NEARUSDT', 
    'OPUSDT', 'SEIUSDT', 'STXUSDT', 'SUIUSDT', 'TIAUSDT', 'TONUSDT', 'TRXUSDT', 
    'VETUSDT', 'XLMUSDT', 'XMRUSDT', 'XRPUSDT', 'XTZUSDT', 'ZECUSDT', 'ZENUSDT'
}

# Moedas relacionadas a Finanças Descentralizadas (DeFi)
DEFI: Set[str] = {
    '1INCHUSDT', 'AAVEUSDT', 'BALUSDT', 'CAKEUSDT', 'COMPUSDT', 'CRVUSDT', 
    'CVXUSDT', 'DYDXUSDT', 'GMXUSDT', 'JUPUSDT', 'KNCUSDT', 'LDOUSDT', 'LINKUSDT', 
    'LRCUSDT', 'MKRUSDT', 'PENDLEUSDT', 'RUNEUSDT', 'SNXUSDT', 'SUSHIUSDT', 
    'UMAUSDT', 'UNIUSDT', 'WOOUSDT', 'YFIUSDT', 'ZRXUSDT'
}

# Moedas de "memes" com alta volatilidade
MEMECOINS: Set[str] = {
    'BONKUSDT', 'DOGEUSDT', 'FLOKIUSDT', 'MEMEUSDT', 'ORDIUSDT', 'PEPEUSDT', 
    'SATSUSDT', 'SHIBUSDT', 'WIFUSDT'
}

# Camada de infraestrutura, oráculos e DePIN (Redes de Infraestrutura Física Descentralizada)
INFRA: Set[str] = {
    'ANKRUSDT', 'ARUSDT', 'BTTUSDT', 'FILUSDT', 'GRTUSDT', 'HNTUSDT', 'LINKUSDT', 
    'OCEANUSDT', 'RNDRUSDT', 'STORJUSDT', 'THETAUSDT'
}


# Dicionário que mapeia a palavra-chave da categoria para o Set de moedas
CATEGORIES = {
    'bluechips': BLUECHIPS,
    'altcoins': ALTCOINS_L1_L2,
    'defi': DEFI,
    'infra': INFRA,
    'memecoins': MEMECOINS,
}

def is_coin_in_whitelist(symbol: str, user_whitelist_str: str) -> bool:
    """
    Verifica se um símbolo de moeda está na whitelist de um usuário.

    A whitelist pode conter:
    - O keyword 'todas'.
    - Símbolos específicos (ex: 'btcusdt').
    - Keywords de categorias (ex: 'memecoins').
    """
    if not user_whitelist_str or 'todas' in user_whitelist_str.lower():
        return True

    # Normaliza a entrada do usuário: minúsculas, remove espaços, divide por vírgula
    user_list = {item.strip() for item in user_whitelist_str.lower().split(',')}
    
    # 1. Verifica se o símbolo exato está na lista do usuário
    if symbol.lower() in user_list:
        return True

    # 2. Verifica se alguma das categorias da lista do usuário contém o símbolo
    for category_keyword in user_list:
        if category_keyword in CATEGORIES and symbol.upper() in CATEGORIES[category_keyword]:
            return True
            
    # Se nenhuma das condições acima for atendida, a moeda não está na whitelist
    return False

========================================
# Arquivo: tests/__init__.py
========================================



========================================
# Arquivo: tests/test_missing_cycles_policy.py
========================================

import asyncio
import types

class FakeBot:
    def __init__(self): self.edits = []
    async def edit_message_text(self, chat_id, message_id, text, parse_mode=None):
        self.edits.append((chat_id, message_id, text))

class FakeApp:
    def __init__(self): self.bot = FakeBot()

class T:
    # Mock minimal de Trade
    def __init__(self, symbol, side, missing_cycles=0, notification_message_id=123):
        self.symbol = symbol; self.side = side
        self.status = "ACTIVE"; self.closed_pnl = None
        self.remaining_qty = 1.0; self.notification_message_id = notification_message_id
        self.missing_cycles = missing_cycles
        self.last_seen_at = None

async def _run(policy, bybit_keys, trades, threshold=3):
    app = FakeApp()
    user = types.SimpleNamespace(telegram_id=111)
    db = object()
    await policy(app, user, db, trades, bybit_keys, threshold)
    return app.bot.edits

def test_nao_fecha_em_1_ou_2_ciclos(event_loop=None):
    from main import apply_missing_cycles_policy  # ajuste o import conforme onde você adicionou a função

    trades = [T("TIAUSDT", "LONG")]
    # 1º ciclo ausente
    edits = asyncio.get_event_loop().run_until_complete(_run(apply_missing_cycles_policy, set(), trades))
    assert trades[0].missing_cycles == 1
    assert trades[0].status == "ACTIVE"
    assert edits == []

    # 2º ciclo ausente
    edits = asyncio.get_event_loop().run_until_complete(_run(apply_missing_cycles_policy, set(), trades))
    assert trades[0].missing_cycles == 2
    assert trades[0].status == "ACTIVE"
    assert edits == []

def test_fecha_no_3o_ciclo(event_loop=None):
    from main import apply_missing_cycles_policy

    trades = [T("TIAUSDT", "LONG", missing_cycles=2)]
    edits = asyncio.get_event_loop().run_until_complete(_run(apply_missing_cycles_policy, set(), trades))
    assert trades[0].missing_cycles == 3
    assert trades[0].status == "CLOSED_GHOST"
    assert trades[0].remaining_qty == 0.0
    assert len(edits) == 1  # mensagem de remoção enviada

def test_reset_quando_volta_a_aparecer(event_loop=None):
    from main import apply_missing_cycles_policy

    trades = [T("TIAUSDT", "LONG", missing_cycles=2)]
    edits = asyncio.get_event_loop().run_until_complete(_run(apply_missing_cycles_policy, {("TIAUSDT","LONG")}, trades))
    assert trades[0].missing_cycles == 0
    assert trades[0].status == "ACTIVE"
    assert len(edits) == 0

========================================
# Arquivo: tests/test_signal_cyber_e2e.py
========================================

# tests/test_signal_cyber_e2e.py
import sys
import types
import textwrap
import pytest

# ======== STUBS mínimos (telegram e keyboards) ========
telegram = types.ModuleType("telegram")
telegram_ext = types.ModuleType("telegram.ext")
telegram_constants = types.ModuleType("telegram.constants")

class InlineKeyboardButton:
    def __init__(self, text, callback_data=None, url=None):
        self.text = text; self.callback_data = callback_data; self.url = url

class InlineKeyboardMarkup:
    def __init__(self, keyboard): self.keyboard = keyboard

class Application:
    def __init__(self): self.bot = None

telegram.InlineKeyboardButton = InlineKeyboardButton
telegram.InlineKeyboardMarkup = InlineKeyboardMarkup
telegram.constants = telegram_constants
telegram_ext.Application = Application

sys.modules.setdefault("telegram", telegram)
sys.modules.setdefault("telegram.ext", telegram_ext)
sys.modules.setdefault("telegram.constants", telegram_constants)

bot_pkg = types.ModuleType("bot")
bot_keyboards = types.ModuleType("bot.keyboards")
def signal_approval_keyboard(signal_id: int):
    return InlineKeyboardMarkup([[InlineKeyboardButton("Aprovar", callback_data=f"approve:{signal_id}")]])
bot_keyboards.signal_approval_keyboard = signal_approval_keyboard
sys.modules.setdefault("bot", bot_pkg)
sys.modules.setdefault("bot.keyboards", bot_keyboards)

# ======== Imports reais do projeto ========
from services.signal_parser import parse_signal, SignalType
import core.trade_manager as tm

# ======== Fakes utilitários ========
class FakeUser:
    def __init__(self, telegram_id=111, api_key_encrypted="enc_k", api_secret_encrypted="enc_s"):
        self.telegram_id = telegram_id
        self.api_key_encrypted = api_key_encrypted
        self.api_secret_encrypted = api_secret_encrypted

class _QueryList:
    def __init__(self, data_list): self._data = data_list
    def filter(self, *a, **k): return self
    def filter_by(self, **k):
        def ok(obj): return all(getattr(obj, kk, None) == vv for kk, vv in k.items())
        return _QueryList([x for x in self._data if ok(x)])
    def all(self): return list(self._data)
    def first(self): return self._data[0] if self._data else None

class FakeDB:
    def __init__(self, users=None, pendings=None):
        self._users = users or []
        self._pendings = pendings or []
        self.added = []; self.deleted = []; self.commits = 0
    def query(self, Model):
        if Model is tm.User: return _QueryList(self._users)
        if Model is tm.PendingSignal: return _QueryList(self._pendings)
        return _QueryList([])
    def add(self, obj):
        self.added.append(obj)
        if isinstance(obj, tm.PendingSignal) or getattr(obj, "__class__", None).__name__ == "DummyPending":
            self._pendings.append(obj)
    def delete(self, obj):
        self.deleted.append(obj)
        if obj in self._pendings: self._pendings.remove(obj)
    def commit(self): self.commits += 1

class FakeBot:
    def __init__(self): self.sent = []
    async def send_message(self, **kwargs): self.sent.append(kwargs)

class FakeApplication(Application):
    def __init__(self): super().__init__(); self.bot = FakeBot()

# ======== Sinal CYBER (LIMIT/SHORT) ========
CYBER_SIGNAL = textwrap.dedent("""
⏳ #38792 - Ordem Limite

💎 Moeda: CYBER
📊 Tipo: SHORT (Futures)

💰 Zona de Entrada: 2.52500000 - 2.64000000
🛑 Stop Loss: 2.90000000 (12.2943%)
🎯 Alvos:
T1: 2.44000000 (5.52%)
T2: 2.37000000 (8.23%)
T3: 2.29000000 (11.33%)
T4: 2.20000000 (14.81%)
""")

@pytest.mark.asyncio
async def test_cyber_limit_short_positions_limit_order(monkeypatch):
    parsed = parse_signal(CYBER_SIGNAL)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "SHORT"
    assert parsed["coin"] == "CYBERUSDT"
    assert parsed["entries"] == [2.525, 2.64]
    assert parsed["stop_loss"] == 2.9

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=777)])

    # dummy PendingSignal para não depender de SQLAlchemy real
    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    # Capturas
    called = {"market": False, "limit_payload": None}

    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        # guardamos o payload passado — deve conter limit_price = 2.64
        called["limit_payload"] = dict(signal_data)
        return {"success": True, "data": {"orderId": "CYB-LIM-001"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "123.45"}]}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    # patches
    monkeypatch.setattr(tm, "place_order", fake_place_order)  # não deve ser chamado
    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # 1) NÃO abriu a mercado
    assert not called["market"], "LIMIT/SHORT não deve abrir ordem a mercado"

    # 2) Chamou limit com limit_price = 2.64 (maior da faixa)
    assert called["limit_payload"] is not None, "place_limit_order não foi chamado"
    assert called["limit_payload"].get("limit_price") == pytest.approx(2.64, rel=1e-6)

    # 3) Criou PendingSignal
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal não foi criado"

    # 4) Enviou mensagem ao usuário
    assert app.bot.sent, "Nenhuma mensagem foi enviada ao usuário"
    texts = [m.get("text", "").lower() for m in app.bot.sent]
    assert any("limite" in t or "monitorando" in t for t in texts), texts


========================================
# Arquivo: tests/test_signal_parser.py
========================================

import textwrap

from services.signal_parser import parse_signal, SignalType


def test_parse_signal_without_diamond():
    message = textwrap.dedent(
        """
        ⏳ #1 - Ordem Limite
        Moeda: SOL
        Tipo: SHORT (Futures)
        Zona de Entrada: 182.66 - 182.66
        Stop Loss: 186.36
        Alvos:
        T1: 181.18
        """
    )

    data = parse_signal(message)

    assert data["coin"] == "SOLUSDT"
    assert data["type"] == SignalType.LIMIT


def test_parse_signal_with_coin_synonym():
    message = textwrap.dedent(
        """
        ⏳ #2 - Ordem Limite
        Coin: NMR
        Tipo: SHORT (Futures)
        Zona de Entrada: 8.04 - 8.28
        Stop Loss: 8.55
        Alvos:
        T1: 7.99
        """
    )

    data = parse_signal(message)

    assert data["coin"] == "NMRUSDT"
    assert data["type"] == SignalType.LIMIT


def test_parse_complex_signal_with_emojis_and_extra_text():
    message = textwrap.dedent(
        """
        ⏳ #38792 - Ordem Limite

        📢 Canal: GRE - 58
        🌐 Plataforma: telegram

        💎 Moeda: CYBER
        📊 Tipo: SHORT (Futures)
        📈 Alavancagem: 10x

        💰 Zona de Entrada: 2.52500000 - 2.64000000
        🛑 Stop Loss: 2.90000000 (12.2943%)
        🎯 Alvos:
        T1: 2.44000000 (5.52%)
        T2: 2.37000000 (8.23%)
        T3: 2.29000000 (11.33%)
        T4: 2.20000000 (14.81%)
        ☯️ R/R ratio: 0.4

        📊 Status: Sinal aberto

        🟢 Confiança: 66.67%  🧭 Consenso: 4/6
        """
    )

    data = parse_signal(message)

    assert data is not None, "O parser não deveria retornar None para este sinal"
    assert data["type"] == SignalType.LIMIT
    assert data["coin"] == "CYBERUSDT"
    assert data["order_type"] == "SHORT"
    assert data["entries"] == [2.525, 2.64]
    assert data["stop_loss"] == 2.9
    assert data["targets"] == [2.44, 2.37, 2.29, 2.2]
    assert data["confidence"] == 66.67



# --- NOVO TESTE: MARKET (Ordem à Mercado) ---
def test_parse_market_signal_with_accent():
    message = textwrap.dedent(
        """
        🏁 #39170 - Ordem à Mercado

        💎 Moeda: AVAX
        📊 Tipo: SHORT (Futures)

        💰 Zona de Entrada: 22.85000000 - 22.85000000
        🛑 Stop Loss: 24.22000000
        Alvos:
        T1: 22.69000000
        T2: 22.55000000
        """
    )

    data = parse_signal(message)

    assert data is not None
    assert data["type"] == SignalType.MARKET
    assert data["coin"] == "AVAXUSDT"
    assert data["order_type"] == "SHORT"
    assert data["entries"][0] == 22.85
    assert data["stop_loss"] == 24.22
    assert 22.69 in data["targets"]
    assert 22.55 in data["targets"]


# --- NOVO TESTE: CANCELAR ---
def test_parse_cancel_signal():
    message = textwrap.dedent(
        """
        ⚠️ BTC sinal cancelado
        """
    )

    data = parse_signal(message)

    assert data is not None
    assert data["type"] == SignalType.CANCELAR
    assert data["coin"] == "BTCUSDT"


========================================
# Arquivo: tests/test_trade_manager_e2e.py
========================================

# tests/test_trade_manager_e2e.py

import sys
import types
import textwrap
import pytest

# ===========================
# STUBS: telegram e bot.keyboards
# ===========================
telegram = types.ModuleType("telegram")
telegram_ext = types.ModuleType("telegram.ext")
telegram_constants = types.ModuleType("telegram.constants")

class InlineKeyboardButton:
    def __init__(self, text, callback_data=None, url=None):
        self.text = text
        self.callback_data = callback_data
        self.url = url

class InlineKeyboardMarkup:
    def __init__(self, keyboard):
        self.keyboard = keyboard

class Application:
    def __init__(self):
        self.bot = None

# expõe no módulo stub
telegram.InlineKeyboardButton = InlineKeyboardButton
telegram.InlineKeyboardMarkup = InlineKeyboardMarkup
telegram.constants = telegram_constants
telegram_ext.Application = Application

# registra stubs
sys.modules.setdefault("telegram", telegram)
sys.modules.setdefault("telegram.ext", telegram_ext)
sys.modules.setdefault("telegram.constants", telegram_constants)

# bot.keyboards stub (para satisfazer "from bot.keyboards import signal_approval_keyboard")
bot_pkg = types.ModuleType("bot")
bot_keyboards = types.ModuleType("bot.keyboards")
def signal_approval_keyboard(signal_id: int):
    return InlineKeyboardMarkup([[InlineKeyboardButton("Aprovar", callback_data=f"approve:{signal_id}")]])
bot_keyboards.signal_approval_keyboard = signal_approval_keyboard
sys.modules.setdefault("bot", bot_pkg)
sys.modules.setdefault("bot.keyboards", bot_keyboards)

# ===========================
# Imports reais do projeto
# ===========================
from services.signal_parser import parse_signal, SignalType
import core.trade_manager as tm


# ===========================
# Fakes utilitários
# ===========================
class FakeUser:
    def __init__(self, telegram_id=111, api_key_encrypted="enc_k", api_secret_encrypted="enc_s", min_confidence=0.0, approval_mode="AUTOMATIC"):
        self.telegram_id = telegram_id
        self.api_key_encrypted = api_key_encrypted
        self.api_secret_encrypted = api_secret_encrypted
        self.min_confidence = min_confidence
        self.approval_mode = approval_mode

class _QueryList:
    def __init__(self, data_list):
        self._data = data_list
    def filter(self, *args, **kwargs):  # compat simples
        return self
    def filter_by(self, **kwargs):
        # Implementação leve para casos .filter_by(user_telegram_id=..., symbol=...)
        def match(obj):
            return all(getattr(obj, k, None) == v for k, v in kwargs.items())
        return _QueryList([x for x in self._data if match(x)])
    def all(self):
        return list(self._data)
    def first(self):
        return self._data[0] if self._data else None

class FakeDB:
    """DB fake que suporta .query(Model) e listas de users/pendings."""
    def __init__(self, users=None, pendings=None):
        self._users = users or []
        self._pendings = pendings or []
        self.added = []
        self.deleted = []
        self.commits = 0
        self.closed = False
    def query(self, Model):
        if Model is tm.User:
            return _QueryList(self._users)
        if Model is tm.PendingSignal:
            return _QueryList(self._pendings)
        if Model is tm.Trade:
            # raramente consultado em testes; devolve vazio
            return _QueryList([])
        if Model is tm.SignalForApproval:
            return _QueryList([])
        return _QueryList([])
    def add(self, obj):
        self.added.append(obj)
        # se for PendingSignal "persistido", também aparece em consultas subsequentes
        if isinstance(obj, tm.PendingSignal) or getattr(obj, "__class__", None).__name__ == "DummyPending":
            self._pendings.append(obj)
    def delete(self, obj):
        self.deleted.append(obj)
        if obj in self._pendings:
            self._pendings.remove(obj)
    def commit(self):
        self.commits += 1
    def close(self):
        self.closed = True

class FakeBot:
    def __init__(self):
        self.sent = []
    async def send_message(self, **kwargs):
        self.sent.append(kwargs)

class FakeApplication(Application):
    def __init__(self):
        super().__init__()
        self.bot = FakeBot()


# ===========================
# Textos de sinais
# ===========================
MARKET_SIGNAL = textwrap.dedent("""
🏁 #39170 - Ordem à Mercado

💎 Moeda: AVAX
📊 Tipo: SHORT (Futures)

💰 Zona de Entrada: 22.85000000 - 22.85000000
🛑 Stop Loss: 24.22000000
Alvos:
T1: 22.69000000
T2: 22.55000000
""")

LIMIT_SIGNAL_SHORT = textwrap.dedent("""
⏳ #38792 - Ordem Limite

💎 Moeda: CYBER
📊 Tipo: SHORT (Futures)

💰 Zona de Entrada: 2.52500000 - 2.64000000
🛑 Stop Loss: 2.90000000
Alvos:
T1: 2.44000000
T2: 2.37000000
T3: 2.29000000
T4: 2.20000000
""")

LIMIT_SIGNAL_LONG = textwrap.dedent("""
⏳ #50001 - Ordem Limite

💎 Moeda: XRP
📊 Tipo: LONG (Futures)

💰 Zona de Entrada: 0.4500 - 0.4510
🛑 Stop Loss: 0.4400
Alvos:
T1: 0.4600
T2: 0.4700
""")

CANCEL_SIGNAL_XRP = "⚠️ XRP sinal cancelado"


# ===========================
# TESTES
# ===========================
@pytest.mark.asyncio
async def test_market_flow_calls_place_order(monkeypatch):
    parsed = parse_signal(MARKET_SIGNAL)
    assert parsed and parsed["type"] == SignalType.MARKET

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=999)])

    class DummyTrade:
        def __init__(self, **kwargs):
            self.kwargs = kwargs

    called = {}
    async def fake_place_order(api_key, api_secret, signal_data, user, balance):
        called["api_key"] = api_key
        called["api_secret"] = api_secret
        called["signal_data"] = signal_data
        called["user_id"] = user.telegram_id
        called["balance"] = balance
        return {"success": True, "data": {"orderId": "fake-123", "qty": "1.0"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "100.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_order", fake_place_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "Trade", DummyTrade)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # Validações
    assert called, "place_order não foi chamado"
    assert called["user_id"] == 999
    assert called["signal_data"]["coin"] == "AVAXUSDT"
    assert called["signal_data"]["order_type"] == "SHORT"
    assert called["signal_data"]["entries"][0] == pytest.approx(22.85, rel=1e-6)
    assert called["signal_data"]["stop_loss"] == pytest.approx(24.22, rel=1e-6)
    assert called["balance"] == 100.0

    # Mensagem ao usuário
    assert app.bot.sent, "Nenhuma mensagem foi enviada"
    texts = [m.get("text", "").lower() for m in app.bot.sent]
    assert any(("ordem" in t) or ("aberta" in t) or ("sucesso" in t) for t in texts), texts


@pytest.mark.asyncio
async def test_limit_short_creates_pending_and_uses_upper_bound(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_SHORT)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "SHORT"

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=777)])

    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    called = {"market": False, "limit": None}

    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        called["limit"] = dict(signal_data)  # capturar signal_data com limit_price
        return {"success": True, "data": {"orderId": "LIM-001"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "50.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_order", fake_place_order)  # não deve ser chamado
    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # Não deve ter chamado market
    assert not called["market"], "LIMIT (SHORT) não deve abrir ordem a mercado"
    # Deve ter chamado limit com limit_price == high (2.64000000)
    assert called["limit"] and called["limit"].get("limit_price") == pytest.approx(2.64, rel=1e-6)
    # Deve ter criado PendingSignal e avisado usuário
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal não criado"
    assert app.bot.sent, "Sem mensagem de confirmação ao usuário"


@pytest.mark.asyncio
async def test_limit_long_uses_lower_bound(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_LONG)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "LONG"

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=888)])

    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    called = {"limit": None}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        called["limit"] = dict(signal_data)
        return {"success": True, "data": {"orderId": "LIM-002"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "80.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    assert called["limit"] is not None, "place_limit_order não foi chamado"
    assert called["limit"]["limit_price"] == pytest.approx(0.4500, rel=1e-6), "LONG deve usar menor preço da faixa"
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal não criado"
    assert app.bot.sent, "Sem mensagem ao usuário"


@pytest.mark.asyncio
async def test_limit_skips_when_existing_pending(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_LONG)
    assert parsed and parsed["type"] == SignalType.LIMIT

    app = FakeApplication()

    class DummyPending:
        def __init__(self, user_telegram_id, symbol, order_id="old", signal_data=None):
            self.user_telegram_id = user_telegram_id
            self.symbol = symbol
            self.order_id = order_id
            self.signal_data = signal_data or {}

    # já existe um pendente para o mesmo símbolo e usuário
    existing = DummyPending(user_telegram_id=777, symbol="XRPUSDT")
    db = FakeDB(users=[FakeUser(telegram_id=777)], pendings=[existing])

    called = {"limit": False}
    async def fake_place_limit_order(*a, **k):
        called["limit"] = True
        return {"success": True}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")
    async def fake_get_account_info(api_key, api_secret): return {"success": True, "data": [{"totalEquity": "10"}]}

    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # não deve chamar place_limit_order
    assert not called["limit"], "Não deveria tentar posicionar nova LIMIT com pendente existente"
    # deve ter avisado usuário
    assert app.bot.sent and any("já tem uma ordem limite pendente" in (m.get("text","")) for m in app.bot.sent)


@pytest.mark.asyncio
async def test_cancel_removes_pending_and_notifies(monkeypatch):
    # preparar db com pending XRP para user 123
    class DummyPending:
        def __init__(self, user_telegram_id, symbol, order_id="LIM-XYZ", signal_data=None):
            self.user_telegram_id = user_telegram_id
            self.symbol = symbol
            self.order_id = order_id
            self.signal_data = signal_data or {}

    pend = DummyPending(user_telegram_id=123, symbol="XRPUSDT")
    users = [FakeUser(telegram_id=123)]
    base_db = FakeDB(users=users, pendings=[pend])

    # monkeypatch SessionLocal para devolver nosso FakeDB
    def fake_SessionLocal():
        # devolve uma "nova" instância por chamada, clonando o estado base
        return FakeDB(users=list(base_db._users), pendings=list(base_db._pendings))

    app = FakeApplication()

    async def fake_cancel_order(api_key, api_secret, order_id, symbol):
        return {"success": True}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "SessionLocal", fake_SessionLocal)
    monkeypatch.setattr(tm, "cancel_order", fake_cancel_order)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)

    parsed_cancel = parse_signal(CANCEL_SIGNAL_XRP)
    assert parsed_cancel and parsed_cancel["type"] == SignalType.CANCELAR

    await tm.process_new_signal(parsed_cancel, app, source_name="TEST-CHANNEL")

    # Como usamos uma instância nova de FakeDB dentro do process, não temos referência direta
    # mas podemos validar pelo envio de mensagem de sucesso
    assert app.bot.sent and any("foi cancelada com sucesso" in (m.get("text","").lower()) for m in app.bot.sent)


@pytest.mark.asyncio
async def test_cancel_without_pending_sends_info_notification(monkeypatch):
    # DB sem pendentes
    base_db = FakeDB(users=[FakeUser(telegram_id=1)], pendings=[])
    def fake_SessionLocal():
        return FakeDB(users=list(base_db._users), pendings=list(base_db._pendings))

    app = FakeApplication()
    captured = {"msg": None}

    async def fake_send_notification(application, text):
        captured["msg"] = text

    monkeypatch.setattr(tm, "SessionLocal", fake_SessionLocal)
    monkeypatch.setattr(tm, "send_notification", fake_send_notification)

    parsed_cancel = parse_signal(CANCEL_SIGNAL_XRP)
    await tm.process_new_signal(parsed_cancel, app, source_name="TEST-CHANNEL")

    assert captured["msg"] is not None
    assert "nenhuma ordem pendente foi encontrada" in captured["msg"].lower()


@pytest.mark.asyncio
async def test_market_fails_on_balance_fetch(monkeypatch):
    parsed = parse_signal(MARKET_SIGNAL)
    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=321)])

    async def fake_get_account_info(api_key, api_secret):
        return {"success": False}  # falha

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    called = {"market": False}
    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "place_order", fake_place_order)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    assert not called["market"], "Não deve tentar abrir ordem sem saldo"
    assert app.bot.sent and any("falha ao buscar seu saldo bybit" in (m.get("text","").lower()) for m in app.bot.sent)


========================================
# Arquivo: utils/__init__.py
========================================



========================================
# Arquivo: utils/config.py
========================================

import os
from dotenv import load_dotenv

load_dotenv()

TELEGRAM_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
ENCRYPTION_KEY = os.getenv('ENCRYPTION_KEY')

API_ID = os.getenv('API_ID')
API_HASH = os.getenv('API_HASH')
ADMIN_ID = int(os.getenv('ADMIN_TELEGRAM_ID', 0)) # Converte para int

========================================
# Arquivo: utils/security.py
========================================

from cryptography.fernet import Fernet
from .config import ENCRYPTION_KEY

# Inicializa o 'cofre' com a sua chave
cipher_suite = Fernet(ENCRYPTION_KEY.encode())

def encrypt_data(data: str) -> str:
    """Criptografa um texto e retorna a versão em string."""
    if not data:
        return None
    encrypted_bytes = cipher_suite.encrypt(data.encode())
    return encrypted_bytes.decode()

def decrypt_data(encrypted_data: str) -> str:
    """Descriptografa um texto e retorna a versão original."""
    if not encrypted_data:
        return None
    decrypted_bytes = cipher_suite.decrypt(encrypted_data.encode())
    return decrypted_bytes.decode()

========================================
# Arquivo: scripts/cleanup_trades.py
========================================

import sys
import os
import argparse
from sqlalchemy.orm import Session
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# Adiciona o diretório raiz ao path para permitir a importação de módulos do projeto
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from database.models import Base, Trade
from database.session import DATABASE_URL  # Importa a URL do banco de dados

def cleanup_trades(db: Session, status: str, user_id: int = None, dry_run: bool = True):
    """
    Busca e, opcionalmente, exclui trades com base em seu status e ID de usuário.
    """
    query = db.query(Trade).filter(Trade.status == status)
    
    if user_id:
        query = query.filter(Trade.user_telegram_id == user_id)
        
    trades_to_delete = query.all()
    count = len(trades_to_delete)
    
    user_filter_str = f" para o usuário com ID {user_id}" if user_id else ""
    
    if count == 0:
        print(f"Nenhum trade com o status '{status}' encontrado{user_filter_str}.")
        return

    print(f"Encontrados {count} trades com o status '{status}'{user_filter_str}.")

    if dry_run:
        print("\n--- MODO DE SIMULAÇÃO (DRY-RUN) ---")
        print("Os seguintes trades seriam excluídos:")
        for trade in trades_to_delete:
            print(f"  - ID: {trade.id}, Símbolo: {trade.symbol}, Usuário: {trade.user_telegram_id}, Data: {trade.closed_at}")
        print("\nNenhuma alteração foi feita no banco de dados.")
    else:
        # Confirmação final antes de excluir
        confirm = input(f"\n!!! ATENÇÃO !!! Você tem certeza que deseja excluir permanentemente estes {count} trades? (s/N): ")
        if confirm.lower() == 's':
            try:
                # Usa delete() em vez de um loop para mais performance
                query.delete(synchronize_session=False)
                db.commit()
                print(f"\n✅ Sucesso! {count} trades foram excluídos permanentemente.")
            except Exception as e:
                db.rollback()
                print(f"\n❌ Erro ao excluir trades: {e}")
        else:
            print("\nOperação cancelada pelo usuário.")

def main():
    """
    Função principal para executar o script via linha de comando.
    """
    parser = argparse.ArgumentParser(description="Script de limpeza para trades no banco de dados.")
    parser.add_argument("--status", type=str, required=True, help="O status dos trades a serem excluídos (ex: CLOSED_GHOST).")
    parser.add_argument("--user-id", type=int, help="(Opcional) ID de usuário do Telegram para filtrar a exclusão.")
    parser.add_argument("--dry-run", action="store_true", help="Apenas simula a exclusão, sem fazer alterações no banco.")
    
    args = parser.parse_args()

    # Configuração da sessão do banco de dados
    engine = create_engine(DATABASE_URL)
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    db = SessionLocal()
    
    try:
        cleanup_trades(db, status=args.status, user_id=args.user_id, dry_run=args.dry_run)
    finally:
        db.close()

if __name__ == "__main__":
    main()

========================================
# Arquivo: scripts/create_invite.py
========================================

import sys
from database.session import SessionLocal, init_db
from database.models import InviteCode

def create_invite_code(code: str):
    db = SessionLocal()
    try:
        existing_code = db.query(InviteCode).filter(InviteCode.code == code).first()
        if existing_code:
            print(f"Código '{code}' já existe.")
            return

        new_code = InviteCode(code=code)
        db.add(new_code)
        db.commit()
        print(f"Código de convite '{code}' criado com sucesso!")
    finally:
        db.close()

if __name__ == "__main__":
    init_db()
    # Agora ele lê o código a partir do seu comando no terminal
    if len(sys.argv) > 1:
        code_to_create = sys.argv[1]
        create_invite_code(code_to_create)
    else:
        print("Erro: Por favor, forneça um código para criar. Exemplo: python create_invite.py MEU-CODIGO-NOVO")

========================================
# Arquivo: bot/__init__.py
========================================



========================================
# Arquivo: bot/handlers.py
========================================

import logging
import asyncio
import pytz
from database.models import PendingSignal
from services.signal_parser import SignalType
from services.bybit_service import place_limit_order, get_account_info, cancel_order 
from datetime import datetime, time, timedelta 
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler
from telegram.error import BadRequest
from database.session import SessionLocal
from database.models import User, InviteCode, MonitoredTarget, Trade, SignalForApproval
from .keyboards import (
    main_menu_keyboard, confirm_remove_keyboard, admin_menu_keyboard, 
    dashboard_menu_keyboard, settings_menu_keyboard, view_targets_keyboard, 
    bot_config_keyboard, performance_menu_keyboard, confirm_manual_close_keyboard,
    signal_filters_keyboard, ma_timeframe_keyboard, risk_menu_keyboard,
    stopgain_menu_keyboard, circuit_menu_keyboard,
    )
from utils.security import encrypt_data, decrypt_data
from services.bybit_service import (
    get_open_positions, 
    get_account_info, 
    close_partial_position, 
    get_open_positions_with_pnl,
    get_market_price
)
from utils.config import ADMIN_ID
from database.crud import get_user_by_id
from core.trade_manager import _execute_trade, _execute_limit_order_for_user
from core.performance_service import generate_performance_report
from services.currency_service import get_usd_to_brl_rate
from sqlalchemy.sql import func
from core.whitelist_service import CATEGORIES

# Estados para as conversas
(WAITING_CODE, WAITING_API_KEY, WAITING_API_SECRET, CONFIRM_REMOVE_API) = range(4)
(ASKING_ENTRY_PERCENT, ASKING_MAX_LEVERAGE, ASKING_MIN_CONFIDENCE) = range(10, 13)
(ASKING_PROFIT_TARGET, ASKING_LOSS_LIMIT) = range(13, 15)
ASKING_STOP_GAIN_TRIGGER, ASKING_STOP_GAIN_LOCK = range(16, 18)
ASKING_CIRCUIT_THRESHOLD, ASKING_CIRCUIT_PAUSE = range(18, 20)
ASKING_COIN_WHITELIST = 15
(
    ASKING_MA_PERIOD, ASKING_MA_TIMEFRAME,
    ASKING_RSI_OVERSOLD, ASKING_RSI_OVERBOUGHT
) = range(20, 24)

logger = logging.getLogger(__name__)

# ---- helpers (resumos no topo dos submenus) ----
def _risk_summary(user) -> str:
    try:
        return (
            f"• Entrada: {float(getattr(user,'entry_size_percent',0) or 0):.1f}%  |  "
            f"Alav.: {int(getattr(user,'max_leverage',0) or 0)}x  |  "
            f"Conf.: {float(getattr(user,'min_confidence',0) or 0):.1f}%"
        )
    except Exception:
        return "• Parâmetros indisponíveis"

def _stopgain_summary(user) -> str:
    try:
        return (
            f"• Gatilho: {float(getattr(user,'stop_gain_trigger_pct',0) or 0):.2f}%  |  "
            f"Trava: {float(getattr(user,'stop_gain_lock_pct',0) or 0):.2f}%"
        )
    except Exception:
        return "• Parâmetros indisponíveis"

def _circuit_summary(user) -> str:
    try:
        return (
            f"• Limite: {int(getattr(user,'circuit_breaker_threshold',0) or 0)}  |  "
            f"Pausa: {int(getattr(user,'circuit_breaker_pause_minutes',0) or 0)} min"
        )
    except Exception:
        return "• Parâmetros indisponíveis"

# --- FLUXO DE USUÁRIO (START, CADASTRO, MENUS) ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    telegram_user = update.effective_user
    user_in_db = get_user_by_id(telegram_user.id)
    if user_in_db:
        await update.message.reply_text(
            "Menu Principal:",
            reply_markup=main_menu_keyboard(telegram_id=telegram_user.id)
        )
        return ConversationHandler.END
    else:
        await update.message.reply_text(
            f"Olá, {telegram_user.first_name}! Para usar o TradeFlow, insira seu código de convite."
        )
        return WAITING_CODE

async def receive_invite_code(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    code_text = update.message.text
    telegram_user = update.effective_user
    db = SessionLocal()
    try:
        invite_code = db.query(InviteCode).filter(InviteCode.code == code_text, InviteCode.is_used == False).first()
        if invite_code:
            new_user = User(telegram_id=telegram_user.id, first_name=telegram_user.first_name)
            db.add(new_user)
            invite_code.is_used = True
            db.commit()
            await update.message.reply_text(
                "✅ Cadastro realizado com sucesso! O próximo passo é configurar sua API.",
                reply_markup=main_menu_keyboard(telegram_id=telegram_user.id)
            )
            return ConversationHandler.END
        else:
            await update.message.reply_text("❌ Código de convite inválido ou já utilizado. Tente novamente.")
            return WAITING_CODE
    finally:
        db.close()

async def back_to_main_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        "Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=update.effective_user.id)
    )

# --- FLUXO DE CONFIGURAÇÃO DE API ---
async def config_api(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Inicia o fluxo de configuração de API com um tutorial melhorado."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['entry_message_id'] = query.message.message_id
    
    tutorial_text = (
        "🔑 <b>Como Criar suas Chaves de API na Bybit</b> 🔑\n\n"
        "Siga estes passos com atenção para conectar sua conta:\n\n"
        "1️⃣  Faça login em <b>Bybit.com</b> e vá para <i>Perfil > API</i>.\n\n"
        "2️⃣  Clique em <b>'Criar Nova Chave'</b> e selecione <i>'Chaves Geradas pelo Sistema'</i>.\n\n"
        "3️⃣  Dê um nome para sua chave (ex: `TradeFlowBot`) e selecione as permissões de <b>'Leitura e Escrita'</b>.\n\n"
        "4️⃣  Nas permissões, marque <b>APENAS</b> as seguintes caixas:\n"
        "   - <b>Contrato</b> (`Contract`): ✅ `Ordens` e ✅ `Posições`\n"
        "   - <b>Trading Unificado</b> (`UTA`): ✅ `Trade`\n\n"
        "5️⃣  🛡️ <b>MUITO IMPORTANTE:</b> Por segurança, <b>NÃO</b> marque a permissão de <i>'Saque' (Withdraw)</i>.\n\n"
        "⚠️ <b>Atenção:</b> Este bot opera exclusivamente com pares de trade terminados em **USDT**.\n\n"
        "6️⃣  Conclua a verificação de segurança e copie sua <b>API Key</b> e <b>API Secret</b>.\n\n"
        "-------------------------------------\n"
        "Pronto! Agora, por favor, envie sua <b>API Key</b>."
    )
    
    await query.edit_message_text(
        text=tutorial_text,
        parse_mode='HTML'
    )
    return WAITING_API_KEY

async def receive_api_key(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe a API Key, apaga a mensagem do usuário e pede a API Secret."""
    await context.bot.delete_message(
        chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    api_key = update.message.text
    context.user_data['api_key'] = api_key
    
    prompt_message = await update.message.reply_text(
        "Chave API recebida com segurança. Agora, por favor, envie sua *API Secret*.",
        parse_mode='Markdown'
    )
    context.user_data['prompt_message_id'] = prompt_message.message_id
    
    return WAITING_API_SECRET

async def receive_api_secret(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe a API Secret, apaga as mensagens, criptografa e salva no banco."""
    await context.bot.delete_message(
        chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    prompt_message_id = context.user_data.get('prompt_message_id')
    if prompt_message_id:
        await context.bot.delete_message(
            chat_id=update.effective_chat.id,
            message_id=prompt_message_id
        )

    api_secret = update.message.text
    api_key = context.user_data.get('api_key')
    telegram_id = update.effective_user.id

    encrypted_key = encrypt_data(api_key)
    encrypted_secret = encrypt_data(api_secret)

    db = SessionLocal()
    try:
        user_to_update = db.query(User).filter(User.telegram_id == telegram_id).first()
        if user_to_update:
            user_to_update.api_key_encrypted = encrypted_key
            user_to_update.api_secret_encrypted = encrypted_secret
            db.commit()
            
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=context.user_data['entry_message_id'],
                text="✅ Suas chaves de API foram salvas com sucesso!",
            )
            await context.bot.send_message(
                chat_id=telegram_id,
                text="Menu Principal:",
                reply_markup=main_menu_keyboard(telegram_id=telegram_id)
            )
        else:
            await update.message.reply_text("Ocorreu um erro. Usuário não encontrado.")
    finally:
        db.close()
        context.user_data.clear()

    return ConversationHandler.END

# --- FLUXO DE REMOÇÃO DE API ---
async def remove_api_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        text="⚠️ Você tem certeza que deseja remover suas chaves de API?",
        reply_markup=confirm_remove_keyboard()
    )
    return CONFIRM_REMOVE_API

async def remove_api_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id

    if query.data == 'remove_api_confirm':
        db = SessionLocal()
        try:
            user_to_update = db.query(User).filter(User.telegram_id == telegram_id).first()
            if user_to_update:
                user_to_update.api_key_encrypted = None
                user_to_update.api_secret_encrypted = None
                db.commit()
            await query.edit_message_text("✅ Suas chaves de API foram removidas.")
        finally:
            db.close()
    else: # Cancelou
        await query.edit_message_text("Operação cancelada.")

    await context.bot.send_message(
        chat_id=telegram_id,
        text="Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=telegram_id)
    )
    return ConversationHandler.END

async def my_positions_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    try:
        await query.answer()
    except BadRequest as e:
        logger.warning(f"Não foi possível responder ao callback_query (pode ser antigo): {e}")
        return

    try:
        await query.edit_message_text("Buscando suas posições gerenciadas...")
    except BadRequest as e:
        logger.warning(f"Falha ao editar mensagem para 'Buscando suas posições...': {e}")
        return

    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if not user or not user.api_key_encrypted:
            await query.edit_message_text("Você ainda não configurou suas chaves de API.")
            return

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        active_trades = db.query(Trade).filter(
            Trade.user_telegram_id == user_id,
            ~Trade.status.like('%CLOSED%')
        ).order_by(Trade.created_at.desc()).all()

        if not active_trades:
            await query.edit_message_text(
                "<b>📊 Suas Posições Ativas</b>\n\nNenhuma posição sendo gerenciada.",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup(
                    [[InlineKeyboardButton("⬅️ Voltar ao Menu", callback_data='back_to_main_menu')]]
                )
            )
            return

        live_pnl_data = {}
        live_positions_result = await get_open_positions_with_pnl(api_key, api_secret)
        if live_positions_result.get("success"):
            for pos in live_positions_result.get("data", []):
                live_pnl_data[pos["symbol"]] = pos

        lines = ["<b>📊 Suas Posições Ativas (Gerenciadas pelo Bot)</b>", ""]
        keyboard_rows = []
        
        if not active_trades:
             lines.append("Nenhuma posição encontrada na Bybit.")
        else:
            # COMENTÁRIO: A lógica agora itera por trade individual, sem agregação.
            for trade in active_trades:
                arrow = "⬆️" if trade.side == "LONG" else "⬇️"
                entry = float(trade.entry_price or 0.0)
                qty = float(trade.remaining_qty if trade.remaining_qty is not None else trade.qty)
                
                pnl_info = "  P/L: <i>buscando...</i>\n"
                pos_data = live_pnl_data.get(trade.symbol)
                if pos_data:
                    pnl_val = float(pos_data.get("unrealized_pnl", 0.0))
                    pnl_frac = float(pos_data.get("unrealized_pnl_frac", 0.0)) * 100.0
                    pnl_info = f"  P/L: <b>{pnl_val:+.2f} USDT ({pnl_frac:+.2f}%)</b>\n"
                
                # COMENTÁRIO: Nova lógica para exibir o progresso dos TPs.
                total_tps = int(trade.total_initial_targets or 0)
                remaining_tps = len(trade.initial_targets or [])
                hit_tps = total_tps - remaining_tps
                
                targets_info = ""
                if total_tps > 0:
                    targets_info = f"  🎯 TPs: <b>{hit_tps}/{total_tps} atingidos</b>\n"

                lines.append(
                    f"- {arrow} <b>{trade.symbol}</b> ({trade.side})\n"
                    f"  Qtd: {qty:g} | Entrada: ${entry:,.4f}\n"
                    f"{pnl_info}{targets_info}"
                )
                
                # Adiciona um botão de fechar para cada trade individual
                keyboard_rows.append([
                    InlineKeyboardButton(
                        f"Fechar {trade.symbol} #{trade.id} ❌",
                        callback_data=f"confirm_close_{trade.id}" # Aponta para o ID único do trade
                    )
                ])

        lines.append("<i>P/L é atualizado em tempo real pela corretora.</i>")
        keyboard_rows.append([InlineKeyboardButton("⬅️ Voltar ao Menu", callback_data='back_to_main_menu')])
        
        await query.edit_message_text(
            "\n".join(lines), 
            parse_mode='HTML', 
            reply_markup=InlineKeyboardMarkup(keyboard_rows)
        )

    finally:
        db.close()

async def user_dashboard_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o painel financeiro com um resumo visual e completo dos saldos da carteira."""
    query = update.callback_query
    try:
        await query.answer()
    except BadRequest as e:
        logger.warning(f"Não foi possível responder ao callback_query (pode ser antigo): {e}")
        return

    await query.edit_message_text("Buscando informações do painel...")
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = get_user_by_id(user_id)
        if not user or not user.api_key_encrypted:
            await query.edit_message_text("Você precisa configurar sua API primeiro.", reply_markup=main_menu_keyboard(telegram_id=user_id))
            return

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # Busca o saldo e a cotação em paralelo para mais eficiência
        account_info_task = get_account_info(api_key, api_secret)
        brl_rate_task = get_usd_to_brl_rate()
        account_info, brl_rate = await asyncio.gather(account_info_task, brl_rate_task)

        message = "<b>Meu Painel Financeiro</b> 📊\n\n"
        
        if account_info.get("success"):
            balance_data = account_info.get("data", {})
            total_equity = balance_data.get("total_equity", 0.0)

            brl_text = ""
            if brl_rate:
                total_brl = total_equity * brl_rate
                brl_text = f" (aprox. R$ {total_brl:,.2f})"

            message += f"💰 <b>Patrimônio Total:</b> ${total_equity:,.2f} USDT{brl_text}\n"
            message += "<i>(Valor total da conta, incluindo P/L de posições abertas e o valor de todas as moedas)</i>\n\n"
            message += "<b>Saldos em Carteira:</b>\n"

            coin_list = balance_data.get("coin_list", [])
            wallet_lines = []
            
            if coin_list:
                for c in coin_list:
                    coin = (c.get("coin") or "").upper()
                    wallet_balance_str = c.get("walletBalance")
                    wallet_balance = float(wallet_balance_str) if wallet_balance_str else 0.0

                    if wallet_balance > 0.00001:
                        if coin == "USDT":
                            wallet_lines.insert(0, f"  - <b>{coin}: {wallet_balance:,.2f}</b>") # Garante que USDT apareça primeiro
                        else:
                            wallet_lines.append(f"  - {coin}: {wallet_balance:g}")
            
            if wallet_lines:
                message += "\n".join(wallet_lines)
            else:
                message += "Nenhum saldo encontrado.\n"
        else:
            message += f"❌ Erro ao buscar saldo: {account_info.get('error')}\n"

        message += "\n\n⚠️ <i>Este bot opera exclusivamente com pares USDT.</i>"

        await query.edit_message_text(message, parse_mode="HTML", reply_markup=dashboard_menu_keyboard(user))

    except Exception as e:
        logger.error(f"Erro ao montar o painel do usuário: {e}", exc_info=True)
        await query.edit_message_text("Ocorreu um erro ao buscar os dados do seu painel.")
    finally:
        db.close()

# --- CANCELAMENTO ---
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancela a operação atual."""
    await update.message.reply_text("Operação cancelada.")
    return ConversationHandler.END

# --- FLUXO DE ADMINISTRAÇÃO ---
async def admin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra o menu de administrador, se o usuário for o admin."""
    user_id = update.effective_user.id
    if user_id != ADMIN_ID:
        await update.message.reply_text("Você não tem permissão para usar este comando.")
        return

    await update.message.reply_text(
        "Bem-vindo ao painel de administração.",
        reply_markup=admin_menu_keyboard()
    )


async def admin_view_targets_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Busca e exibe a lista de todos os canais e tópicos sendo monitorados."""
    query = update.callback_query
    await query.answer()
    
    db = SessionLocal()
    try:
        targets = db.query(MonitoredTarget).all()
        
        message = "<b>👁️ Alvos Atualmente Monitorados</b>\n\n"
        
        if targets:
            for target in targets:
                if target.topic_name:
                    message += f"- <b>Grupo:</b> {target.channel_name}\n  - <b>Tópico:</b> {target.topic_name}\n"
                else:
                    message += f"- <b>Canal:</b> {target.channel_name}\n"
        else:
            message += "Nenhum alvo sendo monitorado no momento."
            
        await query.edit_message_text(
            text=message,
            parse_mode='HTML',
            reply_markup=view_targets_keyboard()
        )
    finally:
        db.close()

async def back_to_admin_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usuário para o menu de administração principal."""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        "Bem-vindo ao painel de administração.",
        reply_markup=admin_menu_keyboard()
    )

async def list_channels_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Coloca um pedido na fila para listar os grupos e canais do usuário."""
    query = update.callback_query
    await query.answer()
    
    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue:
        await query.edit_message_text("Erro: Fila de comunicação não encontrada.")
        return
    
    request_data = {
        "action": "list_channels",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
    }
    
    await comm_queue.put(request_data)
    
    await query.edit_message_text("Buscando sua lista de canais... Se você tiver muitos grupos, isso pode levar até um minuto. Por favor, aguarde.")
    
async def select_channel_to_monitor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Coloca um pedido na fila para listar tópicos (ou gerenciar um canal plano)."""
    query = update.callback_query
    await query.answer()
    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue: return

    user_id = update.effective_user.id
    if user_id != ADMIN_ID: return

    channel_id = int(query.data.split('_')[-1])
    
    channel_name = ""
    for row in query.message.reply_markup.inline_keyboard:
        for button in row:
            if button.callback_data == query.data:
                channel_name = button.text.replace(" ✅", "")
                break

    request_data = {
        "action": "list_topics",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
        "channel_id": channel_id,
        "channel_name": channel_name
    }
    
    await comm_queue.put(request_data)
    await query.edit_message_text("Processando...")

async def select_topic_to_monitor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Salva/remove o tópico e pede para a fila recarregar o menu de tópicos."""
    query = update.callback_query
    await query.answer() 

    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue:
        logger.error("Fila de comunicação não encontrada no contexto do bot.")
        return

    user_id = update.effective_user.id
    if user_id != ADMIN_ID: return

    _, _, channel_id_str, topic_id_str = query.data.split('_')
    channel_id = int(channel_id_str)
    topic_id = int(topic_id_str)
    
    db = SessionLocal()
    try:
        existing_target = db.query(MonitoredTarget).filter_by(channel_id=channel_id, topic_id=topic_id).first()
        
        if existing_target:
            db.delete(existing_target)
        else:
            topic_name = ""
            for row in query.message.reply_markup.inline_keyboard:
                for button in row:
                    if button.callback_data == query.data:
                        topic_name = button.text.replace(" ✅", "")
                        break
            new_target = MonitoredTarget(channel_id=channel_id, topic_id=topic_id, topic_name=topic_name)
            db.add(new_target)
        
        db.commit()
    finally:
        db.close()

    request_data = {
        "action": "list_topics",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
        "channel_id": channel_id,
        "channel_name": ""
    }
    await comm_queue.put(request_data)

async def back_to_channels_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usuário para a lista de canais/grupos."""
    await list_channels_handler(update, context)

# --- FUNÇÕES DUPLICADAS REMOVIDAS PARA LIMPEZA ---
# my_dashboard_handler, my_positions_handler, back_to_main_menu_handler
# já estavam definidas acima.

async def user_settings_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Abre o menu raiz de Configurações (texto padronizado + teclado novo)."""
    query = update.callback_query
    await query.answer()
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("Não encontrei seu usuário. Use /start para registrar.")
            return

        header = (
            "⚙️ <b>Configurações de Trade</b>\n"
            "<i>Escolha uma categoria para ajustar seus parâmetros.</i>"
        )
        await query.edit_message_text(
            text=header,
            reply_markup=settings_menu_keyboard(user),
            parse_mode="HTML",
        )
    except Exception as e:
        logger.error(f"[settings] Erro ao abrir menu raiz de Configurações: {e}", exc_info=True)
        await query.edit_message_text("Não foi possível abrir as Configurações agora.")
    finally:
        db.close()

# ---- RISCO & TAMANHO ----
async def receive_entry_percent(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip().replace("%", "").replace(",", ".")
    db = SessionLocal()
    try:
        value = float(text)
        if value <= 0 or value > 100:
            await update.message.reply_text("Valor inválido. Envie um número entre 0 e 100 (ex.: 3.5).")
            return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("Usuário não encontrado. Use /start para registrar."); return ConversationHandler.END
        user.entry_size_percent = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"🧮 <b>Risco & Tamanho</b>\n✅ Tamanho de entrada salvo: <b>{value:.1f}%</b>",
            reply_markup=risk_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("Não entendi. Envie um número (ex.: 3.5).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] entry_size_percent: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END


async def receive_max_leverage(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip().lower().replace("x", "")
    db = SessionLocal()
    try:
        value = int(float(text))
        if value < 1 or value > 125:
            await update.message.reply_text("Valor inválido. Envie um inteiro entre 1 e 125 (ex.: 10).")
            return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("Usuário não encontrado. Use /start para registrar."); return ConversationHandler.END
        user.max_leverage = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"🧮 <b>Risco & Tamanho</b>\n✅ Alavancagem máxima salva: <b>{value}x</b>",
            reply_markup=risk_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("Não entendi. Envie um número inteiro (ex.: 10).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] max_leverage: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END


async def receive_min_confidence(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip().replace("%", "").replace(",", ".")
    db = SessionLocal()
    try:
        value = float(text)
        if value < 0 or value > 100:
            await update.message.reply_text("Valor inválido. Envie um número entre 0 e 100 (ex.: 70).")
            return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("Usuário não encontrado. Use /start para registrar."); return ConversationHandler.END
        user.min_confidence = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"🧮 <b>Risco & Tamanho</b>\n✅ Confiança mínima salva: <b>{value:.1f}%</b>",
            reply_markup=risk_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("Não entendi. Envie um número (ex.: 70).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] min_confidence: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END

    
def _current_strategy_value(user) -> str:
    return (str(getattr(user, "stop_strategy", None) or
                getattr(user, "stop_strategy_mode", None) or
                getattr(user, "stop_strategy_type", None) or "breakeven")).lower()

def _next_strategy_value(value: str) -> str:
    return "trailing" if value.startswith("b") else "breakeven"

def _stopgain_summary(user) -> str:
    trigger = float(getattr(user, 'stop_gain_trigger_pct', 0) or 0)
    lock    = float(getattr(user, 'stop_gain_lock_pct', 0) or 0)
    cur     = _current_strategy_value(user)
    label   = "Breakeven" if cur.startswith("b") else "Trailing"
    return f"• Estratégia: {label}  |  Gatilho: {trigger:.2f}%  |  Trava: {lock:.2f}%"

async def toggle_stop_strategy_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("Não encontrei seu usuário. Use /start para registrar.")
            return
        cur = _current_strategy_value(user)
        nxt = _next_strategy_value(cur)

        if hasattr(user, "stop_strategy"):
            user.stop_strategy = nxt
        elif hasattr(user, "stop_strategy_mode"):
            user.stop_strategy_mode = nxt
        elif hasattr(user, "stop_strategy_type"):
            user.stop_strategy_type = nxt
        else:
            setattr(user, "stop_strategy", nxt)

        db.commit()
        header = ("🛡️ <b>Stop-Gain</b>\n<i>Configure estratégia, gatilho e trava.</i>\n\n"
                  f"{_stopgain_summary(user)}")
        await query.edit_message_text(text=header,
                                      reply_markup=stopgain_menu_keyboard(user),
                                      parse_mode="HTML")
    except Exception as e:
        db.rollback()
        logger.error(f"[settings] toggle_stop_strategy_handler erro: {e}", exc_info=True)
        await query.edit_message_text("Erro ao alternar estratégia.")
    finally:
        db.close()
    
async def execute_manual_close_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Lida com a EXECUÇÃO do fechamento manual, editando a mensagem original."""
    query = update.callback_query
    await query.answer("Processando fechamento...")

    trade_id = int(query.data.split('_')[-1])
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        trade_to_close = db.query(Trade).filter_by(id=trade_id, user_telegram_id=user_id).first()

        if not trade_to_close:
            await query.edit_message_text("Erro: Trade não encontrado ou já fechado.")
            return

        user = db.query(User).filter_by(telegram_id=user_id).first()
        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        price_result = await get_market_price(trade_to_close.symbol)
        current_price = price_result["price"] if price_result.get("success") else trade_to_close.entry_price

        close_result = await close_partial_position(
            api_key, api_secret, 
            trade_to_close.symbol, 
            trade_to_close.remaining_qty, 
            trade_to_close.side
        )

        if close_result.get("success"):
            pnl = (current_price - trade_to_close.entry_price) * trade_to_close.remaining_qty if trade_to_close.side == 'LONG' else (trade_to_close.entry_price - current_price) * trade_to_close.remaining_qty

            trade_to_close.status = 'CLOSED_MANUAL'
            trade_to_close.closed_at = func.now()
            trade_to_close.closed_pnl = pnl
            db.commit()

            resultado_str = "LUCRO" if pnl >= 0 else "PREJUÍZO"
            emoji = "✅" if pnl >= 0 else "🔻"
            message_text = (
                f"{emoji} <b>Posição Fechada Manualmente ({resultado_str})</b>\n"
                f"<b>Moeda:</b> {trade_to_close.symbol}\n"
                f"<b>Resultado:</b> ${pnl:,.2f}"
            )

            # --- LÓGICA DE EDIÇÃO APLICADA AQUI ---
            if trade_to_close.notification_message_id:
                try:
                    await context.bot.edit_message_text(
                        chat_id=user_id,
                        message_id=trade_to_close.notification_message_id,
                        text=message_text,
                        parse_mode='HTML'
                    )
                except BadRequest as e:
                    logger.warning(f"Não foi possível editar msg de fechamento manual para trade {trade_to_close.id}: {e}")
                    # Fallback: se não conseguir editar, envia uma nova mensagem.
                    await context.bot.send_message(chat_id=user_id, text=message_text, parse_mode='HTML')
            else:
                # Fallback para trades antigos sem ID de mensagem.
                await query.edit_message_text(message_text, parse_mode='HTML')

            await asyncio.sleep(2)
            await my_positions_handler(update, context) # Recarrega a lista de posições
        else:
            error_msg = close_result.get('error')
            await context.bot.send_message(
                chat_id=user_id,
                text=f"❌ Erro ao fechar a posição para {trade_to_close.symbol}: {error_msg}"
            )
            await my_positions_handler(update, context) # Recarrega a lista mesmo em caso de erro
    finally:
        db.close()


async def bot_config_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de configuração do bot com o modo de aprovação atual."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    db = SessionLocal()
    try:
        user = get_user_by_id(user_id)
        if user:
            await query.edit_message_text(
                "<b>🤖 Configuração do Bot</b>\n\n"
                "Ajuste o comportamento geral do bot.",
                parse_mode='HTML',
                reply_markup=bot_config_keyboard(user)
            )
    finally:
        db.close()

async def toggle_approval_mode_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Alterna o modo de aprovação de ordens entre Manual e Automático."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == user_id).first()
        
        if user:
            if user.approval_mode == 'AUTOMATIC':
                user.approval_mode = 'MANUAL'
            else:
                user.approval_mode = 'AUTOMATIC'
            
            db.commit() 
            
            try:
                await query.edit_message_text(
                    "<b>🤖 Configuração do Bot</b>\n\n"
                    "Ajuste o comportamento geral do bot.",
                    parse_mode='HTML',
                    reply_markup=bot_config_keyboard(user)
                )
            except BadRequest as e:
                if "Message is not modified" in str(e):
                    pass
                else:
                    logger.error(f"Erro ao editar mensagem em toggle_approval_mode: {e}")
    finally:
        db.close()

async def handle_signal_approval(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Lida com a aprovação ou rejeição de um sinal por um usuário específico."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id

    action, _, signal_id_str = query.data.partition('_signal_')
    signal_id = int(signal_id_str)
    
    db = SessionLocal()
    try:
        # Busca o sinal pendente para ESTE usuário específico
        signal_to_process = db.query(SignalForApproval).filter_by(id=signal_id, user_telegram_id=user_id).first()
        if not signal_to_process:
            await query.edit_message_text("Este sinal já foi processado ou expirou.")
            return

        user = db.query(User).filter_by(telegram_id=user_id).first()
        signal_data = signal_to_process.signal_data
        
        if action == 'approve':
            await query.edit_message_text("✅ **Entrada Aprovada!** Posicionando sua ordem...")
            
            # Executa o trade apenas para este usuário
            if signal_data.get("type") == SignalType.MARKET:
                await _execute_trade(signal_data, user, context.application, db, signal_to_process.source_name)
            elif signal_data.get("type") == SignalType.LIMIT:
                await _execute_limit_order_for_user(signal_data, user, context.application, db)
            
        elif action == 'reject':
            await query.edit_message_text("❌ **Entrada Rejeitada.** O sinal foi descartado.")
        
        db.delete(signal_to_process)
        db.commit()
    finally:
        db.close()

# --- FLUXO DE CONFIGURAÇÃO DE METAS DIÁRIAS ---

async def ask_profit_target(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuário a nova meta de lucro diário."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie a sua meta de **lucro diário** em USDT.\n"
        "O bot irá parar de abrir novas ordens quando o lucro do dia atingir este valor.\n\n"
        "Envie apenas o número (ex: `100` para $100) ou `0` para desativar.",
        parse_mode='Markdown'
    )
    return ASKING_PROFIT_TARGET

async def receive_profit_target(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova meta de lucro."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        target_value = float(update.message.text.replace(',', '.'))
        if target_value < 0:
            raise ValueError("Valor não pode ser negativo")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.daily_profit_target = target_value
            db.commit()
            
            feedback_text = f"✅ Meta de lucro diário atualizada para ${target_value:.2f}."
            if target_value == 0:
                feedback_text = "✅ Meta de lucro diário foi desativada."

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"{feedback_text}\n\nAjuste outra configuração ou volte.",
                reply_markup=bot_config_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="❌ Valor inválido. Por favor, tente novamente com um número (ex: 100)."
        )
        return ASKING_PROFIT_TARGET

    return ConversationHandler.END

async def ask_loss_limit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuário o novo limite de perda diário."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie o seu limite de **perda diária** em USDT.\n"
        "O bot irá parar de abrir novas ordens se a perda do dia atingir este valor.\n\n"
        "Envie um número positivo (ex: `50` para um limite de $50) ou `0` para desativar.",
        parse_mode='Markdown'
    )
    return ASKING_LOSS_LIMIT

async def receive_loss_limit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva o novo limite de perda."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        limit_value = float(update.message.text.replace(',', '.'))
        if limit_value < 0:
            raise ValueError("Valor não pode ser negativo")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.daily_loss_limit = limit_value
            db.commit()

            feedback_text = f"✅ Limite de perda diário atualizado para ${limit_value:.2f}."
            if limit_value == 0:
                feedback_text = "✅ Limite de perda diário foi desativado."

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"{feedback_text}\n\nAjuste outra configuração ou volte.",
                reply_markup=bot_config_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="❌ Valor inválido. Por favor, tente novamente com um número positivo (ex: 50)."
        )
        return ASKING_LOSS_LIMIT

    return ConversationHandler.END

# --- MENU DE DESEMPENHO ---

async def performance_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o painel de desempenho e lida com a seleção de período, usando o fuso horário de SP."""
    query = update.callback_query
    try:
        await query.answer()
    except BadRequest as e:
        # callback antigo/expirado: não faz nada e evita stacktrace
        logger.warning(f"[perf] callback expirado/antigo: {e}")
        return

    user_id = query.from_user.id
    
    # --- LÓGICA DE FUSO HORÁRIO CORRIGIDA ---
    br_timezone = pytz.timezone("America/Sao_Paulo")
    now_br = datetime.now(br_timezone)
    
    callback_data = query.data
    start_dt, end_dt = None, None

    if callback_data == 'perf_today':
        start_dt = now_br.replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt = now_br
    elif callback_data == 'perf_yesterday':
        yesterday = now_br.date() - timedelta(days=1)
        start_dt = br_timezone.localize(datetime.combine(yesterday, time.min))
        end_dt = br_timezone.localize(datetime.combine(yesterday, time.max))
    elif callback_data == 'perf_7_days':
        start_dt = (now_br - timedelta(days=6)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt = now_br
    elif callback_data == 'perf_30_days':
        start_dt = (now_br - timedelta(days=29)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt = now_br

    if start_dt and end_dt:
        await query.edit_message_text(
            text="⏳ Calculando desempenho para o período selecionado...",
            reply_markup=performance_menu_keyboard()
        )
        
        report_text = await generate_performance_report(user_id, start_dt, end_dt)
        
        await query.edit_message_text(
            text=report_text,
            parse_mode='HTML',
            reply_markup=performance_menu_keyboard()
        )

# --- FLUXO DE CONFIGURAÇÃO DE WHITELIST ---

async def ask_coin_whitelist(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Prompt para editar Whitelist com instruções, categorias e o valor atual."""
    from telegram import InlineKeyboardButton, InlineKeyboardMarkup
    query = update.callback_query
    await query.answer()

    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("Não encontrei seu usuário. Use /start para registrar.")
            return ASKING_COIN_WHITELIST # Permanece no estado, mas informa o erro
            
        # COMENTÁRIO: Lógica adicionada para buscar a configuração atual do usuário.
        current_whitelist = getattr(user, 'coin_whitelist', 'todas') or 'todas'

        text = (
            f"✅ <b>Whitelist de Moedas</b>\n\n"
            f"⚙️ <b>Sua Configuração Atual:</b>\n<code>{current_whitelist}</code>\n\n"
            "Você pode definir exatamente <i>quais moedas</i> o bot poderá operar.\n\n"
            "🧩 <b>Como usar</b>\n"
            "• Digite tickers separados por vírgula (ex.: <code>BTCUSDT,ETHUSDT,SOLUSDT</code>)\n"
            "• Pode misturar <b>tickers</b> com <b>categorias</b>\n"
            "• Use <code>todas</code> para liberar todos os pares\n\n"
            "📦 <b>Categorias disponíveis</b>\n"
            "• <b>bluechips</b> → BTC, ETH, BNB\n"
            "• <b>altcoins</b> → SOL, XRP, ADA, AVAX, DOT, MATIC, LINK...\n"
            "• <b>defi</b> → UNI, AAVE, MKR, SNX, COMP, CRV...\n"
            "• <b>infra</b> → LINK, GRT, FIL\n"
            "• <b>memecoins</b> → DOGE, SHIB, PEPE, WIF, FLOKI, BONK\n\n"
            "ℹ️ Exemplos válidos:\n"
            "• <code>bluechips</code>\n"
            "• <code>memecoins,altcoins</code>\n"
            "• <code>BTCUSDT,ETHUSDT,defi</code>\n\n"
            "⬅️ Clique em <b>Voltar</b> para cancelar sem alterações."
        )

        markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("⬅️ Voltar", callback_data="back_to_settings_menu")]
        ])

        await query.edit_message_text(text, parse_mode="HTML", reply_markup=markup)
    finally:
        db.close()
        
    return ASKING_COIN_WHITELIST

async def receive_coin_whitelist(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Salva whitelist enviada pelo usuário e retorna ao menu de Configurações.
    Aceita tickers (ex.: BTCUSDT) e keywords de categorias (ex.: bluechips, defi, memecoins, infra, altcoins).
    """
    text = (update.message.text or "").strip()
    db = SessionLocal()
    try:
        if not text:
            await update.message.reply_text("Envie ao menos 1 ticker ou categoria. Ex.: BTCUSDT,ETHUSDT ou bluechips")
            return ConversationHandler.END

        # Normalização básica
        raw_items = [i.strip().upper() for i in text.split(",") if i.strip()]
        unique_items = []
        seen = set()
        for i in raw_items:
            if i not in seen:
                unique_items.append(i)
                seen.add(i)

        # Dica: não expandimos categorias na string salva; mantemos como o usuário enviou.
        # A checagem em tempo de execução usa core.whitelist_service.is_coin_in_whitelist(...)
        normalized = ",".join(unique_items)

        user = db.query(User).filter(User.telegram_id == update.effective_user.id).first()
        if not user:
            await update.message.reply_text("Usuário não encontrado. Use /start para registrar.")
            return ConversationHandler.END

        # Se seu modelo for user.coin_whitelist_str ou similar, ajuste o campo aqui:
        if hasattr(user, "coin_whitelist"):
            user.coin_whitelist = normalized
        elif hasattr(user, "coin_whitelist_str"):
            user.coin_whitelist_str = normalized
        else:
            # cria atributo em runtime para evitar quebra; ideal é usar o nome real do seu modelo
            setattr(user, "coin_whitelist", normalized)

        db.commit()

        # Apaga a mensagem do usuário para manter a timeline limpa (se possível)
        try:
            await update.message.delete()
        except Exception:
            pass

        # Mensagem de confirmação + retorno ao menu raiz de Configurações
        header = (
            "⚙️ <b>Configurações de Trade</b>\n"
            "<i>Whitelist atualizada com sucesso.</i>\n\n"
            f"📦 <b>Lista salva</b>: <code>{normalized}</code>"
        )
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=header,
            reply_markup=settings_menu_keyboard(user),
            parse_mode="HTML",
        )
    except Exception as e:
        db.rollback()
        logger.error(f"[settings] receive_coin_whitelist erro: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar a whitelist. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END

async def list_closed_trades_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Busca no DB e lista os últimos trades fechados do usuário."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    await query.edit_message_text("Buscando seu histórico de trades...")

    db = SessionLocal()
    try:
        # Busca os últimos 15 trades fechados, ordenados do mais recente para o mais antigo
        closed_trades = db.query(Trade).filter(
            Trade.user_telegram_id == user_id,
            Trade.status.like('%CLOSED%')
        ).order_by(Trade.closed_at.desc()).limit(15).all()

        message = "<b>📜 Seus Últimos Trades Fechados</b>\n\n"

        if not closed_trades:
            message += "Nenhum trade fechado encontrado no seu histórico."
        else:
            for trade in closed_trades:
                # Define o emoji e o texto do resultado com base no status e no P/L
                pnl = trade.closed_pnl if trade.closed_pnl is not None else 0.0
                resultado_str = f"<b>Resultado: ${pnl:,.2f}</b>"
                
                emoji = "❔"
                if trade.status == 'CLOSED_PROFIT':
                    emoji = "🏆"
                elif trade.status == 'CLOSED_LOSS':
                    emoji = "🛑"
                elif trade.status == 'CLOSED_MANUAL':
                    emoji = "✅" if pnl >= 0 else "🔻"
                elif trade.status == 'CLOSED_GHOST':
                    emoji = "ℹ️"
                    resultado_str = "<i>Fechado externamente</i>"

                # Formata a data de fechamento
                data_fechamento = trade.closed_at.strftime('%d/%m %H:%M') if trade.closed_at else 'N/A'

                message += (
                    f"{emoji} <b>{trade.symbol}</b> ({trade.side})\n"
                    f"  - Fechado em: {data_fechamento}\n"
                    f"  - {resultado_str}\n\n"
                )
        
        # Cria um teclado com o botão para voltar ao menu de desempenho
        keyboard = [[InlineKeyboardButton("⬅️ Voltar ao Desempenho", callback_data='perf_today')]]
        
        await query.edit_message_text(
            text=message,
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    finally:
        db.close()

async def prompt_manual_close_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe a tela de confirmação para o fechamento manual de uma posição."""
    query = update.callback_query
    await query.answer()
    
    # COMENTÁRIO: O callback agora é `confirm_close_<trade_id>`
    trade_id_str = query.data.split('_')[-1]
    if not trade_id_str.isdigit():
        # Lida com o formato antigo `confirm_close_group|SYMBOL|SIDE` como fallback
        await query.edit_message_text("Este botão é de uma versão antiga. Por favor, volte e abra o menu de posições novamente.")
        return

    trade_id = int(trade_id_str)
    
    db = SessionLocal()
    try:
        trade = db.query(Trade).filter_by(id=trade_id).first()
        if not trade:
            await query.edit_message_text("Erro: Trade não encontrado ou já fechado.")
            return

        message = (
            f"⚠️ <b>Confirmar Fechamento</b> ⚠️\n\n"
            f"Você tem certeza que deseja fechar manualmente sua posição em <b>{trade.symbol}</b> (ID: {trade.id})?\n\n"
            f"Esta ação é irreversível."
        )
        await query.edit_message_text(
            text=message,
            parse_mode='HTML',
            reply_markup=confirm_manual_close_keyboard(trade_id)
        )
    finally:
        db.close()

async def toggle_bot_status_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Liga/Desliga o bot ou ativa o modo dormir, em um ciclo de 3 estados."""
    query = update.callback_query
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == user_id).first()
        if not user:
            await query.answer("Usuário não encontrado.", show_alert=True)
            return

        # Lógica do ciclo de 3 estados
        alert_message = ""
        if not user.is_active:
            # ESTADO ATUAL: Pausado -> PRÓXIMO: Ativo 24h
            user.is_active = True
            user.is_sleep_mode_enabled = False
            alert_message = "Bot ATIVADO."
            
        elif user.is_active and not user.is_sleep_mode_enabled:
            # ESTADO ATUAL: Ativo 24h -> PRÓXIMO: Ativo com Modo Dormir
            user.is_sleep_mode_enabled = True
            alert_message = "Modo Dormir ATIVADO. O bot pausará entre 00:00 e 07:00."

        else: # user.is_active and user.is_sleep_mode_enabled
            # ESTADO ATUAL: Ativo com Modo Dormir -> PRÓXIMO: Pausado
            user.is_active = False
            user.is_sleep_mode_enabled = False # Reseta o modo dormir ao pausar
            alert_message = "Bot PAUSADO."

            # Mantém a lógica de cancelar ordens pendentes ao pausar
            api_key = decrypt_data(user.api_key_encrypted)
            api_secret = decrypt_data(user.api_secret_encrypted)
            pendentes = db.query(PendingSignal).filter_by(user_telegram_id=user_id).all()
            canceladas = 0
            for p in pendentes:
                try:
                    resp = await cancel_order(api_key, api_secret, p.order_id, p.symbol)
                    if not resp.get("success"):
                        logger.warning(f"[PAUSE] Falha ao cancelar ordem {p.order_id} ({p.symbol}): {resp.get('error')}")
                    db.delete(p)
                    canceladas += 1
                except Exception as e:
                    logger.error(f"[PAUSE] Exceção ao cancelar {p.order_id} ({p.symbol}): {e}", exc_info=True)
            
            if canceladas > 0:
                alert_message += f" {canceladas} ordem(ns) pendente(s) foi(ram) cancelada(s)."
        
        db.commit()
        await query.answer(alert_message, show_alert=True)

        # Atualiza o teclado do painel para refletir o novo estado
        await query.edit_message_reply_markup(reply_markup=dashboard_menu_keyboard(user))

    finally:
        db.close()

async def ask_entry_percent(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("📥 Envie o <b>tamanho de entrada</b> em % (ex.: 3.5)", parse_mode="HTML")
    return ASKING_ENTRY_PERCENT

async def ask_max_leverage(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("⚙️ Envie a <b>alavancagem máxima</b> (ex.: 5, 10, 20)", parse_mode="HTML")
    return ASKING_MAX_LEVERAGE

async def ask_min_confidence(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("🎯 Envie a <b>confiança mínima</b> em % (ex.: 70)", parse_mode="HTML")
    return ASKING_MIN_CONFIDENCE

async def ask_stop_gain_trigger(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("🚀 Envie o <b>gatilho</b> do Stop-Gain em % (ex.: 3)", parse_mode="HTML")
    return ASKING_STOP_GAIN_TRIGGER

async def ask_stop_gain_lock(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("🔒 Envie a <b>trava</b> do Stop-Gain em % (ex.: 1)", parse_mode="HTML")
    return ASKING_STOP_GAIN_LOCK

async def ask_circuit_threshold(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("⚡ Envie o <b>limite</b> do disjuntor (inteiro, ex.: 3)", parse_mode="HTML")
    return ASKING_CIRCUIT_THRESHOLD

async def ask_circuit_pause(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("⏸️ Envie a <b>pausa</b> após disparo (minutos, ex.: 120)", parse_mode="HTML")
    return ASKING_CIRCUIT_PAUSE

# ---- STOP-GAIN ----
async def receive_stop_gain_trigger(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip().replace("%", "").replace(",", ".")
    db = SessionLocal()
    try:
        value = float(text)
        if value < 0 or value > 100:
            await update.message.reply_text("Valor inválido. Envie entre 0 e 100 (ex.: 3)."); return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("Usuário não encontrado. Use /start para registrar."); return ConversationHandler.END
        user.stop_gain_trigger_pct = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"🛡️ <b>Stop-Gain</b>\n✅ Gatilho salvo: <b>{value:.2f}%</b>",
            reply_markup=stopgain_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("Não entendi. Envie um número (ex.: 3).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] stop_gain_trigger_pct: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END


async def receive_stop_gain_lock(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip().replace("%", "").replace(",", ".")
    db = SessionLocal()
    try:
        value = float(text)
        if value < 0 or value > 100:
            await update.message.reply_text("Valor inválido. Envie entre 0 e 100 (ex.: 1)."); return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("Usuário não encontrado. Use /start para registrar."); return ConversationHandler.END
        user.stop_gain_lock_pct = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"🛡️ <b>Stop-Gain</b>\n✅ Trava salva: <b>{value:.2f}%</b>",
            reply_markup=stopgain_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("Não entendi. Envie um número (ex.: 1).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] stop_gain_lock_pct: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END

# ---- DISJUNTOR ----
async def receive_circuit_threshold(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip()
    db = SessionLocal()
    try:
        value = int(float(text))
        if value < 0 or value > 1000:
            await update.message.reply_text("Valor inválido. Envie um inteiro entre 0 e 1000 (ex.: 3).")
            return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("Usuário não encontrado. Use /start para registrar."); return ConversationHandler.END
        user.circuit_breaker_threshold = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"🚫 <b>Disjuntor</b>\n✅ Limite salvo: <b>{value}</b>",
            reply_markup=circuit_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("Não entendi. Envie um número inteiro (ex.: 3).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] circuit_breaker_threshold: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END

async def receive_circuit_pause(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip().lower().replace("min", "").replace("m", "")
    db = SessionLocal()
    try:
        value = int(float(text))
        if value < 0 or value > 1440:
            await update.message.reply_text("Valor inválido. Envie um inteiro entre 0 e 1440 (ex.: 120).")
            return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("Usuário não encontrado. Use /start para registrar."); return ConversationHandler.END
        user.circuit_breaker_pause_minutes = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"🚫 <b>Disjuntor</b>\n✅ Pausa salva: <b>{value} min</b>",
            reply_markup=circuit_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("Não entendi. Envie um número inteiro (ex.: 120).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] circuit_breaker_pause_minutes: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END

async def signal_filters_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de configuração de filtros de sinais."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            await query.edit_message_text(
                "<b>🔬 Filtros de Análise Técnica</b>\n\n"
                "Ative e configure filtros para melhorar a qualidade dos sinais executados.",
                parse_mode='HTML',
                reply_markup=signal_filters_keyboard(user)
            )
    finally:
        db.close()

async def toggle_ma_filter_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ativa ou desativa o filtro de Média Móvel."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            user.is_ma_filter_enabled = not user.is_ma_filter_enabled
            db.commit()
            await query.edit_message_reply_markup(reply_markup=signal_filters_keyboard(user))
    finally:
        db.close()

async def toggle_rsi_filter_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ativa ou desativa o filtro de RSI."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            user.is_rsi_filter_enabled = not user.is_rsi_filter_enabled
            db.commit()
            await query.edit_message_reply_markup(reply_markup=signal_filters_keyboard(user))
    finally:
        db.close()

# --- Handlers para configurar os valores (exemplo para Período da MA) ---

async def ask_ma_period(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta o novo período da Média Móvel."""
    query = update.callback_query
    await query.answer()
    context.user_data['settings_message_id'] = query.message.message_id
    await query.edit_message_text("Envie o período para a Média Móvel (ex: 50).")
    return ASKING_MA_PERIOD

async def receive_ma_period(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe e salva o novo período da MA."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)
    try:
        value = int(update.message.text)
        if not (5 <= value <= 200): raise ValueError("Valor fora do range")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.ma_period = value
            db.commit()
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id, message_id=message_id_to_edit,
                text=f"✅ Período da MA atualizado para {value}.",
                reply_markup=signal_filters_keyboard(user)
            )
        finally:
            db.close()
    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id, message_id=message_id_to_edit,
            text="❌ Valor inválido. Envie um número inteiro entre 5 e 200."
        )
        return ASKING_MA_PERIOD
    return ConversationHandler.END

# --- Handlers para o Timeframe da Média Móvel ---
async def ask_ma_timeframe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe as opções de timeframe para o usuário escolher."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            await query.edit_message_text(
                "Selecione o tempo gráfico para o cálculo da Média Móvel:",
                reply_markup=ma_timeframe_keyboard(user)
            )
    finally:
        db.close()

async def set_ma_timeframe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Define o timeframe escolhido pelo usuário."""
    query = update.callback_query
    await query.answer()
    timeframe = query.data.split('_')[-1]
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            user.ma_timeframe = timeframe
            user.rsi_timeframe = timeframe # Sincroniza o timeframe do RSI por simplicidade
            db.commit()
            await query.edit_message_text(
                f"✅ Timeframe atualizado para {timeframe} minutos.",
                reply_markup=signal_filters_keyboard(user)
            )
    finally:
        db.close()


# --- Handlers para o Limite de Sobrevenda do RSI ---
async def ask_rsi_oversold(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    context.user_data['settings_message_id'] = query.message.message_id
    await query.edit_message_text("Envie o limite de **Sobrevenda** para o RSI (ex: 30).\nSinais de SHORT serão rejeitados se o RSI estiver abaixo deste valor.")
    return ASKING_RSI_OVERSOLD

async def receive_rsi_oversold(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)
    try:
        value = int(update.message.text)
        if not (10 <= value <= 40): raise ValueError("Valor fora do range")
        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.rsi_oversold_threshold = value
            db.commit()
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id, message_id=message_id_to_edit,
                text=f"✅ Limite de Sobrevenda do RSI atualizado para {value}.",
                reply_markup=signal_filters_keyboard(user)
            )
        finally:
            db.close()
    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id, message_id=message_id_to_edit,
            text="❌ Valor inválido. Envie um número inteiro entre 10 e 40."
        )
        return ASKING_RSI_OVERSOLD
    return ConversationHandler.END

# --- Handlers para o Limite de Sobrecompra do RSI ---
async def ask_rsi_overbought(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    context.user_data['settings_message_id'] = query.message.message_id
    await query.edit_message_text("Envie o limite de **Sobrecompra** para o RSI (ex: 70).\nSinais de LONG serão rejeitados se o RSI estiver acima deste valor.")
    return ASKING_RSI_OVERBOUGHT

async def receive_rsi_overbought(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)
    try:
        value = int(update.message.text)
        if not (60 <= value <= 90): raise ValueError("Valor fora do range")
        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.rsi_overbought_threshold = value
            db.commit()
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id, message_id=message_id_to_edit,
                text=f"✅ Limite de Sobrecompra do RSI atualizado para {value}.",
                reply_markup=signal_filters_keyboard(user)
            )
        finally:
            db.close()
    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id, message_id=message_id_to_edit,
            text="❌ Valor inválido. Envie um número inteiro entre 60 e 90."
        )
        return ASKING_RSI_OVERBOUGHT
    return ConversationHandler.END

async def show_risk_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("Não encontrei seu usuário. Use /start para registrar.")
            return
        header = ("🧮 <b>Risco & Tamanho</b>\n<i>Ajuste parâmetros de risco e tamanho de posição.</i>\n\n"
                  f"{_risk_summary(user)}")
        await query.edit_message_text(text=header, reply_markup=risk_menu_keyboard(user), parse_mode="HTML")
    except Exception as e:
        logger.error(f"[settings] submenu Risco: {e}", exc_info=True)
        await query.edit_message_text("Não foi possível abrir o submenu de Risco agora.")
    finally:
        db.close()

async def show_stopgain_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("Não encontrei seu usuário. Use /start para registrar.")
            return
        header = ("🛡️ <b>Stop-Gain</b>\n<i>Configure gatilho e trava do stop-gain.</i>\n\n"
                  f"{_stopgain_summary(user)}")
        await query.edit_message_text(text=header, reply_markup=stopgain_menu_keyboard(user), parse_mode="HTML")
    except Exception as e:
        logger.error(f"[settings] submenu Stop-Gain: {e}", exc_info=True)
        await query.edit_message_text("Não foi possível abrir o submenu de Stop-Gain agora.")
    finally:
        db.close()

async def show_circuit_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("Não encontrei seu usuário. Use /start para registrar.")
            return
        header = ("🚫 <b>Disjuntor</b>\n<i>Defina limite e pausa após disparo.</i>\n\n"
                  f"{_circuit_summary(user)}")
        await query.edit_message_text(text=header, reply_markup=circuit_menu_keyboard(user), parse_mode="HTML")
    except Exception as e:
        logger.error(f"[settings] submenu Disjuntor: {e}", exc_info=True)
        await query.edit_message_text("Não foi possível abrir o submenu de Disjuntor agora.")
    finally:
        db.close()

async def back_to_settings_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("Não encontrei seu usuário. Use /start para registrar.")
            return
        header = "⚙️ <b>Configurações de Trade</b>\n<i>Escolha uma categoria para ajustar seus parâmetros.</i>"
        await query.edit_message_text(text=header, reply_markup=settings_menu_keyboard(user), parse_mode="HTML")
    except Exception as e:
        logger.error(f"[settings] voltar menu raiz: {e}", exc_info=True)
        await query.edit_message_text("Não foi possível voltar ao menu de configurações agora.")
    finally:
        db.close()

async def back_from_whitelist_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Sai do estado de edição da Whitelist e volta ao menu de Configurações."""
    # reaproveita o handler existente para renderizar o menu
    await back_to_settings_menu_handler(update, context)
    return ConversationHandler.END

========================================
# Arquivo: bot/keyboards.py
========================================

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from database.crud import get_user_by_id

def main_menu_keyboard(telegram_id: int):
    """
    Retorna o teclado do menu principal de forma inteligente,
    verificando o status do usuário diretamente no banco de dados.
    """
    user = get_user_by_id(telegram_id)
    has_api_keys = user and user.api_key_encrypted is not None

    keyboard = []
    if has_api_keys:
        keyboard.append([InlineKeyboardButton("ℹ️ Meu Painel", callback_data='user_dashboard')])
        keyboard.append([InlineKeyboardButton("📊 Minhas Posições", callback_data='user_positions')])
        
        # --- BOTÃO ADICIONADO AQUI ---
        keyboard.append([InlineKeyboardButton("📈 Desempenho", callback_data='perf_today')])
        
        keyboard.append([InlineKeyboardButton("⚙️ Configurações de Trade", callback_data='user_settings')])
        keyboard.append([InlineKeyboardButton("🤖 Configuração do Bot", callback_data='bot_config')])
    else:
        keyboard.append([InlineKeyboardButton("⚙️ Configurar API Bybit", callback_data='config_api')])

    return InlineKeyboardMarkup(keyboard)

def dashboard_menu_keyboard(user):
    """Retorna o teclado para o painel do usuário, com a opção de remover a API e ligar/desligar o bot."""
    
    # Lógica do botão único de 3 estados
    if not user.is_active:
        # Estado 1: Pausado
        toggle_button_text = "Bot: Pausado ⏸️"
    elif user.is_active and not user.is_sleep_mode_enabled:
        # Estado 2: Ativo 24h
        toggle_button_text = "Bot: Ativo ☀️"
    else: # user.is_active and user.is_sleep_mode_enabled
        # Estado 3: Ativo com Modo Dormir
        toggle_button_text = "Bot: Ativo com Modo Dormir 😴"
    
    keyboard = [
        [InlineKeyboardButton(toggle_button_text, callback_data='toggle_bot_status')],
        [InlineKeyboardButton("🗑️ Remover API", callback_data='remove_api_prompt')],
        [InlineKeyboardButton("⬅️ Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def admin_menu_keyboard():
    """Retorna o teclado do menu de administrador."""
    keyboard = [
        [InlineKeyboardButton("📡 Listar Grupos/Canais", callback_data='admin_list_channels')],
        # --- NOVO BOTÃO ---
        [InlineKeyboardButton("👁️ Ver Alvos Ativos", callback_data='admin_view_targets')]
    ]
    return InlineKeyboardMarkup(keyboard)

def view_targets_keyboard():
    """Retorna o teclado para a tela de visualização de alvos, com um botão de voltar."""
    keyboard = [
        [InlineKeyboardButton("⬅️ Voltar ao Menu Admin", callback_data='back_to_admin_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def confirm_remove_keyboard():
    """Retorna o teclado de confirmação para remover a API."""
    keyboard = [
        [InlineKeyboardButton("✅ Sim, remover", callback_data='remove_api_confirm')],
        [InlineKeyboardButton("❌ Não, cancelar", callback_data='remove_api_cancel')],
    ]
    return InlineKeyboardMarkup(keyboard)

def settings_menu_keyboard(user) -> InlineKeyboardMarkup:
    kb = [
        [
            InlineKeyboardButton("🧮 Risco & Tamanho", callback_data="settings_risk"),
            InlineKeyboardButton("🛡️ Stop-Gain", callback_data="settings_stopgain"),
        ],
        [
            InlineKeyboardButton("🚫 Disjuntor", callback_data="settings_circuit"),
            InlineKeyboardButton("✅ Whitelist", callback_data="set_coin_whitelist"),
        ],
        [InlineKeyboardButton("🔬 Filtros de Sinais", callback_data="signal_filters_menu")],
        [InlineKeyboardButton("⬅️ Voltar ao Menu", callback_data="back_to_main_menu")],
    ]
    return InlineKeyboardMarkup(kb)


def risk_menu_keyboard(user) -> InlineKeyboardMarkup:
    entry_pct = f"{float(getattr(user, 'entry_size_percent', 0) or 0):.1f}%"
    leverage  = f"{int(getattr(user, 'max_leverage', 0) or 0)}x"
    min_conf  = f"{float(getattr(user, 'min_confidence', 0) or 0):.1f}%"
    kb = [
        [InlineKeyboardButton(f"📥 Tamanho de Entrada ({entry_pct})", callback_data="set_entry_percent")],
        [InlineKeyboardButton(f"⚙️ Alavancagem Máx. ({leverage})", callback_data="set_max_leverage")],
        [InlineKeyboardButton(f"🎯 Confiança Mín. ({min_conf})", callback_data="set_min_confidence")],
        [InlineKeyboardButton("⬅️ Voltar", callback_data="back_to_settings_menu")],
    ]
    return InlineKeyboardMarkup(kb)

def _read_stop_strategy_label(user) -> str:
    raw = (getattr(user, "stop_strategy", None)
           or getattr(user, "stop_strategy_mode", None)
           or getattr(user, "stop_strategy_type", None)
           or "breakeven")
    raw = str(raw).lower()
    return "Breakeven" if raw.startswith("b") else "Trailing"

def stopgain_menu_keyboard(user) -> InlineKeyboardMarkup:
    trigger = f"{float(getattr(user, 'stop_gain_trigger_pct', 0) or 0):.2f}%"
    lock    = f"{float(getattr(user, 'stop_gain_lock_pct', 0) or 0):.2f}%"
    strategy_label = _read_stop_strategy_label(user)

    kb = [
        [InlineKeyboardButton(f"🧭 Estratégia: {strategy_label}", callback_data="set_stop_strategy")],
        [InlineKeyboardButton(f"🚀 Gatilho Stop-Gain ({trigger})", callback_data="set_stop_gain_trigger")],
        [InlineKeyboardButton(f"🔒 Trava Stop-Gain ({lock})", callback_data="set_stop_gain_lock")],
        [InlineKeyboardButton("⬅️ Voltar", callback_data="back_to_settings_menu")],
    ]
    return InlineKeyboardMarkup(kb)

def circuit_menu_keyboard(user) -> InlineKeyboardMarkup:
    threshold = f"{int(getattr(user, 'circuit_breaker_threshold', 0) or 0)}"
    pause     = f"{int(getattr(user, 'circuit_breaker_pause_minutes', 0) or 0)} min"
    kb = [
        [InlineKeyboardButton(f"⚡ Limite do Disjuntor ({threshold})", callback_data="set_circuit_threshold")],
        [InlineKeyboardButton(f"⏸️ Pausa após Disparo ({pause})", callback_data="set_circuit_pause")],
        [InlineKeyboardButton("⬅️ Voltar", callback_data="back_to_settings_menu")],
    ]
    return InlineKeyboardMarkup(kb)

def bot_config_keyboard(user_settings):
    """
    Retorna o teclado para o menu de configuração do bot, mostrando o modo de aprovação e as metas.
    """
    # Botão de Modo de Aprovação (lógica existente)
    mode = user_settings.approval_mode
    if mode == 'AUTOMATIC':
        approval_button_text = "Entrada de Sinais: Automático ⚡"
    else:
        approval_button_text = "Entrada de Sinais: Manual 👋"

    # --- NOVOS BOTÕES DE METAS ---
    # Formata a meta de lucro para exibição
    profit_target = user_settings.daily_profit_target
    profit_text = f"Meta de Lucro Diária: ${profit_target:.2f}" if profit_target > 0 else "Meta de Lucro Diária: Desativada"

    # Formata o limite de perda para exibição
    loss_limit = user_settings.daily_loss_limit
    loss_text = f"Limite de Perda Diário: ${loss_limit:.2f}" if loss_limit > 0 else "Limite de Perda Diário: Desativado"

    keyboard = [
        [InlineKeyboardButton(approval_button_text, callback_data='toggle_approval_mode')],
        # --- NOVAS LINHAS ADICIONADAS AO TECLADO ---
        [InlineKeyboardButton(profit_text, callback_data='set_profit_target')],
        [InlineKeyboardButton(loss_text, callback_data='set_loss_limit')],
        [InlineKeyboardButton("⬅️ Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def signal_approval_keyboard(signal_for_approval_id: int):
    """
    Retorna o teclado com os botões de Aprovar/Rejeitar para um sinal manual.
    """
    keyboard = [
        [
            InlineKeyboardButton("✅ Aprovar Entrada", callback_data=f'approve_signal_{signal_for_approval_id}'),
            InlineKeyboardButton("❌ Rejeitar", callback_data=f'reject_signal_{signal_for_approval_id}')
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

def performance_menu_keyboard():
    """
    Retorna o teclado para o menu de análise de desempenho com filtros de período.
    """
    keyboard = [
        [
            InlineKeyboardButton("Hoje", callback_data='perf_today'),
            InlineKeyboardButton("Ontem", callback_data='perf_yesterday')
        ],
        [
            InlineKeyboardButton("Últimos 7 Dias", callback_data='perf_7_days'),
            InlineKeyboardButton("Últimos 30 Dias", callback_data='perf_30_days')
        ],
        [InlineKeyboardButton("📜 Histórico de Trades", callback_data='list_closed_trades')],
        [InlineKeyboardButton("⬅️ Voltar ao Menu Principal", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def confirm_manual_close_keyboard(trade_id: int):
    """Retorna o teclado de confirmação para o fechamento manual de um trade."""
    keyboard = [
        [
            InlineKeyboardButton("✅ Sim, fechar", callback_data=f'execute_close_{trade_id}'),
            InlineKeyboardButton("❌ Cancelar", callback_data='user_positions') # Volta para a lista de posições
        ],
    ]
    return InlineKeyboardMarkup(keyboard)

def signal_filters_keyboard(user_settings):
    """
    Retorna o teclado para o menu de configuração dos filtros de análise técnica.
    """
    # Botão para o filtro de Média Móvel (MA)
    ma_status_icon = "✅" if user_settings.is_ma_filter_enabled else "❌"
    ma_text = f"{ma_status_icon} Filtro de Média Móvel"

    # Botão para o filtro de RSI
    rsi_status_icon = "✅" if user_settings.is_rsi_filter_enabled else "❌"
    rsi_text = f"{rsi_status_icon} Filtro de RSI"
    
    keyboard = [
        [InlineKeyboardButton("Voltar para Configurações ⬅️", callback_data='user_settings')],
        [
            InlineKeyboardButton(ma_text, callback_data='toggle_ma_filter'),
            InlineKeyboardButton(f"Período MA: {user_settings.ma_period}", callback_data='set_ma_period')
        ],
        [
            InlineKeyboardButton(rsi_text, callback_data='toggle_rsi_filter'),
            InlineKeyboardButton(f"Sobrecompra: {user_settings.rsi_overbought_threshold}", callback_data='set_rsi_overbought')
        ],
        [
            InlineKeyboardButton(f"Timeframe: {user_settings.ma_timeframe} min", callback_data='ask_ma_timeframe'),
            InlineKeyboardButton(f"Sobrevenda: {user_settings.rsi_oversold_threshold}", callback_data='set_rsi_oversold')
        ],
    ]
    return InlineKeyboardMarkup(keyboard)

def ma_timeframe_keyboard(user_settings):
    """
    Retorna o teclado com as opções de timeframe para a Média Móvel.
    """
    # Marca o timeframe atual com um emoji
    timeframes = {'15': '15 min', '60': '1 hora', '240': '4 horas', 'D': 'Diário'}
    keyboard_buttons = []
    
    for tf_value, tf_text in timeframes.items():
        prefix = "✅ " if user_settings.ma_timeframe == tf_value else ""
        keyboard_buttons.append(
            InlineKeyboardButton(f"{prefix}{tf_text}", callback_data=f"set_ma_timeframe_{tf_value}")
        )
    
    # Organiza os botões em duas colunas
    keyboard = [keyboard_buttons[i:i + 2] for i in range(0, len(keyboard_buttons), 2)]
    keyboard.append([InlineKeyboardButton("⬅️ Voltar para Filtros", callback_data='signal_filters_menu')])
    return InlineKeyboardMarkup(keyboard)

========================================
# Arquivo: alembic/env.py
========================================

import os
import sys
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# Adiciona a raiz do projeto ao path para que possamos importar 'database.models'
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from database.models import Base

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # --- INÍCIO DA MODIFICAÇÃO ---
    # Pega a configuração do alembic.ini
    configuration = config.get_section(config.config_ini_section, {})
    # Tenta pegar a URL de uma variável de ambiente, se não existir, usa a do .ini
    url = os.getenv('DATABASE_URL', configuration['sqlalchemy.url'])
    configuration['sqlalchemy.url'] = url
    
    connectable = engine_from_config(
        configuration, # Usa a configuração modificada
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


========================================
# Arquivo: alembic/versions/657fc8fb3f24_adiciona_filtros_de_analise_tecnica.py
========================================

"""adiciona_filtros_de_analise_tecnica

Revision ID: 657fc8fb3f24
Revises: c19acb6f35e0
Create Date: 2025-08-26 18:19:40.264746

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '657fc8fb3f24'
down_revision: Union[str, Sequence[str], None] = 'c19acb6f35e0'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('is_ma_filter_enabled', sa.Boolean(), nullable=False))
    op.add_column('users', sa.Column('ma_period', sa.Integer(), nullable=False))
    op.add_column('users', sa.Column('ma_timeframe', sa.String(length=10), nullable=False))
    op.add_column('users', sa.Column('is_rsi_filter_enabled', sa.Boolean(), nullable=False))
    op.add_column('users', sa.Column('rsi_timeframe', sa.String(length=10), nullable=False))
    op.add_column('users', sa.Column('rsi_oversold_threshold', sa.Integer(), nullable=False))
    op.add_column('users', sa.Column('rsi_overbought_threshold', sa.Integer(), nullable=False))
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('users', 'rsi_overbought_threshold')
    op.drop_column('users', 'rsi_oversold_threshold')
    op.drop_column('users', 'rsi_timeframe')
    op.drop_column('users', 'is_rsi_filter_enabled')
    op.drop_column('users', 'ma_timeframe')
    op.drop_column('users', 'ma_period')
    op.drop_column('users', 'is_ma_filter_enabled')
    # ### end Alembic commands ###


========================================
# Arquivo: alembic/versions/b2a5a70c97b3_add_missing_cycles_and_last_seen_at_to_.py
========================================

"""add missing_cycles and last_seen_at to trades

Revision ID: b2a5a70c97b3
Revises: 657fc8fb3f24
Create Date: 2025-08-29 10:39:42.185181

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'b2a5a70c97b3'
down_revision: Union[str, Sequence[str], None] = '657fc8fb3f24'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None



def upgrade() -> None:
    bind = op.get_bind()
    insp = sa.inspect(bind)
    cols = {c["name"] for c in insp.get_columns("trades")}
    dialect = bind.dialect.name  # "sqlite", "postgresql", etc.

    # missing_cycles
    if "missing_cycles" not in cols:
        op.add_column(
            "trades",
            sa.Column("missing_cycles", sa.Integer(), nullable=False, server_default="0"),
        )
        # Remover default apenas em Postgres; SQLite não suporta DROP DEFAULT
        if dialect == "postgresql":
            op.execute("ALTER TABLE trades ALTER COLUMN missing_cycles DROP DEFAULT")

    # last_seen_at
    if "last_seen_at" not in cols:
        op.add_column(
            "trades",
            sa.Column("last_seen_at", sa.DateTime(timezone=True), nullable=True),
        )

def downgrade() -> None:
    bind = op.get_bind()
    insp = sa.inspect(bind)
    cols = {c["name"] for c in insp.get_columns("trades")}

    if "last_seen_at" in cols:
        op.drop_column("trades", "last_seen_at")
    if "missing_cycles" in cols:
        op.drop_column("trades", "missing_cycles")

========================================
# Arquivo: alembic/versions/c19acb6f35e0_versao_inicial_do_projeto.py
========================================

"""versao_inicial_do_projeto

Revision ID: c19acb6f35e0
Revises: 
Create Date: 2025-08-26 17:47:42.959909

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'c19acb6f35e0'
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('invite_codes',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('code', sa.String(), nullable=False),
    sa.Column('is_used', sa.Boolean(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('code')
    )
    op.create_table('monitored_targets',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('channel_id', sa.BigInteger(), nullable=False),
    sa.Column('channel_name', sa.String(), nullable=True),
    sa.Column('topic_id', sa.BigInteger(), nullable=True),
    sa.Column('topic_name', sa.String(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('topic_id')
    )
    op.create_table('pending_signals',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('symbol', sa.String(), nullable=False),
    sa.Column('order_id', sa.String(), nullable=False),
    sa.Column('signal_data', sa.JSON(), nullable=False),
    sa.Column('notification_message_id', sa.BigInteger(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('order_id'),
    sa.UniqueConstraint('user_telegram_id', 'symbol', name='_user_symbol_uc')
    )
    op.create_index(op.f('ix_pending_signals_symbol'), 'pending_signals', ['symbol'], unique=False)
    op.create_index(op.f('ix_pending_signals_user_telegram_id'), 'pending_signals', ['user_telegram_id'], unique=False)
    op.create_table('signals_for_approval',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('symbol', sa.String(), nullable=False),
    sa.Column('source_name', sa.String(), nullable=True),
    sa.Column('signal_data', sa.JSON(), nullable=False),
    sa.Column('approval_message_id', sa.BigInteger(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_signals_for_approval_user_telegram_id'), 'signals_for_approval', ['user_telegram_id'], unique=False)
    op.create_table('trades',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('order_id', sa.String(), nullable=False),
    sa.Column('notification_message_id', sa.BigInteger(), nullable=True),
    sa.Column('symbol', sa.String(), nullable=False),
    sa.Column('side', sa.String(), nullable=False),
    sa.Column('qty', sa.Float(), nullable=False),
    sa.Column('entry_price', sa.Float(), nullable=True),
    sa.Column('stop_loss', sa.Float(), nullable=True),
    sa.Column('current_stop_loss', sa.Float(), nullable=True),
    sa.Column('initial_targets', sa.JSON(), nullable=True),
    sa.Column('total_initial_targets', sa.Integer(), nullable=True),
    sa.Column('status', sa.String(), nullable=True),
    sa.Column('remaining_qty', sa.Float(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=True),
    sa.Column('closed_at', sa.DateTime(timezone=True), nullable=True),
    sa.Column('closed_pnl', sa.Float(), nullable=True),
    sa.Column('is_breakeven', sa.Boolean(), nullable=False),
    sa.Column('trail_high_water_mark', sa.Float(), nullable=True),
    sa.Column('is_stop_gain_active', sa.Boolean(), nullable=False),
    sa.Column('unrealized_pnl_pct', sa.Float(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('order_id')
    )
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('first_name', sa.String(), nullable=True),
    sa.Column('api_key_encrypted', sa.String(), nullable=True),
    sa.Column('api_secret_encrypted', sa.String(), nullable=True),
    sa.Column('entry_size_percent', sa.Float(), nullable=True),
    sa.Column('max_leverage', sa.Integer(), nullable=True),
    sa.Column('min_confidence', sa.Float(), nullable=True),
    sa.Column('approval_mode', sa.String(), nullable=False),
    sa.Column('daily_profit_target', sa.Float(), nullable=False),
    sa.Column('daily_loss_limit', sa.Float(), nullable=False),
    sa.Column('coin_whitelist', sa.String(), nullable=False),
    sa.Column('stop_strategy', sa.String(length=20), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('stop_gain_trigger_pct', sa.Float(), nullable=False),
    sa.Column('stop_gain_lock_pct', sa.Float(), nullable=False),
    sa.Column('circuit_breaker_threshold', sa.Integer(), nullable=False),
    sa.Column('circuit_breaker_pause_minutes', sa.Integer(), nullable=False),
    sa.Column('long_trades_paused_until', sa.DateTime(timezone=True), nullable=True),
    sa.Column('short_trades_paused_until', sa.DateTime(timezone=True), nullable=True),
    sa.Column('is_sleep_mode_enabled', sa.Boolean(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_telegram_id'), 'users', ['telegram_id'], unique=True)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_users_telegram_id'), table_name='users')
    op.drop_table('users')
    op.drop_table('trades')
    op.drop_index(op.f('ix_signals_for_approval_user_telegram_id'), table_name='signals_for_approval')
    op.drop_table('signals_for_approval')
    op.drop_index(op.f('ix_pending_signals_user_telegram_id'), table_name='pending_signals')
    op.drop_index(op.f('ix_pending_signals_symbol'), table_name='pending_signals')
    op.drop_table('pending_signals')
    op.drop_table('monitored_targets')
    op.drop_table('invite_codes')
    # ### end Alembic commands ###


========================================
# Arquivo: alembic/versions/ea992c8d7b70_add_trades_missing_cycles_and_last_seen_.py
========================================

"""add trades.missing_cycles and last_seen_at

Revision ID: ea992c8d7b70
Revises: b2a5a70c97b3
Create Date: 2025-08-29 12:39:12.562656

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'ea992c8d7b70'
down_revision: Union[str, Sequence[str], None] = 'b2a5a70c97b3'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


========================================
# Arquivo: services/__init__.py
========================================



========================================
# Arquivo: services/bybit_service.py
========================================

import logging
import asyncio
import os
import random
from typing import Dict, Any, Optional
from datetime import datetime, time, timedelta
from pybit.unified_trading import HTTP
from pybit.exceptions import InvalidRequestError
from database.models import User
from decimal import Decimal, ROUND_DOWN, ROUND_CEILING
from telegram import InlineKeyboardButton, InlineKeyboardMarkup

logger = logging.getLogger(__name__)
INSTRUMENT_INFO_CACHE: Dict[str, Any] = {}

def _round_down_to_step(value: Decimal, step: Decimal) -> Decimal:
    """Arredonda para BAIXO no múltiplo de 'step' (quantidade)."""
    if step <= 0:
        return value
    return (value // step) * step

def _round_down_to_tick(price: Decimal, tick: Decimal) -> Decimal:
    """Arredonda para BAIXO no múltiplo de 'tick' (preço)."""
    if tick <= 0:
        return price
    return (price // tick) * tick

def _round_up_to_tick(price: Decimal, tick: Decimal) -> Decimal:
    """Arredonda para CIMA no múltiplo de 'tick' (preço), sem alterar se já estiver alinhado."""
    if tick <= 0:
        return price
    q, r = divmod(price, tick)
    if r == 0:
        return price
    return (q + 1) * tick

def _apply_safety_ticks(
    side: str,
    desired_sl: Decimal,
    last_price: Decimal,
    tick: Decimal,
    safety_ticks: int
) -> Decimal:
    """
    Garante distância mínima de N ticks do last_price, respeitando o lado:
      - LONG  (posição Buy):  SL < last_price - N*tick  (usa floor)
      - SHORT (posição Sell): SL > last_price + N*tick  (usa ceil)
    Retorna preço já alinhado ao tick.
    """
    if tick <= 0 or safety_ticks <= 0:
        return desired_sl

    n = Decimal(safety_ticks)
    if side.upper() in ("LONG", "BUY"):
        limite_max = last_price - (n * tick)   # deve ser estritamente abaixo do last
        # alinhar o limite para baixo no tick
        if limite_max > 0:
            limite_max = (limite_max // tick) * tick
        # nunca acima do limite
        return desired_sl if desired_sl <= limite_max else limite_max

    else:  # SHORT / SELL
        limite_min = last_price + (n * tick)   # deve ser estritamente acima do last
        # alinhar o limite para cima no tick
        if tick > 0:
            q, r = divmod(limite_min, tick)
            if r != 0:
                limite_min = (q + 1) * tick
        # nunca abaixo do limite
        return desired_sl if desired_sl >= limite_min else limite_min

async def get_instrument_info(symbol: str) -> Dict[str, Any]:
    """
    Busca as regras de um instrumento (símbolo) da Bybit, usando um cache em memória.
    """
    if symbol in INSTRUMENT_INFO_CACHE:
        return INSTRUMENT_INFO_CACHE[symbol]

    def _sync_call():
        try:
            # Sessão não autenticada com timeout (sem 'retries')
            session = HTTP(testnet=False, timeout=30)
            response = session.get_instruments_info(category="linear", symbol=symbol)
            
            if response.get("retCode") != 0:
                return {"success": False, "error": response.get("retMsg")}
            
            instrument_list = response.get("result", {}).get("list", [])
            if not instrument_list:
                return {"success": False, "error": f"Símbolo {symbol} não encontrado na Bybit."}

            info = instrument_list[0]
            lot_size_filter = info.get("lotSizeFilter", {})
            price_filter = info.get("priceFilter", {})

            rules = {
                "success": True,
                "status": info.get("status"),
                "qtyStep": Decimal(lot_size_filter.get("qtyStep", "0")),
                "minOrderQty": Decimal(lot_size_filter.get("minOrderQty", "0")),
                "minNotionalValue": Decimal(lot_size_filter.get("minOrderIv", "0")),
                "tickSize": Decimal(price_filter.get("tickSize", "0")),
            }
            INSTRUMENT_INFO_CACHE[symbol] = rules
            return rules
    
        except Exception as e:
            logger.error(f"Exceção em get_instrument_info para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


# Função auxiliar síncrona, não precisa de 'async'
def get_session(api_key: str, api_secret: str) -> HTTP:
    """Cria e retorna uma sessão HTTP para ser usada em threads."""
    return HTTP(
        testnet=False,
        api_key=api_key,
        api_secret=api_secret,
        timeout=30,
        recv_window=30000  # ↑ aumentamos para mitigar 10002 por drift/latência
    )

def _resolve_position_index(session, symbol: str, close_side: str) -> Dict[str, Any]:
    """
    Descobre o mode (One-Way vs Hedge) e qual positionIdx usar (ou omitir) ao reduzir posição.
    - One-Way: não enviar positionIdx (ou usar 0).
    - Hedge: usar 1 (Long/Buy) para reduzir LONG; usar 2 (Short/Sell) para reduzir SHORT.

    close_side: "Buy" ou "Sell" (lado da ORDEM de fechamento, não o 'trade.side').
    Retorna:
      {
        "mode": "one_way" | "hedge" | "unknown",
        "positionIdx": int | None,  # None => omitir no payload
        "position_found": bool,     # se há posição aberta detectada
        "details": {...}            # dados brutos mínimos para log/inspeção
      }
    """
    try:
        resp = session.get_positions(category="linear", symbol=symbol)
        if resp.get("retCode") != 0:
            logger.warning(f"[bybit_service] _resolve_position_index: falha em get_positions para {symbol}: {resp.get('retMsg')}")
            # fallback seguro: omitir positionIdx
            return {"mode": "unknown", "positionIdx": None, "position_found": False, "details": {"reason": "api_error"}}

        items = (resp.get("result", {}) or {}).get("list", []) or []
        # Normalizações úteis
        positions_nonzero = [p for p in items if float(p.get("size") or 0) > 0]
        idxs = {int(p.get("positionIdx") or 0) for p in items}

        # Heurística de detecção:
        # - One-Way geralmente retorna positionIdx 0 (ou único item), e só existe um lado efetivo.
        # - Hedge usa 1 (Long/Buy) e 2 (Short/Sell). Pode retornar dois itens para o símbolo.
        mode = "one_way"
        if 1 in idxs or 2 in idxs:
            mode = "hedge"
        elif len(items) > 1:
            # Vários itens mas sem 1/2 explícitos — trate como hedge por segurança
            mode = "hedge"

        # Mapeia qual idx usar conforme o lado que será reduzido
        # close_side = "Sell" se trade era LONG; "Buy" se trade era SHORT.
        position_idx = None
        position_found = False

        if mode == "hedge":
            # Encontre a posição correspondente ao lado que será reduzido
            # Em Hedge, Buy = LONG (idx 1), Sell = SHORT (idx 2)
            desired_idx = 1 if close_side == "Sell" else 2
            for p in items:
                if int(p.get("positionIdx") or 0) == desired_idx and float(p.get("size") or 0) > 0:
                    position_found = True
                    break
            # Mesmo que size=0, ainda usamos o idx “correto” para o lado.
            position_idx = desired_idx

        elif mode == "one_way":
            # Em One-Way, omita o campo (ou use 0). Preferimos omitir para evitar 10001.
            # Verifica se existe alguma posição aberta > 0
            position_found = any(positions_nonzero)
            position_idx = None  # omitir

        details = {
            "raw_count": len(items),
            "idxs": sorted(list(idxs)),
            "close_side": close_side,
            "positions_nonzero": len(positions_nonzero),
        }

        logger.info(f"[bybit_service] _resolve_position_index {symbol}: mode={mode}, close_side={close_side}, use_idx={position_idx}, found={position_found}, details={details}")
        return {"mode": mode, "positionIdx": position_idx, "position_found": position_found, "details": details}

    except Exception as e:
        logger.error(f"Exceção em _resolve_position_index para {symbol}: {e}", exc_info=True)
        # fallback seguro: omitir positionIdx
        return {"mode": "unknown", "positionIdx": None, "position_found": False, "details": {"reason": "exception", "error": str(e)}}


async def get_account_info(api_key: str, api_secret: str) -> dict:
    """Busca o saldo da conta, calculando o saldo disponível para Contas Unificadas."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.get_wallet_balance(accountType="UNIFIED")
            
            if response.get('retCode') == 0:
                account_data_list = response['result'].get('list', [])
                if not account_data_list:
                    return {"success": False, "data": {}, "error": "Lista de contas vazia na resposta da API."}
                
                account_data = account_data_list[0]
                equity_str = account_data.get('totalEquity')
                total_equity = float(equity_str) if equity_str else 0.0
                coin_list = account_data.get('coin', [])
                
                available_balance_usdt = 0.0
                for coin in coin_list:
                    if coin.get('coin') == 'USDT':
                        wallet_balance_str = coin.get('walletBalance', '0')
                        order_margin_str = coin.get('totalOrderIM', '0')
                        position_margin_str = coin.get('totalPositionIM', '0')

                        wallet_balance = float(wallet_balance_str) if wallet_balance_str else 0.0
                        order_margin = float(order_margin_str) if order_margin_str else 0.0
                        position_margin = float(position_margin_str) if position_margin_str else 0.0
                        
                        # Cálculo correto para Conta de Trading Unificada
                        available_balance_usdt = wallet_balance - order_margin - position_margin
                        break
                
                result_data = {
                    "total_equity": total_equity,
                    "available_balance_usdt": available_balance_usdt,
                    "coin_list": coin_list
                }
                return {"success": True, "data": result_data}
                
            return {"success": False, "data": {}, "error": response.get('retMsg', 'Erro desconhecido')}
        except Exception as e:
            logger.error(f"Exceção em get_account_info: {e}", exc_info=True)
            return {"success": False, "data": {}, "error": str(e)}

    return await asyncio.to_thread(_sync_call)

async def place_order(api_key: str, api_secret: str, signal_data: dict, user_settings: User, balance: float) -> dict:
    """Abre uma nova posição a mercado (Market) com validação completa, incluindo verificação de SL contra o preço atual."""
    symbol = signal_data['coin']
    
    # --- NOVA VERIFICAÇÃO DE PRÉ-VOO ---
    # Buscamos o preço de mercado ANTES de qualquer outra coisa
    price_check = await get_market_price(symbol)
    if not price_check.get("success"):
        return {"success": False, "error": f"Não foi possível obter o preço de mercado atual para {symbol}."}
    current_market_price = Decimal(str(price_check["price"]))
    
    # Validamos o Stop Loss do sinal contra o preço atual
    side = "Buy" if (signal_data.get('order_type') or '').upper() == 'LONG' else "Sell"
    stop_loss_price = Decimal(str(signal_data.get('stop_loss')))

    if side == 'Buy' and stop_loss_price >= current_market_price:
        return {"success": False, "error": f"Stop Loss ({stop_loss_price}) inválido para LONG. Deve ser menor que o preço atual ({current_market_price})."}
    if side == 'Sell' and stop_loss_price <= current_market_price:
        return {"success": False, "error": f"Stop Loss ({stop_loss_price}) inválido para SHORT. Deve ser maior que o preço atual ({current_market_price})."}
    
    # Se a validação passou, continuamos para a lógica de execução síncrona
    async def pre_flight_checks():
        if symbol not in INSTRUMENT_INFO_CACHE: await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            if not instrument_rules or not instrument_rules.get("success"): return instrument_rules or {"success": False, "error": f"Regras para {symbol} não encontradas."}
            if instrument_rules["status"] != "Trading": return {"success": False, "error": f"O símbolo {symbol} não está ativo para negociação ({instrument_rules['status']})."}

            session = get_session(api_key, api_secret)
            leverage = Decimal(str(user_settings.max_leverage))
            
            # Usamos o preço de mercado que acabamos de buscar para o cálculo
            entry_price = current_market_price
            
            margin_in_dollars = Decimal(str(balance)) * (Decimal(str(user_settings.entry_size_percent)) / Decimal("100"))
            notional_value = margin_in_dollars * leverage
            
            if entry_price <= 0: return {"success": False, "error": f"Preço de entrada inválido: {entry_price}"}
            qty_raw = notional_value / entry_price
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])

            if qty_adj < instrument_rules["minOrderQty"]:
                return {"success": False, "error": f"Qtd. ajustada ({qty_adj:f}) é menor que a mínima permitida ({instrument_rules['minOrderQty']:f}) para {symbol}."}
            final_notional_value = qty_adj * entry_price
            if final_notional_value < instrument_rules["minNotionalValue"]:
                return {"success": False, "error": f"Valor total da ordem (${final_notional_value:.2f}) é menor que o mínimo permitido de ${instrument_rules['minNotionalValue']:.2f}."}
            
            payload = {
                "category": "linear", "symbol": symbol, "side": side, "orderType": "Market", "qty": str(qty_adj),
                "takeProfit": str((signal_data.get('targets') or [None])[0]), "stopLoss": str(stop_loss_price),
            }
            try:
                session.set_leverage(category="linear", symbol=symbol, buyLeverage=str(leverage), sellLeverage=str(leverage))
            except InvalidRequestError as e:
                if "leverage not modified" in str(e).lower(): logger.warning(f"Alavancagem para {symbol} já está correta. Continuando...")
                else: return {"success": False, "error": str(e)}
            
            _safe_log_order_payload("place_order:market_entry", payload)
            response = session.place_order(**{k: v for k, v in payload.items() if v is not None})
            if response.get('retCode') == 0: return {"success": True, "data": response['result']}
            return {"success": False, "error": response.get('retMsg')}
      
        except Exception as e:
            logger.error(f"Exceção ao abrir ordem (Market): {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"Exceção em place_order (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}


async def get_market_price(symbol: str) -> dict:
    """Busca o preço de mercado atual de forma assíncrona."""
    def _sync_call():
        try:
            session = HTTP(testnet=False, timeout=30)
            response = session.get_tickers(category="linear", symbol=symbol)
            if response.get('retCode') == 0 and response['result']['list']:
                price = float(response['result']['list'][0]['lastPrice'])
                return {"success": True, "price": price}
            else:
                return {"success": False, "error": response.get('retMsg', 'Preço não encontrado')}
        except Exception as e:
            logger.error(f"Exceção ao buscar preço de mercado para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def close_partial_position(api_key: str, api_secret: str, symbol: str, qty_to_close: float, side: str, position_idx: int) -> dict:
    """Fecha parte de uma posição com Market/ReduceOnly.
    - Detecta o lado REAL da posição no exchange (não confia no `side` recebido).
    - Aplica One-Way vs Hedge automaticamente (usa/omite positionIdx conforme o modo).
    - Em 110017 (reduceOnly mesmo lado) e 10001 (idx/mode), faz retry defensivo.
    """
    async def pre_flight_checks():
        if symbol not in INSTRUMENT_INFO_CACHE:
            await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            if not instrument_rules or not instrument_rules.get("success"):
                return instrument_rules or {"success": False, "error": f"Regras para {symbol} não encontradas."}

            session = get_session(api_key, api_secret)

            # 0) Descobre a(s) posição(ões) atual(is) na corretora
            pos_resp = session.get_positions(category="linear", symbol=symbol)
            if pos_resp.get("retCode") != 0:
                return {"success": False, "error": pos_resp.get("retMsg", "Falha ao obter posições atuais")}
            pos_items = (pos_resp.get("result", {}) or {}).get("list", []) or []
            pos_open = [p for p in pos_items if float(p.get("size") or 0) > 0]

            if not pos_open:
                logger.warning(f"[bybit_service] close_partial: nenhuma posição aberta em {symbol}. Nada a fechar.")
                return {"success": True, "skipped": True, "reason": "no_open_position"}

            # Se houver mais de uma (hedge com ambos os lados), priorizamos a primeira com size>0.
            p0 = pos_open[0]
            pos_side_api = (p0.get("side") or "").strip()  # "Buy" (LONG) ou "Sell" (SHORT)
            pos_idx_api = int(p0.get("positionIdx") or 0)

            # 1) Lado correto de fechamento é o CONTRÁRIO do lado da posição
            close_side = "Sell" if pos_side_api == "Buy" else "Buy"

            # 2) Ajuste de quantidade ao step e checagens mínimas
            qty_raw = Decimal(str(qty_to_close))
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])
            logger.info(
                f"[bybit_service] close_partial {symbol}: raw={qty_raw}, "
                f"step={instrument_rules['qtyStep']}, minQty={instrument_rules['minOrderQty']} => adj={qty_adj}"
            )
            if qty_adj < instrument_rules["minOrderQty"]:
                logger.warning(f"Quantidade a fechar para {symbol} ({qty_adj:f}) < mínimo permitido. Ignorando.")
                return {"success": True, "skipped": True, "reason": "qty_less_than_min_order_qty"}

            # 3) Resolve modo e índice de posição
            #    - One-Way: omitir positionIdx
            #    - Hedge: usar idx do lado da POSIÇÃO (não do lado da ordem)
            resolve = _resolve_position_index(session, symbol, close_side)
            mode = resolve.get("mode", "unknown")
            auto_idx = resolve.get("positionIdx", None)

            # Se hedge e o resolver não retornou idx, usar o índice da posição real
            if mode == "hedge":
                if auto_idx is None:
                    if pos_idx_api in (1, 2):
                        auto_idx = pos_idx_api
                    else:
                        # fallback por mapeamento do lado da POSIÇÃO
                        auto_idx = 1 if pos_side_api == "Buy" else 2
            else:
                # one-way: não enviar positionIdx
                auto_idx = None

            logger.info(
                f"[bybit_service] resolver: symbol={symbol}, mode={mode}, "
                f"pos_side_api={pos_side_api}, close_side={close_side}, "
                f"auto_idx={auto_idx}, pos_idx_api={pos_idx_api}, details={resolve.get('details')}"
            )

            # 4) Monta payload base
            payload = {
                "category": "linear",
                "symbol": symbol,
                "side": close_side,
                "orderType": "Market",
                "qty": str(qty_adj),
                "reduceOnly": True,
            }
            if auto_idx is not None:
                payload["positionIdx"] = auto_idx  # em hedge, vincula ao lado da posição aberta

            def _try_place(p):
                _safe_log_order_payload("close_partial:first_try", p)
                return session.place_order(**p)

            # 5) Primeira tentativa
            try:
                response = _try_place(payload)
                if response.get('retCode') == 0:
                    return {"success": True, "data": response['result']}
                msg = response.get('retMsg', '') or ''
                # 110017: reduce-only com mesmo lado da posição (corrida entre leitura e envio)
                if "reduce-only order has same side" in msg.lower() or "110017" in msg:
                    raise InvalidRequestError(msg)
                # 10001: idx/mode mismatch
                if "position idx not match" in msg.lower() or "10001" in msg:
                    raise InvalidRequestError(msg)
                return {"success": False, "error": msg}

            except InvalidRequestError as e:
                text = str(e).lower()
                alt_payload = dict(payload)
                alt_strategy = None

                if "reduce-only order has same side" in text or "110017" in text:
                    # Defensive: posição pode ter virado entre leitura e envio → inverter lado e ajustar idx
                    alt_payload["side"] = "Buy" if payload["side"] == "Sell" else "Sell"
                    if "positionIdx" in alt_payload:
                        # idx deve permanecer atrelado ao lado da POSIÇÃO alvo (flip de ordem não muda qual posição queremos reduzir)
                        # portanto, se flipou a ordem, manter o idx original (da posição aberta)
                        alt_payload["positionIdx"] = payload.get("positionIdx", pos_idx_api or (1 if pos_side_api == "Buy" else 2))
                    alt_strategy = f"flip_side_{payload['side']}_to_{alt_payload['side']}"
                    logger.warning(f"[bybit_service] 110017 detectado para {symbol}. Retry: {alt_strategy}")

                elif "position idx not match" in text or "10001" in text:
                    # Alternar presença do idx
                    if "positionIdx" in alt_payload:
                        alt_payload.pop("positionIdx", None)
                        alt_strategy = "remove_positionIdx"
                    else:
                        # em hedge, forçar idx coerente com a POSIÇÃO
                        alt_payload["positionIdx"] = pos_idx_api if pos_idx_api in (1, 2) else (1 if pos_side_api == "Buy" else 2)
                        alt_strategy = f"force_positionIdx_{alt_payload['positionIdx']}"
                    logger.warning(f"[bybit_service] 10001 detectado para {symbol}. Retry com '{alt_strategy}'.")

                else:
                    return {"success": False, "error": str(e)}

                try:
                    _safe_log_order_payload("close_partial:retry", alt_payload)
                    resp2 = session.place_order(**alt_payload)
                    if resp2.get('retCode') == 0:
                        logger.info(f"[bybit_service] retry sucesso para {symbol} com estratégia '{alt_strategy}'.")
                        return {
                            "success": True,
                            "data": resp2['result'],
                            "retry": True,
                            "retry_strategy": alt_strategy
                        }
                    return {
                        "success": False,
                        "error": resp2.get('retMsg', 'Falha no retry'),
                        "retry": True,
                        "retry_strategy": alt_strategy
                    }
                except InvalidRequestError as e2:
                    return {"success": False, "error": str(e2), "retry": True, "retry_strategy": alt_strategy}

        except Exception as e:
            logger.error(f"Exceção ao fechar posição parcial: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"Exceção em close_partial_position (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}

async def modify_position_stop_loss(
    api_key: str,
    api_secret: str,
    symbol: str,
    new_stop_loss: float,
    reason: Optional[str] = None  # "be" | "ts" | "lock" | None
) -> dict:
    """
    Modifica o Stop Loss com:
      - Arredondamento no tick (down p/ LONG, up p/ SHORT)
      - Folga mínima de N ticks vs lastPrice (TF_SAFETY_TICKS, default 2)
      - Retry inteligente para retCode 10001: até 3 tentativas (0.2s, 0.4s, 0.8s + jitter)
    Trata "not modified" como sucesso.
    """
    try:
        # --- 1) Regras do instrumento (tickSize) ---
        instrument_rules = await get_instrument_info(symbol)
        if not instrument_rules.get("success"):
            error_msg = instrument_rules.get("error", f"Regras do instrumento {symbol} não encontradas.")
            logger.error(f"Falha ao obter regras para {symbol} antes de modificar SL: {error_msg}")
            return {"success": False, "error": error_msg}

        tick_size = instrument_rules.get("tickSize", Decimal("0"))
        if tick_size <= 0:
            return {"success": False, "error": f"tickSize inválido para {symbol}."}

        # --- 2) Safety ticks do ambiente (default 2) ---
        try:
            safety_ticks = int(os.getenv("TF_SAFETY_TICKS", "2"))
        except Exception:
            safety_ticks = 2
        if safety_ticks < 0:
            safety_ticks = 0

        desired_sl = Decimal(str(new_stop_loss))

        # --- 3) Tentativas com backoff ---
        backoffs = [0.0, 0.2, 0.4, 0.8]  # primeira sem espera
        last_error = None
        last_telemetry = {}

        for attempt, delay in enumerate(backoffs, start=1):
            if delay > 0:
                await asyncio.sleep(delay + random.uniform(0.0, 0.05))

            def _sync_attempt():
                try:
                    session = get_session(api_key, api_secret)

                    # 3.1 Descobre lado da posição (Buy/Sell) p/ este símbolo
                    pos_resp = session.get_positions(category="linear", symbol=symbol)
                    pos_list = (pos_resp.get("result", {}) or {}).get("list", []) or []
                    pos = next((p for p in pos_list if float(p.get("size") or 0) > 0), pos_list[0] if pos_list else None)
                    side_api = (pos.get("side") if pos else None) or "Buy"
                    side_norm = "LONG" if side_api == "Buy" else "SHORT"

                    # 3.2 Busca lastPrice mais recente
                    t = session.get_tickers(category="linear", symbol=symbol)
                    lst = (t.get("result", {}) or {}).get("list", [])
                    if not lst:
                        return {"ok": False, "error": "Ticker vazio.", "attempt": attempt}
                    last_price = Decimal(str(lst[0].get("lastPrice")))

                    # 3.3 Arredonda ao tick conforme lado
                    if side_norm == "LONG":
                        rounded = _round_down_to_tick(desired_sl, tick_size)
                    else:
                        rounded = _round_up_to_tick(desired_sl, tick_size)

                    # 3.4 Aplica folga mínima de N ticks vs lastPrice
                    adjusted = _apply_safety_ticks(side_norm, rounded, last_price, tick_size, safety_ticks)

                    logger.info(
                        "[sl:set] symbol=%s attempt=%d reason=%s side=%s original=%s rounded=%s last=%s ticks=%d adjusted=%s",
                        symbol, attempt, (reason or "n/a"), side_api, str(desired_sl), str(rounded), str(last_price), safety_ticks, str(adjusted)
                    )

                    # 3.5 Envia para a Bybit
                    payload = {"category": "linear", "symbol": symbol, "stopLoss": str(adjusted)}
                    resp = session.set_trading_stop(**payload)

                    if resp.get("retCode") == 0:
                        return {"ok": True, "data": resp.get("result"), "attempt": attempt}

                    # Falha: empacota info p/ decisão de retry fora da thread
                    return {
                        "ok": False,
                        "error": resp.get("retMsg"),
                        "retCode": resp.get("retCode"),
                        "attempt": attempt,
                        "telemetry": {
                            "last": str(last_price),
                            "desired": str(desired_sl),
                            "rounded": str(rounded),
                            "adjusted": str(adjusted),
                            "ticks": safety_ticks,
                            "side": side_api
                        }
                    }

                except InvalidRequestError as e:
                    msg = str(e)
                    # Bybit usa 10001 e mensagens “should lower/higher than base_price”
                    rc = 10001 if "10001" in msg else None
                    return {
                        "ok": False,
                        "error": msg,
                        "retCode": rc,
                        "attempt": attempt,
                    }
                except Exception as e:
                    logger.error("Exceção em modify_position_stop_loss (attempt=%d): %s", attempt, e, exc_info=True)
                    return {"ok": False, "error": str(e), "attempt": attempt}

            result = await asyncio.to_thread(_sync_attempt)

            # Sucesso?
            if result.get("ok"):
                return {"success": True, "data": result.get("data"), "attempt": result.get("attempt")}

            # Falha: decide se reintenta
            last_error = result.get("error")
            last_telemetry = result.get("telemetry", {})

            # Tratar "not modified" como sucesso silencioso
            if last_error and "not modified" in last_error.lower():
                logger.info("[sl:set] symbol=%s attempt=%d reason=%s already-in-place -> success",
                            symbol, result.get("attempt"), (reason or "n/a"))
                return {"success": True, "data": {"note": "not modified"}, "attempt": result.get("attempt")}

            # Só reintenta em 10001 / mensagens de base price
            retryable = False
            rc = result.get("retCode")
            if rc == 10001:
                retryable = True
            elif last_error:
                le = last_error.lower()
                if ("base price" in le) or ("should lower than base_price" in le) or ("should higher than base_price" in le):
                    retryable = True

            if retryable and attempt < len(backoffs):
                logger.warning("[sl:retry] symbol=%s attempt=%d reason=%s err=%s", symbol, result.get("attempt"), (reason or "n/a"), last_error)
                continue
            else:
                break  # não-retryable ou esgotou tentativas

        # Esgotou tentativas / falha não-retryable
        logger.error("[sl:failed] symbol=%s reason=%s err=%s telemetry=%s",
                     symbol, (reason or "n/a"), last_error, last_telemetry)
        return {"success": False, "error": last_error or "unknown error", "telemetry": last_telemetry}

    except Exception as e:
        logger.error(f"Exceção na lógica de modificar Stop Loss para {symbol}: {e}", exc_info=True)
        return {"success": False, "error": str(e)}

async def get_open_positions(api_key: str, api_secret: str) -> dict:
    return await get_open_positions_with_pnl(api_key, api_secret)

async def get_pnl_for_period(api_key: str, api_secret: str, start_time: datetime, end_time: datetime) -> dict:
    """Busca o P/L (Lucro/Prejuízo) realizado para um período de tempo específico."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            
            start_timestamp_ms = int(start_time.timestamp() * 1000)
            end_timestamp_ms = int(end_time.timestamp() * 1000)

            response = session.get_closed_pnl(
                category="linear",
                startTime=start_timestamp_ms,
                endTime=end_timestamp_ms,
                limit=200 # Aumentar o limite para buscar mais trades em períodos longos
            )

            if response.get('retCode') == 0:
                pnl_list = response.get('result', {}).get('list', [])
                total_pnl = sum(float(item.get('closedPnl', 0)) for item in pnl_list)
                return {"success": True, "pnl": total_pnl}
            else:
                error_msg = response.get('retMsg', 'Erro desconhecido ao buscar P/L.')
                logger.error(f"Erro da API Bybit ao buscar P/L: {error_msg}")
                return {"success": False, "error": error_msg}

        except Exception as e:
            logger.error(f"Exceção em get_pnl_for_period: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


async def get_daily_pnl(api_key: str, api_secret: str) -> dict:
    """Busca o P/L realizado para o dia atual (agora usa a função genérica)."""
    today_start = datetime.combine(datetime.today(), time.min)
    now = datetime.now()
    return await get_pnl_for_period(api_key, api_secret, today_start, now)


# --- FUNÇÃO PARA ENVIAR ORDEM LIMITE ---
async def place_limit_order(api_key: str, api_secret: str, signal_data: dict, user_settings: User, balance: float) -> dict:
    """Envia uma nova ordem limite para a Bybit com validação completa."""
    async def pre_flight_checks():
        symbol = signal_data['coin']
        if symbol not in INSTRUMENT_INFO_CACHE:
            await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            symbol = signal_data['coin']
            
            if not instrument_rules or not instrument_rules.get("success"):
                return instrument_rules or {"success": False, "error": f"Regras para {symbol} não encontradas."}
            if instrument_rules["status"] != "Trading":
                return {"success": False, "error": f"O símbolo {symbol} não está ativo para negociação ({instrument_rules['status']})."}

            session = get_session(api_key, api_secret)
            side = "Buy" if (signal_data.get('order_type') or '').upper() == 'LONG' else "Sell"
            leverage = Decimal(str(user_settings.max_leverage))
            tick = instrument_rules["tickSize"]

            price = Decimal(str(signal_data.get('limit_price')))
            price_adj = _round_down_to_tick(price, tick)

            margin_in_dollars = Decimal(str(balance)) * (Decimal(str(user_settings.entry_size_percent)) / Decimal("100"))
            notional_value = margin_in_dollars * leverage

            if price_adj <= 0:
                return {"success": False, "error": f"Preço de entrada inválido após ajuste: {price_adj}"}
            
            qty_raw = notional_value / price_adj
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])
            
            if qty_adj < instrument_rules["minOrderQty"]:
                return {"success": False, "error": f"Qtd. ajustada ({qty_adj:f}) é menor que a mínima permitida ({instrument_rules['minOrderQty']:f}) para {symbol}."}
            final_notional_value = qty_adj * price_adj
            if final_notional_value < instrument_rules["minNotionalValue"]:
                return {"success": False, "error": f"Valor total da ordem (${final_notional_value:.2f}) é menor que o mínimo permitido de ${instrument_rules['minNotionalValue']:.2f}."}

            # --- Ajuste de TP/SL ao tick do instrumento ---
            tp_raw = (signal_data.get('targets') or [None])[0]
            sl_raw = signal_data.get('stop_loss')

            take_profit_adj = None
            if tp_raw is not None:
                take_profit_adj = _round_down_to_tick(Decimal(str(tp_raw)), tick)

            stop_loss_adj = None
            if sl_raw is not None:
                stop_loss_adj = _round_down_to_tick(Decimal(str(sl_raw)), tick)

            payload = {
                "category": "linear", "symbol": symbol, "side": side,
                "orderType": "Limit", "qty": str(qty_adj), "price": str(price_adj),
                "takeProfit": str(take_profit_adj) if take_profit_adj is not None else None,
                "stopLoss": str(stop_loss_adj) if stop_loss_adj is not None else None,
            }

            try:
                session.set_leverage(category="linear", symbol=symbol, buyLeverage=str(leverage), sellLeverage=str(leverage))
            except InvalidRequestError as e:
                if "leverage not modified" in str(e).lower():
                    logger.warning(f"Alavancagem para {symbol} já está correta. Continuando...")
                else:
                    return {"success": False, "error": str(e)}

            _safe_log_order_payload("place_limit_order:first_try", payload)
            response = session.place_order(**{k: v for k, v in payload.items() if v is not None})
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            return {"success": False, "error": response.get('retMsg')}

        except Exception as e:
            logger.error(f"Exceção ao abrir ordem (Limit): {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"Exceção em place_limit_order (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}

# --- FUNÇÃO PARA VERIFICAR STATUS DE UMA ORDEM ---
async def get_order_status(api_key: str, api_secret: str, order_id: str, symbol: str) -> dict:
    """Verifica o status de uma ordem específica na Bybit, procurando em ordens abertas."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            # --- CORREÇÃO: MUDAMOS PARA get_open_orders ---
            response = session.get_open_orders(
                category="linear",
                symbol=symbol,
                orderId=order_id,
            )
            if response.get('retCode') == 0:
                order_list = response.get('result', {}).get('list', [])
                if order_list:
                    # A ordem foi encontrada na lista de ordens abertas
                    return {"success": True, "data": order_list[0]}
                else:
                    # Se não está nas ordens abertas, pode já ter sido executada ou cancelada.
                    # Por segurança, vamos verificar o histórico também.
                    hist_response = session.get_order_history(category="linear", orderId=order_id)
                    if hist_response.get('retCode') == 0:
                        hist_list = hist_response.get('result', {}).get('list', [])
                        if hist_list:
                            return {"success": True, "data": hist_list[0]}
                    
                    return {"success": False, "error": "Ordem não encontrada nem nas abertas nem no histórico."}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"Exceção ao verificar status da ordem: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)


# --- FUNÇÃO PARA CANCELAR UMA ORDEM ---
async def cancel_order(api_key: str, api_secret: str, order_id: str, symbol: str) -> dict:
    """Cancela uma ordem limite pendente na Bybit."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.cancel_order(
                category="linear",
                symbol=symbol,
                orderId=order_id
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"Exceção ao cancelar ordem: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

# --- PNL FECHADO (PERFORMANCE) ---
async def get_closed_pnl_breakdown(api_key: str, api_secret: str, start_time: datetime, end_time: datetime) -> dict:
    """
    Retorna o P/L total e contagem de ganhos/perdas no período informado.
    Usa o endpoint oficial de closed PnL e pagina os resultados se o período for > 7 dias.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)

            total_pnl = 0.0
            total_wins = 0
            total_losses = 0
            all_items = []

            current_start = start_time

            while current_start < end_time:
                # Calcula o fim da janela atual, limitado a 7 dias ou ao fim do período total
                current_end = min(current_start + timedelta(days=7), end_time)

                logger.info(f"[bybit_service] Buscando PnL de {current_start.strftime('%Y-%m-%d')} a {current_end.strftime('%Y-%m-%d')}")

                resp = session.get_closed_pnl(
                    category="linear",
                    startTime=int(current_start.timestamp() * 1000),
                    endTime=int(current_end.timestamp() * 1000),
                    limit=200,
                )

                if resp.get("retCode") != 0:
                    error_msg = resp.get("retMsg", f"Erro desconhecido na paginação de PnL (start={current_start})")
                    logger.error(f"Erro da API Bybit em get_closed_pnl_breakdown: {error_msg}")
                    # Retorna o erro da primeira falha
                    return {"success": False, "error": error_msg}

                items = resp.get("result", {}).get("list", []) or []
                all_items.extend(items)

                # Avança o início da próxima janela
                current_start += timedelta(days=7)

            # Processa a lista completa de itens coletados
            for it in all_items:
                pnl = float(it.get("closedPnl", 0) or 0)
                total_pnl += pnl
                if pnl > 0:
                    total_wins += 1
                elif pnl < 0:
                    total_losses += 1

            return {
                "success": True,
                "total_pnl": total_pnl,
                "wins": total_wins,
                "losses": total_losses,
                "trades": len(all_items),
            }
        except Exception as e:
            logger.error(f"Exceção em get_closed_pnl_breakdown: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


# --- POSIÇÕES ABERTAS COM PNL ATUAL ---
async def get_open_positions_with_pnl(api_key: str, api_secret: str) -> dict:
    """
    Lista posições abertas com avgPrice, markPrice e P/L atual (valor e fração),
    deduplicando por (symbol, side, positionIdx). Se houver duplicatas, mantém a de maior size.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            resp = session.get_positions(category="linear", settleCoin="USDT")
            if resp.get("retCode") != 0:
                return {"success": False, "error": resp.get("retMsg", "erro")}

            seen = {}  # key: (symbol, side, positionIdx) -> item
            positions = (resp.get("result", {}).get("list", []) or [])
            for pos in positions:
                size = float(pos.get("size", 0) or 0)
                if size <= 0:
                    continue

                symbol = pos.get("symbol")
                pos_side_api = (pos.get("side") or "").strip()  # "Buy" | "Sell"
                side = "LONG" if pos_side_api == "Buy" else "SHORT"
                entry = float(pos.get("avgPrice", 0) or 0)
                mark = float((pos.get("markPrice") or 0) or 0)
                pos_idx = int(pos.get("positionIdx", 0))
                key = (symbol, side, pos_idx)

                # Fallback de preço se mark vier 0
                if not mark and symbol:
                    try:
                        t = session.get_tickers(category="linear", symbol=symbol)
                        mark = float(t["result"]["list"][0]["lastPrice"])
                    except Exception:
                        pass

                if entry > 0 and mark > 0:
                    diff = (mark - entry) if side == "LONG" else (entry - mark)
                    pnl = diff * size
                    pnl_frac = (diff / entry) if entry else 0.0  # fração (ex.: 0.015 = 1.5%)
                else:
                    pnl = 0.0
                    pnl_frac = 0.0

                item = {
                    "symbol": symbol,
                    "side": side,
                    "size": size,
                    "entry": entry,
                    "mark": mark,
                    "unrealized_pnl": pnl,
                    "unrealized_pnl_frac": pnl_frac,  # padronizado em FRAÇÃO
                    "position_idx": pos_idx,
                }

                if key in seen:
                    # mantém a maior posição e loga para auditoria
                    if size > float(seen[key]["size"]):
                        logger.info(
                            "[positions:dedupe:replace] key=%s old_size=%.8f new_size=%.8f",
                            key, float(seen[key]["size"]), size
                        )
                        seen[key] = item
                    else:
                        logger.info(
                            "[positions:dedupe:skip] key=%s keep_size=%.8f skip_size=%.8f",
                            key, float(seen[key]["size"]), size
                        )
                else:
                    seen[key] = item

            out = list(seen.values())
            return {"success": True, "data": out}
        except Exception as e:
            logger.error(f"Exceção em get_open_positions_with_pnl: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)

async def get_specific_position_size(api_key: str, api_secret: str, symbol: str) -> float:
    """
    Busca o tamanho (size) de uma posição específica aberta na Bybit.
    Retorna sempre um float (0.0 em caso de inexistência ou erro).
    """
    def _sync_call() -> float:
        try:
            session = get_session(api_key, api_secret)
            response = session.get_positions(category="linear", symbol=symbol)

            if response.get('retCode') == 0:
                position_list = (response.get('result', {}) or {}).get('list', []) or []
                if position_list and position_list[0]:
                    # Retorna o tamanho da primeira posição na lista (mantém comportamento atual)
                    size_val = float(position_list[0].get('size', 0.0) or 0.0)
                    return size_val
                # Lista vazia: posição não existe
                return 0.0

            # retCode != 0: loga e retorna 0.0
            logger.warning(f"get_specific_position_size: Bybit retornou retCode={response.get('retCode')} para {symbol} - {response.get('retMsg')}")
            return 0.0

        except Exception as e:
            logger.error(f"Exceção em get_specific_position_size para {symbol}: {e}", exc_info=True)
            # Nunca retorne None: padroniza para 0.0
            return 0.0

    return await asyncio.to_thread(_sync_call)

    
async def get_order_history(api_key: str, api_secret: str, order_id: str) -> dict:
    """Busca os detalhes de uma ordem específica no histórico."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.get_order_history(category="linear", orderId=order_id, limit=1)
            
            if response.get('retCode') == 0:
                order_list = response.get('result', {}).get('list', [])
                if order_list:
                    return {"success": True, "data": order_list[0]}
                return {"success": False, "error": "Ordem não encontrada no histórico."}
            return {"success": False, "error": response.get('retMsg')}
        
        except Exception as e:
            logger.error(f"Exceção em get_order_history: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)

async def modify_position_take_profit(api_key: str, api_secret: str, symbol: str, new_take_profit: float) -> dict:
    """Modifica o Take Profit de uma posição aberta, garantindo a precisão do preço (tick size)."""
    try:
        # Busca regras/tick do instrumento (com cache)
        instrument_rules = await get_instrument_info(symbol)
        if not instrument_rules.get("success"):
            error_msg = instrument_rules.get("error", f"Regras do instrumento {symbol} não encontradas.")
            logger.error(f"Falha ao obter regras para {symbol} antes de modificar TP: {error_msg}")
            return {"success": False, "error": error_msg}

        tick_size = instrument_rules.get("tickSize", Decimal("0"))
        tp_price_decimal = Decimal(str(new_take_profit))
        rounded_tp_price = _round_down_to_tick(tp_price_decimal, tick_size)

        logger.info(f"Modificando TP para {symbol}: Original: {tp_price_decimal}, Arredondado ({tick_size}): {rounded_tp_price}")

        def _sync_call():
            try:
                session = get_session(api_key, api_secret)
                payload = {"category": "linear", "symbol": symbol, "takeProfit": str(rounded_tp_price)}
                _safe_log_order_payload("modify_tp", payload)
                response = session.set_trading_stop(**payload)
                if response.get('retCode') == 0:
                    return {"success": True, "data": response['result']}
                return {"success": False, "error": response.get('retMsg')}
            except InvalidRequestError as e:
                if "not modified" in str(e).lower():
                    logger.info(f"TP para {symbol} já está em {rounded_tp_price}. Tratando como sucesso.")
                    return {"success": True, "data": {"note": "not modified"}}
                raise e

        return await asyncio.to_thread(_sync_call)

    except Exception as e:
        logger.error(f"Exceção na lógica de modificar Take Profit para {symbol}: {e}", exc_info=True)
        return {"success": False, "error": str(e)}

async def get_last_closed_trade_info(api_key: str, api_secret: str, symbol: str) -> dict:
    """
    Função "Detetive" aprimorada: cruza dados de PnL e histórico de ordens
    para determinar com mais precisão o resultado de um trade que já fechou.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            end_time = datetime.now()
            start_time = end_time - timedelta(hours=2) # Aumenta a janela para 2h por segurança
            
            # 1. Busca o PnL fechado mais recente para obter o PnL e o ID da ordem de fechamento
            pnl_response = session.get_closed_pnl(
                category="linear",
                symbol=symbol,
                startTime=int(start_time.timestamp() * 1000),
                endTime=int(end_time.timestamp() * 1000),
                limit=1
            )

            if pnl_response.get('retCode') != 0 or not pnl_response.get('result', {}).get('list'):
                return {"success": False, "error": "Nenhum PnL fechado encontrado para o símbolo recentemente."}
            
            pnl_data = pnl_response['result']['list'][0]
            closing_order_id = pnl_data.get('orderId')
            
            # Prepara o resultado final com os dados do PnL
            final_data = {
                "closedPnl": pnl_data.get('closedPnl', 0.0),
                "exitType": "Unknown" # Começa com 'Unknown' como fallback
            }

            if not closing_order_id:
                logger.warning(f"Detetive: PnL encontrado para {symbol}, mas sem orderId. Retornando 'Unknown'.")
                return {"success": True, "data": final_data}

            # 2. Busca os detalhes da ordem de fechamento para obter o motivo real
            order_hist_response = session.get_order_history(
                category="linear",
                orderId=closing_order_id
            )

            if order_hist_response.get('retCode') == 0 and order_hist_response.get('result', {}).get('list'):
                order_data = order_hist_response['result']['list'][0]
                stop_order_type = order_data.get('stopOrderType', '').strip()

                if stop_order_type == 'TakeProfit':
                    final_data['exitType'] = 'TakeProfit'
                elif stop_order_type == 'StopLoss':
                    final_data['exitType'] = 'StopLoss'
                # Outros tipos de ordens (como fechamento manual via ordem a mercado) não terão stopOrderType.
                # Nesses casos, o fallback 'Unknown' será mantido, o que é o comportamento esperado.
            
            return {"success": True, "data": final_data}

        except Exception as e:
            logger.error(f"Exceção em get_last_closed_trade_info: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)

async def get_historical_klines(symbol: str, interval: str, limit: int = 200) -> dict:
    """
    Busca os dados históricos de k-lines (candles) para um símbolo.
    
    Args:
        symbol: O par de moedas (ex: 'BTCUSDT').
        interval: O tempo gráfico do candle ('60' para 1h, '240' para 4h, 'D' para diário).
        limit: O número de candles a serem buscados (máx 1000, padrão 200).

    Returns:
        Um dicionário com a lista de k-lines ou um erro.
        O formato dos dados é uma lista de listas:
        [startTime, openPrice, highPrice, lowPrice, closePrice, volume, turnover]
    """
    def _sync_call():
        try:
            # Para dados públicos de mercado, não é necessário autenticar com chaves de API
            session = HTTP(testnet=False, timeout=15)
            response = session.get_kline(
                category="linear",
                symbol=symbol,
                interval=interval,
                limit=limit
            )
            
            if response.get('retCode') == 0 and response.get('result', {}).get('list'):
                kline_data = response['result']['list']
                # Os dados vêm com o candle mais recente no final, vamos inverter
                # para que o mais recente fique na primeira posição.
                kline_data.reverse()
                return {"success": True, "data": kline_data}
            else:
                error_msg = response.get('retMsg', f"Não foi possível obter os k-lines para {symbol}.")
                logger.warning(f"[bybit_service] Falha ao buscar k-lines para {symbol} (intervalo {interval}): {error_msg}")
                return {"success": False, "error": error_msg}
        except Exception as e:
            logger.error(f"Exceção em get_historical_klines para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)

def _safe_log_order_payload(context: str, payload: Dict[str, Any]) -> None:
    """
    Loga, de forma segura, os campos relevantes de um payload de ordem.
    Não loga credenciais nem headers. Apenas dados não sensíveis.
    """
    try:
        preview = {
            "category": payload.get("category"),
            "symbol": payload.get("symbol"),
            "side": payload.get("side"),
            "orderType": payload.get("orderType"),
            "qty": payload.get("qty"),
            "price": payload.get("price", "omitted"),
            "takeProfit": payload.get("takeProfit", "omitted"),
            "stopLoss": payload.get("stopLoss", "omitted"),
            "reduceOnly": payload.get("reduceOnly", False),
            "positionIdx": payload.get("positionIdx", "omitted"),
        }
        logger.info(f"[order_payload:{context}] {preview}")
    except Exception as e:
        logger.warning(f"[order_payload:{context}] falha ao logar preview: {e}")


========================================
# Arquivo: services/currency_service.py
========================================

import logging
import aiohttp
from typing import Optional

logger = logging.getLogger(__name__)

async def get_usd_to_brl_rate() -> Optional[float]:
    """
    Busca a taxa de conversão de USD para BRL de uma API pública.
    Retorna a taxa como float ou None em caso de falha.
    """
    # Usamos uma API simples e gratuita que não requer chave.
    url = "https://api.exchangerate-api.com/v4/latest/USD"
    
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=5) as response:
                if response.status == 200:
                    data = await response.json()
                    rate = data.get("rates", {}).get("BRL")
                    if rate:
                        logger.info(f"Taxa de conversão USD-BRL obtida: {rate}")
                        return float(rate)
                    else:
                        logger.warning("Campo 'BRL' não encontrado na resposta da API de cotação.")
                        return None
                else:
                    logger.error(f"Falha ao buscar cotação BRL. Status: {response.status}")
                    return None
    except Exception as e:
        logger.error(f"Exceção ao buscar cotação BRL: {e}", exc_info=True)
        return None

========================================
# Arquivo: services/notification_service.py
========================================

import logging
from telegram.ext import Application
from utils.config import ADMIN_ID

logger = logging.getLogger(__name__)

async def send_notification(application: Application, message: str):
    """
    Envia uma mensagem de notificação para o administrador do bot.
    """
    if not application:
        logger.warning("Tentativa de enviar notificação sem a instância da aplicação.")
        return
    try:
        await application.bot.send_message(
            chat_id=ADMIN_ID,
            text=message,
            parse_mode='HTML'
        )
        logger.info(f"Notificação enviada para o admin: {message[:50]}...")
    except Exception as e:
        logger.error(f"Falha ao enviar notificação para o admin: {e}")

========================================
# Arquivo: services/signal_parser.py
========================================

import re
import logging
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)

# --- DEFINIÇÃO CENTRALIZADA DOS TIPOS DE SINAL ---
class SignalType:
    MARKET = 'MARKET'
    LIMIT = 'LIMIT'
    CANCELAR = 'CANCELAR'


# -----------------------
# Helpers de normalização
# -----------------------
_FLOAT = r'[-+]?\d+(?:[.,]\d+)?'

def _to_float(x: str) -> float:
    """Converte string com vírgula ou ponto para float."""
    if x is None:
        return 0.0
    x = x.strip().replace(' ', '').replace(',', '.')
    # remove percentuais e símbolos residuais
    x = re.sub(r'[^0-9.+-]', '', x)
    try:
        return float(x)
    except Exception:
        return 0.0

def _normalize_symbol(coin_raw: str) -> str:
    coin = (coin_raw or '').strip().upper()
    # remove emojis e lixo
    coin = re.sub(r'[^A-Z0-9]', '', coin)
    # alguns sinais usam par completo (ex.: AVAXUSDT)
    if coin.endswith('USDT') or coin.endswith('USD'):
        return coin if coin.endswith('USDT') else f'{coin}T'  # USD -> USDT (fail-safe)
    return f'{coin}USDT' if coin else coin

def _pick_first_number(text: str) -> Optional[float]:
    m = re.search(_FLOAT, text)
    return _to_float(m.group(0)) if m else None

def _findall_numbers(text: str) -> List[float]:
    return [_to_float(g) for g in re.findall(_FLOAT, text or '')]


# ----------------------------------------------------
# Padrões de alto nível (ordem importa: específicos 1º)
# ----------------------------------------------------
CANCEL_PATTERN = re.compile(r'⚠️\s*([A-Za-z0-9]+)[^\n]*sinal\s*cancelad[oa]', re.IGNORECASE)

# “Ordem Limite” / “Ordem a/à Mercado” podem aparecer em qualquer lugar
IS_MARKET_PATTERN = re.compile(r'Ordem\s*(?:à|a)?\s*Mercado', re.IGNORECASE)
IS_LIMIT_PATTERN  = re.compile(r'Ordem\s*Limite', re.IGNORECASE)

# Verificador de “sinal completo”
FULL_SIGNAL_GUARD = re.compile(r'(?=.*(?:Moeda|Coin|Pair)\s*:)(?=.*Tipo\s*:)(?=.*Stop\s*Loss\s*:)', re.IGNORECASE | re.DOTALL)


# ---------------------------
# Extrator de sinal “completo”
# ---------------------------
def _full_signal_extractor(message_text: str) -> Optional[Dict[str, Any]]:

    def find_single_value(pattern: str, text: str) -> Optional[str]:
        # Usa .*? para pular emojis e rótulos adicionais na linha
        m = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
        return m.group(1).strip() if m else None

    # --- Campos básicos ---
    coin_raw = find_single_value(r'(?:Moeda|Coin|Pair)\s*:\s*([A-Za-z0-9 ._-]+)', message_text)
    order_type_raw = find_single_value(r'Tipo\s*:\s*([A-Za-z ]+)', message_text)
    entry_raw = find_single_value(r'Zona\s*de\s*Entrada\s*:\s*([^\n\r]+)', message_text)
    sl_raw = find_single_value(r'Stop\s*Loss\s*:\s*([^\n\r]+)', message_text)

    # targets: T1:, T2:, ...
    targets = []
    for tlabel, val in re.findall(r'(?:^|\n)\s*T(\d+)\s*:\s*([^\n\r]+)', message_text, flags=re.IGNORECASE):
        n = _pick_first_number(val)
        if n is not None:
            targets.append(n)

    # confiança (se existir)
    conf_raw = find_single_value(r'Confian[çc]a\s*:\s*([0-9.,]+)\s*%', message_text)
    confidence = _to_float(conf_raw) if conf_raw else None

    # normalizações
    coin = _normalize_symbol(coin_raw or '')
    order_type = 'LONG'
    if order_type_raw:
        if 'SHORT' in order_type_raw.upper():
            order_type = 'SHORT'
        elif 'LONG' in order_type_raw.upper():
            order_type = 'LONG'

    # entradas
    entries: List[float] = []
    if entry_raw:
        nums = _findall_numbers(entry_raw)
        # muitos sinais colocam "x - y"; se só tem um número, trata como lista única
        if len(nums) == 1:
            entries = [nums[0]]
        elif len(nums) >= 2:
            entries = [nums[0], nums[1]]
        else:
            entries = []

    # stop
    stop_loss = _pick_first_number(sl_raw or '') or 0.0

    # --- Determinação do tipo (MARKET x LIMIT) ---
    # 1) texto explícito
    is_market_text = bool(IS_MARKET_PATTERN.search(message_text))
    is_limit_text  = bool(IS_LIMIT_PATTERN.search(message_text))

    # 2) heurística: “entrada única” OU faixa idêntica => MARKET
    entries_imply_market = False
    if entries:
        if len(entries) == 1:
            entries_imply_market = True
        elif len(entries) >= 2 and abs(entries[0] - entries[1]) < 1e-10:
            entries_imply_market = True

    # decisão final
    if is_market_text or (not is_limit_text and entries_imply_market):
        signal_kind = SignalType.MARKET
        # para MARKET garantimos entries[0] preenchida (usa o primeiro número visto no bloco de entrada)
        if not entries and entry_raw:
            n = _pick_first_number(entry_raw)
            entries = [n] if n is not None else []
    else:
        signal_kind = SignalType.LIMIT

    if not coin or not entries or stop_loss == 0.0:
        logger.debug("Parser: campos essenciais ausentes: coin=%s entries=%s stop=%s", coin, entries, stop_loss)
        return None

    return {
        "type": signal_kind,
        "coin": coin,
        "order_type": order_type,          # LONG | SHORT
        "entries": entries,                # [preço] ou [min, max]
        "stop_loss": stop_loss,
        "targets": targets,                # [t1, t2, ...]
        "confidence": confidence,          # opcional (float ou None)
    }


# -----------------
# Função de entrada
# -----------------
def parse_signal(message_text: str) -> Optional[Dict[str, Any]]:
    """
    Identifica e extrai sinais:
      - CANCELAMENTO: '⚠️ <COIN> ... sinal cancelad(o/a)'
      - ENTRADA COMPLETA: campos Moeda/Coin/Pair, Tipo, Stop Loss (com 'Ordem Limite' ou 'Ordem à Mercado')
    Retorna um dicionário com os campos normalizados ou None se não reconhecer.
    """
    if not message_text or not isinstance(message_text, str):
        return None

    text = message_text.strip()

    # 1) Cancelamento
    m_cancel = CANCEL_PATTERN.search(text)
    if m_cancel:
        coin = _normalize_symbol(m_cancel.group(1))
        return {"type": SignalType.CANCELAR, "coin": coin}

    # 2) Sinal de entrada (guarda)
    if not FULL_SIGNAL_GUARD.search(text):
        return None

    data = _full_signal_extractor(text)
    return data

========================================
# Arquivo: services/telethon_service.py
========================================

import logging
import asyncio
import os
import re
from telegram.ext import Application
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telethon.sync import TelegramClient
from telethon import events
from telethon.errors.rpcerrorlist import ChannelForumMissingError, ChannelInvalidError
from telethon.tl.functions.channels import GetForumTopicsRequest
from utils.config import API_ID, API_HASH
from database.session import SessionLocal
from database.models import MonitoredTarget
from .signal_parser import parse_signal

logger = logging.getLogger(__name__)

# --- LÓGICA DE CAMINHO DINÂMICO ---
if os.path.isdir('/data'):
    SESSION_PATH = '/data/tradeflow_user'
else:
    SESSION_PATH = 'tradeflow_user'

# --- DEFINIÇÃO ÚNICA E CORRETA DO CLIENTE ---
client = TelegramClient(SESSION_PATH, API_ID, API_HASH)
comm_queue = None
# Cache em memória para armazenar os IDs das mensagens já processadas e evitar duplicidade.
PROCESSED_MESSAGE_IDS = set()


# --- Funções de Busca (Helpers) ---

def get_monitored_targets():
    """Busca no DB a lista de todos os alvos (canal/tópico) monitorados."""
    db = SessionLocal()
    try:
        return db.query(MonitoredTarget).all()
    finally:
        db.close()

async def list_channels():
    """Lista todos os canais e supergrupos com logging detalhado."""
    logger.info("[list_channels] Iniciando busca de diálogos...")
    channels = []
    count = 0
    try:
        async for dialog in client.iter_dialogs():
            count += 1
            if count % 50 == 0:
                logger.info(f"[list_channels] ... processou {count} diálogos...")
            
            if dialog.is_channel:
                channels.append((dialog.name, dialog.id))
        
        logger.info(f"[list_channels] Busca de diálogos finalizada. Total de {count} diálogos processados.")
    except Exception as e:
        logger.error(f"[list_channels] Erro durante iter_dialogs: {e}", exc_info=True)
        
    return channels

async def list_channel_topics(channel_id: int):
    """Busca os tópicos de um canal específico."""
    topics = []
    try:
        entity = await client.get_entity(channel_id)
        result = await client(GetForumTopicsRequest(
            channel=entity, offset_date=0, offset_id=0, offset_topic=0, limit=100
        ))
        for topic in result.topics:
            topics.append((topic.title, topic.id))
            
    except (ChannelForumMissingError, ChannelInvalidError):
        logger.warning(f"Canal {channel_id} não possui tópicos (não é um fórum).")
        
    except Exception as e:
        logger.error(f"Exceção em list_channel_topics para o canal {channel_id}: {e}", exc_info=True)
        
    return topics

# --- Listener de Sinais ---
# Em vez de filtrar por regex no decorator, ouvimos TUDO e deixamos o parser decidir.
from telethon import events

@client.on(events.NewMessage)
@client.on(events.MessageEdited)
async def signal_listener(event):
    """
    Ouve TODAS as mensagens e processa APENAS as dos alvos monitorados.
    """
    global comm_queue
    if not comm_queue: return

    chat_id = getattr(event, "chat_id", None)
    message_id = getattr(getattr(event, "message", None), "id", None)
    topic_id = event.reply_to.reply_to_msg_id if getattr(event, "reply_to", None) else None
    text = (getattr(event, "raw_text", None) or getattr(getattr(event, "message", None), "message", None) or "")

    # 1. Primeiro, verifica se a mensagem é de um alvo monitorado
    monitored_targets = get_monitored_targets()
    is_target = any(
        (t.channel_id == chat_id and ((t.topic_id is None and topic_id is None) or t.topic_id == topic_id))
        for t in monitored_targets
    )

    # 2. Se não for um alvo, a função termina silenciosamente.
    if not is_target:
        return

    # --- LÓGICA DE LOG MOVIDA PARA CÁ ---
    # 3. Agora que sabemos que a mensagem é importante, nós a registramos.
    preview = text.replace("\n", " ")[:120]
    logger.info(f"📨 [Telethon] Mensagem RELEVANTE recebida | chat_id={chat_id} | msg_id={message_id} | preview={preview!r}")

    # O resto da lógica para evitar duplicidade e processar o sinal continua a mesma...
    if message_id in PROCESSED_MESSAGE_IDS:
        logger.info(f"⏭️ [Telethon] Mensagem {message_id} já processada. Ignorando.")
        return

    from services.signal_parser import parse_signal
    parsed = parse_signal(text)

    if parsed:
        logger.info(
            "✅ [Telethon] É sinal! "
            f"type={parsed.get('type')} coin={parsed.get('coin')} "
            f"order={parsed.get('order_type')} entries={parsed.get('entries')} sl={parsed.get('stop_loss')}"
        )
        if message_id is not None:
            PROCESSED_MESSAGE_IDS.add(message_id)

        await comm_queue.put({
            "action": "process_signal",
            "signal_text": text,
            "source_name": f"telegram:{chat_id}"
        })

# --- Processador da Fila ---

async def queue_processor(queue: asyncio.Queue, ptb_app: Application):
    """Processa pedidos da fila, agora passando o 'source_name' adiante."""
    global comm_queue
    comm_queue = queue
    from core.trade_manager import process_new_signal

    while True:
        request = await queue.get()
        action = request.get("action")
        logger.info(f"[Queue Processor] ==> Pedido recebido! Ação: '{action}'")
        
        try:
            if action == "list_channels":
                logger.info("[Queue Processor] ... Entrou no bloco de 'list_channels'.")
                chat_id = request.get("chat_id")
                message_id = request.get("message_id")
                channels = await list_channels()
                db = SessionLocal()
                monitored_channels_ids = {target.channel_id for target in db.query(MonitoredTarget).all()}
                db.close()
                keyboard = []
                
                if channels:
                    for channel_name, channel_id in channels:
                        suffix = " ✅" if channel_id in monitored_channels_ids else ""
                        keyboard.append([InlineKeyboardButton(f"{channel_name}{suffix}", callback_data=f"monitor_channel_{channel_id}")])
                
                if keyboard:
                    await ptb_app.bot.edit_message_text(
                        chat_id=chat_id, message_id=message_id,
                        text="Selecione um grupo/canal (✅ = algum monitoramento ativo):",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    await ptb_app.bot.edit_message_text(chat_id=chat_id, message_id=message_id, text="Nenhum canal ou supergrupo encontrado.")

            elif action == "list_topics":
                logger.info("[Queue Processor] ... Entrou no bloco de 'list_topics'.")
                channel_id = request.get("channel_id")
                chat_id = request.get("chat_id")
                message_id = request.get("message_id")
                channel_name = request.get("channel_name")
                
                topics = await list_channel_topics(channel_id)
                db = SessionLocal()
                
                try:
                    if topics:
                        monitored_topic_ids = {t.topic_id for t in db.query(MonitoredTarget).filter_by(channel_id=channel_id).all() if t.topic_id}
                        keyboard = [[InlineKeyboardButton("⬅️ Voltar para Grupos", callback_data="admin_list_channels")]]
                        for name, topic_id in topics:
                            suffix = " ✅" if topic_id in monitored_topic_ids else ""
                            keyboard.append([InlineKeyboardButton(f"{name}{suffix}", callback_data=f"monitor_topic_{channel_id}_{topic_id}")])
                        
                        await ptb_app.bot.edit_message_text(
                            chat_id=chat_id, message_id=message_id,
                            text="Selecione o tópico para monitorar (✅ = já monitorado):",
                            reply_markup=InlineKeyboardMarkup(keyboard)
                        )
                    else:
                        existing = db.query(MonitoredTarget).filter_by(channel_id=channel_id, topic_id=None).first()
                        if existing:
                            db.delete(existing)
                            feedback_msg = f"❌ Canal '{channel_name}' removido da lista de monitoramento."
                        else:
                            new_target = MonitoredTarget(channel_id=channel_id, channel_name=channel_name)
                            db.add(new_target)
                            feedback_msg = f"✅ Canal '{channel_name}' adicionado à lista de monitoramento."
                        
                        db.commit()
                        await ptb_app.bot.edit_message_text(chat_id=chat_id, message_id=message_id, text=feedback_msg)
                finally:
                    db.close()

            elif action == "process_signal":
                logger.info("[Queue Processor] ... Entrou no bloco de 'process_signal'.")
                signal_text = request.get("signal_text")
                source_name = request.get("source_name", "Fonte Desconhecida")
                
                signal_data = parse_signal(signal_text)
                if signal_data:
                    await process_new_signal(signal_data, ptb_app, source_name)
                else:
                    logger.info("Mensagem da fila não é um sinal válido.")
            
            else:
                logger.warning(f"[Queue Processor] Ação desconhecida ou nula recebida: '{action}'")

        except Exception as e:
            logger.error(f"Erro CRÍTICO no processador da fila ao manusear a ação '{action}': {e}", exc_info=True)
        finally:
            queue.task_done()
            logger.info(f"[Queue Processor] <== Pedido '{action}' finalizado.")

# --- Função Principal do Serviço ---

async def start_signal_monitor(queue: asyncio.Queue):
    """Inicia o cliente Telethon, o ouvinte de sinais e o processador da fila."""
    logger.info("Iniciando monitor de sinais com Telethon...")
    
    await client.start()
    
    ptb_app = await queue.get()

    logger.info("✅ Monitor de sinais e processador de fila ativos.")
    
    asyncio.create_task(queue_processor(queue, ptb_app))
    
    await client.run_until_disconnected()

