========================================
# Arquivo: Dockerfile
========================================

# Usa uma imagem oficial do Python como base
FROM python:3.11-slim

# Define o diretÃ³rio de trabalho dentro do container
WORKDIR /app

# Copia o arquivo de dependÃªncias primeiro
COPY requirements.txt .

# Instala as dependÃªncias do Python
RUN pip install --no-cache-dir -r requirements.txt

# Copia todo o resto do cÃ³digo do projeto
COPY . .

# Comando que serÃ¡ executado quando o container iniciar, usando o script simplificado
CMD ["./start.sh"]

========================================
# Arquivo: main.py
========================================

import logging
import asyncio
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, 
    ConversationHandler, CallbackQueryHandler
)
from utils.config import TELEGRAM_TOKEN
from bot.handlers import (
    start, receive_invite_code, cancel, WAITING_CODE,
    config_api, receive_api_key, receive_api_secret, WAITING_API_KEY, WAITING_API_SECRET,
    remove_api_prompt, remove_api_action, CONFIRM_REMOVE_API,
    my_positions_handler, user_dashboard_handler, user_settings_handler,
    back_to_main_menu_handler,
    ask_entry_percent, receive_entry_percent, ASKING_ENTRY_PERCENT,
    ask_max_leverage, receive_max_leverage, ASKING_MAX_LEVERAGE,
    ask_min_confidence, receive_min_confidence, ASKING_MIN_CONFIDENCE,
    admin_menu, list_channels_handler, select_channel_to_monitor, select_topic_to_monitor,
    admin_view_targets_handler, back_to_admin_menu_handler,
    bot_config_handler, toggle_approval_mode_handler, handle_signal_approval, 
    ask_profit_target, receive_profit_target, ASKING_PROFIT_TARGET,
    ask_loss_limit, receive_loss_limit, ASKING_LOSS_LIMIT, 
    ask_coin_whitelist, receive_coin_whitelist, ASKING_COIN_WHITELIST,
    performance_menu_handler, list_closed_trades_handler,
    prompt_manual_close_handler, execute_manual_close_handler
)
from database.session import init_db
from services.telethon_service import start_signal_monitor
from core.position_tracker import run_tracker

# --- ConfiguraÃ§Ã£o do Logging ---
logging.basicConfig(
    format="%(asctime)s - [%(levelname)s] - %(name)s - %(message)s",
    level=logging.INFO
)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("telegram").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)

async def run_ptb(application: Application, queue: asyncio.Queue):
    """Inicializa e roda a aplicaÃ§Ã£o python-telegram-bot."""
    application.bot_data['comm_queue'] = queue
    logger.info("Inicializando o bot do Telegram (PTB)...")
    await application.initialize()
    await application.start()
    await application.updater.start_polling()
    logger.info("âœ… Bot do Telegram (PTB) ativo.")

async def main():
    """Configura os handlers e inicia o PTB e o Telethon em paralelo."""
    init_db()
    comm_queue = asyncio.Queue()
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    await comm_queue.put(application)

    # --- Handlers de Conversa ---
    register_conv = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={ WAITING_CODE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_invite_code)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    api_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(config_api, pattern='^config_api$')],
        states={
            WAITING_API_KEY: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_api_key)],
            WAITING_API_SECRET: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_api_secret)],
        },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    remove_api_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(remove_api_prompt, pattern='^remove_api_prompt$')],
        states={ CONFIRM_REMOVE_API: [CallbackQueryHandler(remove_api_action, pattern='^remove_api_confirm|remove_api_cancel$')] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    settings_entry_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_entry_percent, pattern='^set_entry_percent$')],
        states={ ASKING_ENTRY_PERCENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_entry_percent)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    settings_leverage_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_max_leverage, pattern='^set_max_leverage$')],
        states={ ASKING_MAX_LEVERAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_max_leverage)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    settings_confidence_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_min_confidence, pattern='^set_min_confidence$')],
        states={ ASKING_MIN_CONFIDENCE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_min_confidence)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    profit_target_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_profit_target, pattern='^set_profit_target$')],
        states={ ASKING_PROFIT_TARGET: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_profit_target)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    loss_limit_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_loss_limit, pattern='^set_loss_limit$')],
        states={ ASKING_LOSS_LIMIT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_loss_limit)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    whitelist_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_coin_whitelist, pattern='^set_coin_whitelist$')],
        states={ ASKING_COIN_WHITELIST: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_coin_whitelist)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )

    # Adicionando todos os handlers
    application.add_handler(register_conv)
    application.add_handler(api_conv)
    application.add_handler(remove_api_conv)
    application.add_handler(settings_entry_conv)
    application.add_handler(settings_leverage_conv)
    application.add_handler(settings_confidence_conv)
    application.add_handler(profit_target_conv)
    application.add_handler(loss_limit_conv)
    application.add_handler(whitelist_conv)
    
    application.add_handler(CommandHandler("admin", admin_menu))
    application.add_handler(CallbackQueryHandler(list_channels_handler, pattern='^admin_list_channels$'))
    application.add_handler(CallbackQueryHandler(select_channel_to_monitor, pattern='^monitor_channel_'))
    application.add_handler(CallbackQueryHandler(select_topic_to_monitor, pattern='^monitor_topic_'))
    application.add_handler(CallbackQueryHandler(admin_view_targets_handler, pattern='^admin_view_targets$'))
    application.add_handler(CallbackQueryHandler(back_to_admin_menu_handler, pattern='^back_to_admin_menu$'))

    application.add_handler(CommandHandler("start", start))
    
    application.add_handler(CallbackQueryHandler(my_positions_handler, pattern='^user_positions$'))
    application.add_handler(CallbackQueryHandler(user_settings_handler, pattern='^user_settings$'))
    application.add_handler(CallbackQueryHandler(user_dashboard_handler, pattern='^user_dashboard$'))
    application.add_handler(CallbackQueryHandler(back_to_main_menu_handler, pattern='^back_to_main_menu$'))
    application.add_handler(CallbackQueryHandler(prompt_manual_close_handler, pattern='^confirm_close_'))
    application.add_handler(CallbackQueryHandler(execute_manual_close_handler, pattern='^execute_close_'))

    application.add_handler(CallbackQueryHandler(performance_menu_handler, pattern='^perf_'))
    
    application.add_handler(CallbackQueryHandler(list_closed_trades_handler, pattern='^list_closed_trades$'))

    application.add_handler(CallbackQueryHandler(bot_config_handler, pattern='^bot_config$'))
    application.add_handler(CallbackQueryHandler(toggle_approval_mode_handler, pattern='^toggle_approval_mode$'))

    application.add_handler(CallbackQueryHandler(handle_signal_approval, pattern=r'^(approve_signal_|reject_signal_)'))


    logger.info("Bot configurado. Iniciando todos os serviÃ§os...")

    await asyncio.gather(
        run_ptb(application, comm_queue),
        start_signal_monitor(comm_queue),
        run_tracker(application)
    )

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Bot desligado pelo usuÃ¡rio.")
    except Exception as e:
        logger.critical(f"Erro crÃ­tico nÃ£o tratado: {e}", exc_info=True)

========================================
# Arquivo: start.sh
========================================

#!/bin/sh

echo "Aplicando migraÃ§Ãµes do banco de dados..."
# Este comando garante que o DB esteja sempre na versÃ£o mais recente
alembic upgrade head

echo "Iniciando o bot TradeFlow..."
python main.py

========================================
# Arquivo: database/__init__.py
========================================



========================================
# Arquivo: database/crud.py
========================================

from .session import SessionLocal
from .models import User

def get_user_by_id(telegram_id: int):
    """Busca um usuÃ¡rio no banco de dados pelo seu ID do Telegram."""
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == telegram_id).first()
        return user
    finally:
        db.close()

========================================
# Arquivo: database/models.py
========================================

from sqlalchemy import (Column, Integer, String, BigInteger, Boolean, Float, JSON, DateTime, UniqueConstraint)
from sqlalchemy.orm import declarative_base
from sqlalchemy.sql import func

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)
    first_name = Column(String)
    api_key_encrypted = Column(String)
    api_secret_encrypted = Column(String)
    entry_size_percent = Column(Float, default=5.0)
    max_leverage = Column(Integer, default=10)
    min_confidence = Column(Float, default=0.0)
    approval_mode = Column(String, default='AUTOMATIC', nullable=False)
    daily_profit_target = Column(Float, default=0.0, nullable=False)
    daily_loss_limit = Column(Float, default=0.0, nullable=False)
    coin_whitelist = Column(String, default='todas', nullable=False)

class InviteCode(Base):
    __tablename__ = 'invite_codes'
    id = Column(Integer, primary_key=True)
    code = Column(String, unique=True, nullable=False)
    is_used = Column(Boolean, default=False)

class MonitoredTarget(Base):
    __tablename__ = 'monitored_targets'
    id = Column(Integer, primary_key=True)
    channel_id = Column(BigInteger, nullable=False)
    channel_name = Column(String)
    topic_id = Column(BigInteger, unique=True, nullable=True)
    topic_name = Column(String)

class Trade(Base):
    __tablename__ = 'trades'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False)
    order_id = Column(String, unique=True, nullable=False)
    symbol = Column(String, nullable=False)
    side = Column(String, nullable=False)
    qty = Column(Float, nullable=False)
    entry_price = Column(Float)
    stop_loss = Column(Float)
    current_stop_loss = Column(Float)
    initial_targets = Column(JSON)
    status = Column(String, default='ACTIVE')
    remaining_qty = Column(Float)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    closed_at = Column(DateTime(timezone=True), nullable=True)
    closed_pnl = Column(Float, nullable=True)

class PendingSignal(Base):
    __tablename__ = 'pending_signals'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False, index=True)
    
    # --- MUDANÃ‡A APLICADA AQUI ---
    # Removemos o unique=True do symbol
    symbol = Column(String, nullable=False, index=True) 
    
    order_id = Column(String, unique=True, nullable=False)
    signal_data = Column(JSON, nullable=False)

    # Adicionamos uma restriÃ§Ã£o de unicidade composta
    __table_args__ = (UniqueConstraint('user_telegram_id', 'symbol', name='_user_symbol_uc'),)

class SignalForApproval(Base):
    __tablename__ = 'signals_for_approval'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False, index=True)
    symbol = Column(String, nullable=False)
    source_name = Column(String)
    signal_data = Column(JSON, nullable=False)
    approval_message_id = Column(BigInteger)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

========================================
# Arquivo: database/session.py
========================================

import os # Importa a biblioteca 'os'
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from .models import Base

# --- LÃ“GICA DE CAMINHO DINÃ‚MICO ---
if os.path.isdir('/data'):
    # Caminho para o banco de dados no servidor Fly.io
    DATABASE_URL = "sqlite:////data/tradeflow.db"
else:
    # Caminho para o banco de dados local (no seu Mac)
    DATABASE_URL = "sqlite:///./tradeflow.db"

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def init_db():
    Base.metadata.create_all(bind=engine)

========================================
# Arquivo: core/__init__.py
========================================



========================================
# Arquivo: core/performance_service.py
========================================

from services.bybit_service import get_closed_pnl_breakdown, get_account_info
from utils.security import decrypt_data
from database.session import SessionLocal
from database.models import Trade, User
from datetime import datetime
import logging
import asyncio

logger = logging.getLogger(__name__)

async def generate_performance_report(user_id: int, start_dt: datetime, end_dt: datetime) -> str:
    """Gera relatÃ³rio de desempenho, incluindo a rentabilidade sobre o patrimÃ´nio."""
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if not user or not user.api_key_encrypted:
            return "VocÃª precisa ter uma chave de API configurada para ver o desempenho."

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # Busca os dados de P/L e o saldo da conta em paralelo
        pnl_result, account_info = await asyncio.gather(
            get_closed_pnl_breakdown(api_key, api_secret, start_dt, end_dt),
            get_account_info(api_key, api_secret)
        )

        if not pnl_result.get("success"):
            return f"NÃ£o foi possÃ­vel calcular seu desempenho: {pnl_result.get('error')}"

        total_pnl = pnl_result["total_pnl"]
        wins = pnl_result["wins"]
        losses = pnl_result["losses"]
        trades = pnl_result["trades"]
        hit_rate = (wins / trades * 100.0) if trades else 0.0
        
        # --- NOVO CÃLCULO DE RENTABILIDADE ---
        rentabilidade_str = ""
        if account_info.get("success"):
            total_equity = account_info.get("data", {}).get("total_equity", 0.0)
            if total_equity > 0:
                rentabilidade = (total_pnl / total_equity) * 100
                rentabilidade_str = f"ğŸš€ <b>Rentabilidade:</b> {rentabilidade:+.2f}%\n\n"
        
        lucro_str = f"ğŸ“ˆ <b>Lucro:</b> ${total_pnl:,.2f}" if total_pnl >= 0 else f"ğŸ“‰ <b>PrejuÃ­zo:</b> ${abs(total_pnl):,.2f}"

        msg = (
            f"<b>ğŸ“Š Desempenho do PerÃ­odo</b>\n"
            f"<i>De {start_dt:%d/%m/%Y} a {end_dt:%d/%m/%Y}</i>\n\n"
            f"{rentabilidade_str}"
            f"{lucro_str}\n\n"
            f"ğŸ¯ <b>Taxa de Acerto:</b> {hit_rate:.2f}%\n"
            f"ğŸ“¦ <b>Total de Trades:</b> {trades}\n"
            f"  - Ganhos: {wins}\n"
            f"  - Perdas: {losses}\n"
        )
        return msg

    except Exception as e:
        logger.error(f"Erro ao gerar relatÃ³rio de performance para {user_id}: {e}", exc_info=True)
        return "Ocorreu um erro ao gerar seu relatÃ³rio."
    finally:
        db.close()


========================================
# Arquivo: core/position_tracker.py
========================================

import asyncio
import logging
from telegram.ext import Application
from sqlalchemy.orm import Session
from database.session import SessionLocal
from database.models import Trade, User, PendingSignal
from services.bybit_service import (
    get_market_price, close_partial_position,
    modify_position_stop_loss, get_order_status,
    get_specific_position_size, modify_position_take_profit,
    get_last_closed_trade_info
)
from services.notification_service import send_notification
from utils.security import decrypt_data
from sqlalchemy.sql import func

logger = logging.getLogger(__name__)


async def check_pending_orders_for_user(application: Application, user: User, db: Session):
    """Verifica as ordens limite pendentes e envia notificaÃ§Ã£o detalhada na execuÃ§Ã£o."""
    pending_orders = db.query(PendingSignal).filter_by(user_telegram_id=user.telegram_id).all()
    if not pending_orders:
        return

    logger.info(f"Rastreador: Verificando {len(pending_orders)} ordem(ns) pendente(s) para o usuÃ¡rio {user.telegram_id}.")
    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)

    for order in pending_orders:
        status_result = await get_order_status(api_key, api_secret, order.order_id, order.symbol)
        if not status_result.get("success"):
            logger.error(f"Falha ao obter status da ordem {order.order_id}: {status_result.get('error')}")
            continue

        order_data = status_result["data"] or {}
        order_status = (order_data.get("orderStatus") or "").strip()

        if order_status == 'Filled':
            logger.info(f"Ordem Limite {order.order_id} EXECUTADA para o usuÃ¡rio {user.telegram_id}.")
            signal_data = order.signal_data or {}
            
            qty = float(order_data.get('cumExecQty', 0.0))
            entry_price = float(order_data.get('avgPrice', 0.0))
            
            if qty <= 0 or entry_price <= 0:
                logger.warning(f"Ordem {order.order_id} Filled, mas com qty/preÃ§o zerado. Removendo.")
                db.delete(order)
                await application.bot.send_message(chat_id=user.telegram_id, text=f"â„¹ï¸ Sua ordem limite para <b>{order.symbol}</b> foi finalizada sem execuÃ§Ã£o reportada.", parse_mode='HTML')
                continue

            # --- LÃ“GICA DE NOTIFICAÃ‡ÃƒO DETALHADA ---
            side = signal_data.get('order_type')
            leverage = user.max_leverage
            margin = (qty * entry_price) / leverage if leverage > 0 else 0
            stop_loss = signal_data.get('stop_loss')
            all_targets = signal_data.get('targets') or []
            take_profit_1 = all_targets[0] if all_targets else "N/A"
            num_targets = len(all_targets)
            tp_text = f"${float(take_profit_1):,.4f}" if isinstance(take_profit_1, (int, float)) else take_profit_1
            if num_targets > 1:
                tp_text += f" (de {num_targets} alvos)"
            
            new_trade = Trade(
                user_telegram_id=order.user_telegram_id, order_id=order.order_id,
                symbol=order.symbol, side=side, qty=qty, entry_price=entry_price,
                stop_loss=stop_loss, current_stop_loss=stop_loss,
                initial_targets=all_targets, status='ACTIVE', remaining_qty=qty
            )
            db.add(new_trade)
            db.delete(order)
            
            message = (
                f"ğŸ“ˆ <b>Ordem Limite Executada!</b>\n\n"
                f"  - ğŸ“Š <b>Tipo:</b> {side} | <b>Alavancagem:</b> {leverage}x\n"
                f"  - ğŸ’ <b>Moeda:</b> {order.symbol}\n"
                f"  - ğŸ”¢ <b>Quantidade:</b> {qty:g}\n"
                f"  - ğŸ’µ <b>PreÃ§o de Entrada:</b> ${entry_price:,.4f}\n"
                f"  - ğŸ’° <b>Margem:</b> ${margin:,.2f}\n"
                f"  - ğŸ›¡ï¸ <b>Stop Loss:</b> ${stop_loss:,.4f}\n"
                f"  - ğŸ¯ <b>Take Profit 1:</b> {tp_text}"
            )
            await application.bot.send_message(chat_id=user.telegram_id, text=message, parse_mode='HTML')

        elif order_status in {'Cancelled', 'Deactivated', 'Rejected'}:
            logger.info(f"Ordem Limite {order.order_id} do usuÃ¡rio {user.telegram_id} foi '{order_status}'. Removendo.")
            db.delete(order)
            await application.bot.send_message(chat_id=user.telegram_id, text=f"â„¹ï¸ Sua ordem limite para <b>{order.symbol}</b> foi '<b>{order_status}</b>' e removida do monitoramento.", parse_mode='HTML')

async def check_active_trades_for_user(application: Application, user: User, db: Session):
    """Verifica e gerencia os trades ativos, usando a funÃ§Ã£o detetive para fechamentos."""
    active_trades = db.query(Trade).filter(
        Trade.user_telegram_id == user.telegram_id,
        ~Trade.status.like('%CLOSED%')
    ).all()
    if not active_trades:
        return

    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)

    for trade in active_trades:
        live_position_size = await get_specific_position_size(api_key, api_secret, trade.symbol)

        if live_position_size > 0:
            # --- CENÃRIO 1: POSIÃ‡ÃƒO ABERTA (LÃ“GICA EXISTENTE) ---
            # (A lÃ³gica de TP/SL para posiÃ§Ãµes abertas continua a mesma)
            price_result = await get_market_price(trade.symbol)
            if not price_result.get("success"): continue
            current_price = price_result["price"]
            # ... (LÃ³gica de TP e SL que jÃ¡ temos) ...

        else:
            # --- CENÃRIO 2: POSIÃ‡ÃƒO FECHADA - USANDO O DETETIVE ---
            logger.info(f"[tracker] PosiÃ§Ã£o para {trade.symbol} nÃ£o encontrada. Usando o detetive...")
            
            closed_info_result = await get_last_closed_trade_info(api_key, api_secret, trade.symbol)

            if closed_info_result.get("success"):
                closed_data = closed_info_result["data"]
                pnl = float(closed_data.get("closedPnl", 0.0))
                closing_reason = closed_data.get("exitType", "Unknown")

                trade.closed_at = func.now()
                trade.closed_pnl = pnl
                trade.remaining_qty = 0.0
                
                message_text = ""
                if closing_reason == "TakeProfit":
                    trade.status = 'CLOSED_PROFIT'
                    message_text = f"ğŸ† <b>Take Profit Atingido!</b> ğŸ†\n<b>Moeda:</b> {trade.symbol}\n<b>Lucro Realizado:</b> ${pnl:,.2f}"
                elif closing_reason == "StopLoss":
                    if pnl >= 0:
                        trade.status = 'CLOSED_STOP_GAIN'
                        message_text = f"âœ… <b>Stop com Ganho Atingido!</b>\n<b>Moeda:</b> {trade.symbol}\n<b>Resultado:</b> ${pnl:,.2f}"
                    else:
                        trade.status = 'CLOSED_LOSS'
                        message_text = f"ğŸ›‘ <b>Stop Loss Atingido</b>\n<b>Moeda:</b> {trade.symbol}\n<b>PrejuÃ­zo Realizado:</b> ${pnl:,.2f}"
                else: # Outros motivos (LiquidaÃ§Ã£o, Manual, etc.)
                    trade.status = 'CLOSED_GHOST'
                    message_text = f"â„¹ï¸ PosiÃ§Ã£o em <b>{trade.symbol}</b> foi fechada na corretora.\n<b>Resultado:</b> ${pnl:,.2f}"

                await application.bot.send_message(chat_id=user.telegram_id, text=message_text, parse_mode='HTML')
            else:
                # Fallback se o detetive falhar
                trade.status = 'CLOSED_GHOST'; trade.closed_at = func.now(); trade.closed_pnl = 0.0
                trade.remaining_qty = 0.0
                message_text = f"â„¹ï¸ PosiÃ§Ã£o em <b>{trade.symbol}</b> nÃ£o foi encontrada na Bybit e foi removida do monitoramento."
                await application.bot.send_message(chat_id=user.telegram_id, text=message_text, parse_mode='HTML')

async def run_tracker(application: Application):
    """FunÃ§Ã£o principal que roda o verificador em loop para TODOS os usuÃ¡rios."""
    logger.info("Iniciando Rastreador de PosiÃ§Ãµes e Ordens (Modo MultiusuÃ¡rio)...")
    while True:
        db = SessionLocal()
        try:
            all_users = db.query(User).filter(User.api_key_encrypted.isnot(None)).all()
            if not all_users:
                logger.info("Rastreador: Nenhum usuÃ¡rio com API para verificar.")
            else:
                logger.info(f"Rastreador: Verificando assets para {len(all_users)} usuÃ¡rio(s).")
                for user in all_users:
                    await check_pending_orders_for_user(application, user, db)
                    await check_active_trades_for_user(application, user, db)

                # commit das modificaÃ§Ãµes (Trades atualizados, remoÃ§Ã£o de Pending, etc.)
                db.commit()

        except Exception as e:
            logger.critical(f"Erro crÃ­tico no loop do rastreador: {e}", exc_info=True)
            db.rollback()
        finally:
            db.close()

        await asyncio.sleep(60)


========================================
# Arquivo: core/trade_manager.py
========================================

import os
import asyncio
import logging
from typing import Tuple
from telegram.ext import Application
from sqlalchemy.orm import Session
from database.session import SessionLocal
from database.models import User, Trade, PendingSignal, SignalForApproval
from services.bybit_service import (
    place_order, get_account_info,
    place_limit_order, cancel_order,
    get_order_history
)
from services.notification_service import send_notification
from utils.security import decrypt_data
from utils.config import ADMIN_ID
from bot.keyboards import signal_approval_keyboard
from services.signal_parser import SignalType
from core.whitelist_service import is_coin_in_whitelist

logger = logging.getLogger(__name__)


def _avaliar_sinal(signal_data: dict, user_settings: User) -> Tuple[bool, str]:
    min_confidence = user_settings.min_confidence
    signal_confidence = signal_data.get('confidence', 0.0)
    if signal_confidence is not None and signal_confidence < min_confidence:
        motivo = f"ConfianÃ§a ({signal_confidence:.2f}%) Ã© menor que o seu mÃ­nimo ({min_confidence:.2f}%)"
        return False, motivo
    return True, "Sinal aprovado pelos seus critÃ©rios."

async def _execute_trade(signal_data: dict, user: User, application: Application, db: Session, source_name: str):
    """Executa uma ordem a MERCADO, busca os detalhes da execuÃ§Ã£o e envia uma notificaÃ§Ã£o detalhada."""
    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)
    
    account_info = await get_account_info(api_key, api_secret)
    if not account_info.get("success"):
        await application.bot.send_message(chat_id=user.telegram_id, text=f"âŒ Falha ao buscar seu saldo Bybit para operar {signal_data['coin']}.")
        return

    balance_data = account_info.get("data", {})
    balance = float(balance_data.get('available_balance_usdt', 0))

    order_result = await place_order(api_key, api_secret, signal_data, user, balance)
    
    if order_result.get("success"):
        order_data = order_result['data']
        order_id = order_data['orderId']
        
        await asyncio.sleep(2)
        final_order_data_result = await get_order_history(api_key, api_secret, order_id)
        if not final_order_data_result.get("success"):
            await application.bot.send_message(chat_id=user.telegram_id, text=f"âš ï¸ Ordem {signal_data['coin']} enviada, mas falha ao confirmar detalhes. Verifique na corretora.")
            return
        final_order_data = final_order_data_result['data']
        
        symbol = signal_data['coin']
        side = signal_data['order_type']
        leverage = user.max_leverage
        qty = float(final_order_data.get('cumExecQty', 0))
        entry_price = float(final_order_data.get('avgPrice', 0))
        
        if qty == 0 or entry_price == 0:
            await application.bot.send_message(chat_id=user.telegram_id, text=f"âš ï¸ Ordem {symbol} enviada, mas a execuÃ§Ã£o reportou quantidade/preÃ§o zerado.")
            return
            
        margin = (qty * entry_price) / leverage if leverage > 0 else 0
        stop_loss = signal_data['stop_loss']
        
        # --- LÃ“GICA DE NOTIFICAÃ‡ÃƒO CORRIGIDA ---
        all_targets = signal_data.get('targets') or []
        take_profit_1 = all_targets[0] if all_targets else "N/A"
        num_targets = len(all_targets)

        new_trade = Trade(
            user_telegram_id=user.telegram_id, order_id=order_id,
            symbol=symbol, side=side, qty=qty, entry_price=entry_price,
            stop_loss=stop_loss, current_stop_loss=stop_loss,
            initial_targets=all_targets, # Garante que todos os alvos sejam salvos
            status='ACTIVE',
            remaining_qty=qty
        )
        db.add(new_trade)
        logger.info(f"Trade {order_id} para o usuÃ¡rio {user.telegram_id} salvo no DB com dados de execuÃ§Ã£o.")
        
        tp_text = f"${float(take_profit_1):,.4f}" if isinstance(take_profit_1, (int, float)) else take_profit_1
        if num_targets > 1:
            tp_text += f" (de {num_targets} alvos)"

        message = (
            f"ğŸ“ˆ <b>Ordem a Mercado Aberta!</b>\n\n"
            f"  - ğŸ“Š <b>Tipo:</b> {side} | <b>Alavancagem:</b> {leverage}x\n"
            f"  - ğŸ’ <b>Moeda:</b> {symbol}\n"
            f"  - ğŸ”¢ <b>Quantidade:</b> {qty:g}\n"
            f"  - ğŸ’µ <b>PreÃ§o de Entrada:</b> ${entry_price:,.4f}\n"
            f"  - ğŸ’° <b>Margem:</b> ${margin:,.2f}\n"
            f"  - ğŸ›¡ï¸ <b>Stop Loss:</b> ${stop_loss:,.4f}\n"
            f"  - ğŸ¯ <b>Take Profit 1:</b> {tp_text}"
        )
        await application.bot.send_message(chat_id=user.telegram_id, text=message, parse_mode='HTML')
    else:
        error_msg = order_result.get('error')
        await application.bot.send_message(chat_id=user.telegram_id, text=f"âŒ <b>Falha ao Abrir Ordem</b>\n<b>Moeda:</b> {signal_data['coin']}\n<b>Motivo:</b> {error_msg}", parse_mode='HTML')

async def process_new_signal(signal_data: dict, application: Application, source_name: str):
    """Processa um novo sinal, verificando a preferÃªncia de cada usuÃ¡rio individualmente."""
    signal_type = signal_data.get("type")
    symbol = signal_data.get("coin")
    db = SessionLocal()
    try:
        if signal_type == SignalType.CANCELAR:
            # A lÃ³gica de cancelamento permanece a mesma
            logger.info(f"Recebido sinal de cancelamento para {symbol}.")
            # ... (cÃ³digo de cancelamento que vocÃª jÃ¡ tem)
            db.commit()
            return

        elif signal_type in [SignalType.MARKET, SignalType.LIMIT]:
            all_users = db.query(User).filter(User.api_key_encrypted.isnot(None)).all()
            if not all_users:
                logger.info("Nenhum usuÃ¡rio com API para processar o sinal.")
                return

            logger.info(f"Sinal para {symbol} recebido. Verificando preferÃªncias de {len(all_users)} usuÃ¡rio(s)...")

            for user in all_users:
                # 1. Avalia o sinal contra os filtros do usuÃ¡rio
                aprovado, motivo = _avaliar_sinal(signal_data, user)
                if not aprovado:
                    logger.info(f"Sinal para {symbol} ignorado para o usuÃ¡rio {user.telegram_id}: {motivo}")
                    continue
                
                # 2. Verifica a whitelist do usuÃ¡rio
                if not is_coin_in_whitelist(symbol, user.coin_whitelist):
                    logger.info(f"Sinal para {symbol} ignorado para o usuÃ¡rio {user.telegram_id} devido Ã  whitelist.")
                    continue

                # 3. Verifica o modo de aprovaÃ§Ã£o individual do usuÃ¡rio
                if user.approval_mode == 'AUTOMATIC':
                    logger.info(f"UsuÃ¡rio {user.telegram_id} em modo AUTOMÃTICO. Executando trade para {symbol}.")
                    if signal_type == SignalType.MARKET:
                        await _execute_trade(signal_data, user, application, db, source_name)
                    elif signal_type == SignalType.LIMIT:
                        await _execute_limit_order_for_user(signal_data, user, application, db)

                elif user.approval_mode == 'MANUAL':
                    logger.info(f"UsuÃ¡rio {user.telegram_id} em modo MANUAL. Enviando sinal para sua aprovaÃ§Ã£o.")
                    
                    new_signal_for_approval = SignalForApproval(
                        user_telegram_id=user.telegram_id,  # <-- Agora salva o ID do usuÃ¡rio correto
                        symbol=symbol,
                        source_name=source_name,
                        signal_data=signal_data
                    )
                    db.add(new_signal_for_approval)
                    db.commit() # Commit para obter o ID

                    signal_details = (
                        f"<b>Sinal Recebido para AprovaÃ§Ã£o</b>\n\n"
                        f"<b>Moeda:</b> {signal_data['coin']}\n"
                        f"<b>Tipo:</b> {signal_data['order_type']}\n<b>Entrada:</b> {signal_data['entries'][0]}\n"
                        f"<b>Stop:</b> {signal_data['stop_loss']}\n<b>Alvo 1:</b> {signal_data['targets'][0]}\n\n"
                        f"O sinal passou nos seus filtros. VocÃª aprova a entrada?"
                    )
                    sent_message = await application.bot.send_message(
                        chat_id=user.telegram_id, # <-- Envia para o usuÃ¡rio especÃ­fico
                        text=signal_details, parse_mode='HTML',
                        reply_markup=signal_approval_keyboard(new_signal_for_approval.id)
                    )
                    new_signal_for_approval.approval_message_id = sent_message.message_id
        
        db.commit()
    finally:
        db.close()

async def _execute_limit_order_for_user(signal_data: dict, user: User, application: Application, db: Session):
    """FunÃ§Ã£o auxiliar para posicionar uma ordem limite para um Ãºnico usuÃ¡rio."""
    symbol = signal_data.get("coin")
    existing_pending = db.query(PendingSignal).filter_by(user_telegram_id=user.telegram_id, symbol=symbol).first()
    if existing_pending:
        await application.bot.send_message(chat_id=user.telegram_id, text=f"â„¹ï¸ VocÃª jÃ¡ tem uma ordem limite pendente para <b>{symbol}</b>.", parse_mode='HTML')
        return

    entries = (signal_data.get('entries') or [])[:2]
    if not entries:
        logger.warning(f"Sinal LIMIT para {symbol} sem preÃ§os de entrada vÃ¡lidos.")
        return

    limit_price = float(min(entries)) if (signal_data.get('order_type') or '').upper() == 'LONG' else float(max(entries))
    signal_data['limit_price'] = limit_price

    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)
    account_info = await get_account_info(api_key, api_secret)
    if not account_info.get("success"):
        logger.error(f"Falha ao buscar saldo para usuÃ¡rio {user.telegram_id} ao posicionar LIMIT em {symbol}.")
        return

    balance = float(account_info.get("data", {}).get('available_balance_usdt', 0))
    limit_order_result = await place_limit_order(api_key, api_secret, signal_data, user, balance)

    if limit_order_result.get("success"):
        order_id = limit_order_result["data"]["orderId"]
        db.add(PendingSignal(user_telegram_id=user.telegram_id, symbol=symbol, order_id=order_id, signal_data=signal_data))
        
        # --- LÃ“GICA DE NOTIFICAÃ‡ÃƒO COMPLETA ---
        all_targets = signal_data.get('targets') or []
        take_profit_1 = all_targets[0] if all_targets else "N/A"
        num_targets = len(all_targets)
        tp_text = f"${float(take_profit_1):,.4f}" if isinstance(take_profit_1, (int, float)) else take_profit_1
        if num_targets > 1:
            tp_text += f" (de {num_targets} alvos)"
        
        message = (
            f"âœ… <b>Ordem Limite Posicionada!</b>\n\n"
            f"  - ğŸ“Š <b>Tipo:</b> {signal_data.get('order_type')} | <b>Alavancagem:</b> {user.max_leverage}x\n"
            f"  - ğŸ’ <b>Moeda:</b> {symbol}\n"
            f"  - ğŸ¯ <b>PreÃ§o de Entrada:</b> ${limit_price:,.4f}\n"
            f"  - ğŸ›¡ï¸ <b>Stop Loss:</b> ${signal_data.get('stop_loss'):,.4f}\n"
            f"  - ğŸ¯ <b>Take Profit 1:</b> {tp_text}\n\n"
            f"ğŸ‘€ Monitorando a execuÃ§Ã£oâ€¦"
        )
        await application.bot.send_message(chat_id=user.telegram_id, text=message, parse_mode='HTML')
    else:
        error = limit_order_result.get('error') or "Erro desconhecido"
        await application.bot.send_message(chat_id=user.telegram_id, text=f"âŒ Falha ao posicionar sua ordem limite para <b>{symbol}</b>.\n<b>Motivo:</b> {error}", parse_mode='HTML')

========================================
# Arquivo: core/whitelist_service.py
========================================

import logging
from typing import Set

logger = logging.getLogger(__name__)

# --- CATEGORIAS DE MOEDAS ---
# Estas listas podem ser expandidas no futuro. Usamos Sets para performance.

# Moedas de grande capitalizaÃ§Ã£o e projetos estabelecidos (excluindo BTC e ETH)
ALTCOINS_L1_L2: Set[str] = {
    'SOLUSDT', 'XRPUSDT', 'ADAUSDT', 'AVAXUSDT', 'DOTUSDT', 'MATICUSDT',
    'LINKUSDT', 'TRXUSDT', 'ATOMUSDT', 'NEARUSDT', 'APTUSDT', 'OPUSDT',
    'ARBUSDT', 'LDOUSDT', 'SUIUSDT'
}

# Moedas relacionadas a FinanÃ§as Descentralizadas
DEFI: Set[str] = {
    'UNIUSDT', 'AAVEUSDT', 'MKRUSDT', 'SNXUSDT', 'COMPUSDT', 'CRVUSDT',
    'SUSHIUSDT', 'YFIUSDT'
}

# Moedas de "memes" com alta volatilidade
MEMECOINS: Set[str] = {
    'DOGEUSDT', 'SHIBUSDT', 'PEPEUSDT', 'WIFUSDT', 'FLOKIUSDT', 'BONKUSDT'
}

# DicionÃ¡rio que mapeia a palavra-chave da categoria para o Set de moedas
CATEGORIES = {
    'altcoins': ALTCOINS_L1_L2,
    'defi': DEFI,
    'memecoins': MEMECOINS,
}

def is_coin_in_whitelist(symbol: str, user_whitelist_str: str) -> bool:
    """
    Verifica se um sÃ­mbolo de moeda estÃ¡ na whitelist de um usuÃ¡rio.

    A whitelist pode conter:
    - O keyword 'todas'.
    - SÃ­mbolos especÃ­ficos (ex: 'btcusdt').
    - Keywords de categorias (ex: 'memecoins').
    """
    if not user_whitelist_str or 'todas' in user_whitelist_str.lower():
        return True

    # Normaliza a entrada do usuÃ¡rio: minÃºsculas, remove espaÃ§os, divide por vÃ­rgula
    user_list = {item.strip() for item in user_whitelist_str.lower().split(',')}
    
    # 1. Verifica se o sÃ­mbolo exato estÃ¡ na lista do usuÃ¡rio
    if symbol.lower() in user_list:
        return True

    # 2. Verifica se alguma das categorias da lista do usuÃ¡rio contÃ©m o sÃ­mbolo
    for category_keyword in user_list:
        if category_keyword in CATEGORIES and symbol in CATEGORIES[category_keyword]:
            return True
            
    # Se nenhuma das condiÃ§Ãµes acima for atendida, a moeda nÃ£o estÃ¡ na whitelist
    return False

========================================
# Arquivo: tests/__init__.py
========================================



========================================
# Arquivo: tests/test_signal_cyber_e2e.py
========================================

# tests/test_signal_cyber_e2e.py
import sys
import types
import textwrap
import pytest

# ======== STUBS mÃ­nimos (telegram e keyboards) ========
telegram = types.ModuleType("telegram")
telegram_ext = types.ModuleType("telegram.ext")
telegram_constants = types.ModuleType("telegram.constants")

class InlineKeyboardButton:
    def __init__(self, text, callback_data=None, url=None):
        self.text = text; self.callback_data = callback_data; self.url = url

class InlineKeyboardMarkup:
    def __init__(self, keyboard): self.keyboard = keyboard

class Application:
    def __init__(self): self.bot = None

telegram.InlineKeyboardButton = InlineKeyboardButton
telegram.InlineKeyboardMarkup = InlineKeyboardMarkup
telegram.constants = telegram_constants
telegram_ext.Application = Application

sys.modules.setdefault("telegram", telegram)
sys.modules.setdefault("telegram.ext", telegram_ext)
sys.modules.setdefault("telegram.constants", telegram_constants)

bot_pkg = types.ModuleType("bot")
bot_keyboards = types.ModuleType("bot.keyboards")
def signal_approval_keyboard(signal_id: int):
    return InlineKeyboardMarkup([[InlineKeyboardButton("Aprovar", callback_data=f"approve:{signal_id}")]])
bot_keyboards.signal_approval_keyboard = signal_approval_keyboard
sys.modules.setdefault("bot", bot_pkg)
sys.modules.setdefault("bot.keyboards", bot_keyboards)

# ======== Imports reais do projeto ========
from services.signal_parser import parse_signal, SignalType
import core.trade_manager as tm

# ======== Fakes utilitÃ¡rios ========
class FakeUser:
    def __init__(self, telegram_id=111, api_key_encrypted="enc_k", api_secret_encrypted="enc_s"):
        self.telegram_id = telegram_id
        self.api_key_encrypted = api_key_encrypted
        self.api_secret_encrypted = api_secret_encrypted

class _QueryList:
    def __init__(self, data_list): self._data = data_list
    def filter(self, *a, **k): return self
    def filter_by(self, **k):
        def ok(obj): return all(getattr(obj, kk, None) == vv for kk, vv in k.items())
        return _QueryList([x for x in self._data if ok(x)])
    def all(self): return list(self._data)
    def first(self): return self._data[0] if self._data else None

class FakeDB:
    def __init__(self, users=None, pendings=None):
        self._users = users or []
        self._pendings = pendings or []
        self.added = []; self.deleted = []; self.commits = 0
    def query(self, Model):
        if Model is tm.User: return _QueryList(self._users)
        if Model is tm.PendingSignal: return _QueryList(self._pendings)
        return _QueryList([])
    def add(self, obj):
        self.added.append(obj)
        if isinstance(obj, tm.PendingSignal) or getattr(obj, "__class__", None).__name__ == "DummyPending":
            self._pendings.append(obj)
    def delete(self, obj):
        self.deleted.append(obj)
        if obj in self._pendings: self._pendings.remove(obj)
    def commit(self): self.commits += 1

class FakeBot:
    def __init__(self): self.sent = []
    async def send_message(self, **kwargs): self.sent.append(kwargs)

class FakeApplication(Application):
    def __init__(self): super().__init__(); self.bot = FakeBot()

# ======== Sinal CYBER (LIMIT/SHORT) ========
CYBER_SIGNAL = textwrap.dedent("""
â³ #38792 - Ordem Limite

ğŸ’ Moeda: CYBER
ğŸ“Š Tipo: SHORT (Futures)

ğŸ’° Zona de Entrada: 2.52500000 - 2.64000000
ğŸ›‘ Stop Loss: 2.90000000 (12.2943%)
ğŸ¯ Alvos:
T1: 2.44000000 (5.52%)
T2: 2.37000000 (8.23%)
T3: 2.29000000 (11.33%)
T4: 2.20000000 (14.81%)
""")

@pytest.mark.asyncio
async def test_cyber_limit_short_positions_limit_order(monkeypatch):
    parsed = parse_signal(CYBER_SIGNAL)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "SHORT"
    assert parsed["coin"] == "CYBERUSDT"
    assert parsed["entries"] == [2.525, 2.64]
    assert parsed["stop_loss"] == 2.9

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=777)])

    # dummy PendingSignal para nÃ£o depender de SQLAlchemy real
    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    # Capturas
    called = {"market": False, "limit_payload": None}

    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        # guardamos o payload passado â€” deve conter limit_price = 2.64
        called["limit_payload"] = dict(signal_data)
        return {"success": True, "data": {"orderId": "CYB-LIM-001"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "123.45"}]}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    # patches
    monkeypatch.setattr(tm, "place_order", fake_place_order)  # nÃ£o deve ser chamado
    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # 1) NÃƒO abriu a mercado
    assert not called["market"], "LIMIT/SHORT nÃ£o deve abrir ordem a mercado"

    # 2) Chamou limit com limit_price = 2.64 (maior da faixa)
    assert called["limit_payload"] is not None, "place_limit_order nÃ£o foi chamado"
    assert called["limit_payload"].get("limit_price") == pytest.approx(2.64, rel=1e-6)

    # 3) Criou PendingSignal
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal nÃ£o foi criado"

    # 4) Enviou mensagem ao usuÃ¡rio
    assert app.bot.sent, "Nenhuma mensagem foi enviada ao usuÃ¡rio"
    texts = [m.get("text", "").lower() for m in app.bot.sent]
    assert any("limite" in t or "monitorando" in t for t in texts), texts


========================================
# Arquivo: tests/test_signal_parser.py
========================================

import textwrap

from services.signal_parser import parse_signal, SignalType


def test_parse_signal_without_diamond():
    message = textwrap.dedent(
        """
        â³ #1 - Ordem Limite
        Moeda: SOL
        Tipo: SHORT (Futures)
        Zona de Entrada: 182.66 - 182.66
        Stop Loss: 186.36
        Alvos:
        T1: 181.18
        """
    )

    data = parse_signal(message)

    assert data["coin"] == "SOLUSDT"
    assert data["type"] == SignalType.LIMIT


def test_parse_signal_with_coin_synonym():
    message = textwrap.dedent(
        """
        â³ #2 - Ordem Limite
        Coin: NMR
        Tipo: SHORT (Futures)
        Zona de Entrada: 8.04 - 8.28
        Stop Loss: 8.55
        Alvos:
        T1: 7.99
        """
    )

    data = parse_signal(message)

    assert data["coin"] == "NMRUSDT"
    assert data["type"] == SignalType.LIMIT


def test_parse_complex_signal_with_emojis_and_extra_text():
    message = textwrap.dedent(
        """
        â³ #38792 - Ordem Limite

        ğŸ“¢ Canal: GRE - 58
        ğŸŒ Plataforma: telegram

        ğŸ’ Moeda: CYBER
        ğŸ“Š Tipo: SHORT (Futures)
        ğŸ“ˆ Alavancagem: 10x

        ğŸ’° Zona de Entrada: 2.52500000 - 2.64000000
        ğŸ›‘ Stop Loss: 2.90000000 (12.2943%)
        ğŸ¯ Alvos:
        T1: 2.44000000 (5.52%)
        T2: 2.37000000 (8.23%)
        T3: 2.29000000 (11.33%)
        T4: 2.20000000 (14.81%)
        â˜¯ï¸ R/R ratio: 0.4

        ğŸ“Š Status: Sinal aberto

        ğŸŸ¢ ConfianÃ§a: 66.67%  ğŸ§­ Consenso: 4/6
        """
    )

    data = parse_signal(message)

    assert data is not None, "O parser nÃ£o deveria retornar None para este sinal"
    assert data["type"] == SignalType.LIMIT
    assert data["coin"] == "CYBERUSDT"
    assert data["order_type"] == "SHORT"
    assert data["entries"] == [2.525, 2.64]
    assert data["stop_loss"] == 2.9
    assert data["targets"] == [2.44, 2.37, 2.29, 2.2]
    assert data["confidence"] == 66.67



# --- NOVO TESTE: MARKET (Ordem Ã  Mercado) ---
def test_parse_market_signal_with_accent():
    message = textwrap.dedent(
        """
        ğŸ #39170 - Ordem Ã  Mercado

        ğŸ’ Moeda: AVAX
        ğŸ“Š Tipo: SHORT (Futures)

        ğŸ’° Zona de Entrada: 22.85000000 - 22.85000000
        ğŸ›‘ Stop Loss: 24.22000000
        Alvos:
        T1: 22.69000000
        T2: 22.55000000
        """
    )

    data = parse_signal(message)

    assert data is not None
    assert data["type"] == SignalType.MARKET
    assert data["coin"] == "AVAXUSDT"
    assert data["order_type"] == "SHORT"
    assert data["entries"][0] == 22.85
    assert data["stop_loss"] == 24.22
    assert 22.69 in data["targets"]
    assert 22.55 in data["targets"]


# --- NOVO TESTE: CANCELAR ---
def test_parse_cancel_signal():
    message = textwrap.dedent(
        """
        âš ï¸ BTC sinal cancelado
        """
    )

    data = parse_signal(message)

    assert data is not None
    assert data["type"] == SignalType.CANCELAR
    assert data["coin"] == "BTCUSDT"


========================================
# Arquivo: tests/test_trade_manager_e2e.py
========================================

# tests/test_trade_manager_e2e.py

import sys
import types
import textwrap
import pytest

# ===========================
# STUBS: telegram e bot.keyboards
# ===========================
telegram = types.ModuleType("telegram")
telegram_ext = types.ModuleType("telegram.ext")
telegram_constants = types.ModuleType("telegram.constants")

class InlineKeyboardButton:
    def __init__(self, text, callback_data=None, url=None):
        self.text = text
        self.callback_data = callback_data
        self.url = url

class InlineKeyboardMarkup:
    def __init__(self, keyboard):
        self.keyboard = keyboard

class Application:
    def __init__(self):
        self.bot = None

# expÃµe no mÃ³dulo stub
telegram.InlineKeyboardButton = InlineKeyboardButton
telegram.InlineKeyboardMarkup = InlineKeyboardMarkup
telegram.constants = telegram_constants
telegram_ext.Application = Application

# registra stubs
sys.modules.setdefault("telegram", telegram)
sys.modules.setdefault("telegram.ext", telegram_ext)
sys.modules.setdefault("telegram.constants", telegram_constants)

# bot.keyboards stub (para satisfazer "from bot.keyboards import signal_approval_keyboard")
bot_pkg = types.ModuleType("bot")
bot_keyboards = types.ModuleType("bot.keyboards")
def signal_approval_keyboard(signal_id: int):
    return InlineKeyboardMarkup([[InlineKeyboardButton("Aprovar", callback_data=f"approve:{signal_id}")]])
bot_keyboards.signal_approval_keyboard = signal_approval_keyboard
sys.modules.setdefault("bot", bot_pkg)
sys.modules.setdefault("bot.keyboards", bot_keyboards)

# ===========================
# Imports reais do projeto
# ===========================
from services.signal_parser import parse_signal, SignalType
import core.trade_manager as tm


# ===========================
# Fakes utilitÃ¡rios
# ===========================
class FakeUser:
    def __init__(self, telegram_id=111, api_key_encrypted="enc_k", api_secret_encrypted="enc_s", min_confidence=0.0, approval_mode="AUTOMATIC"):
        self.telegram_id = telegram_id
        self.api_key_encrypted = api_key_encrypted
        self.api_secret_encrypted = api_secret_encrypted
        self.min_confidence = min_confidence
        self.approval_mode = approval_mode

class _QueryList:
    def __init__(self, data_list):
        self._data = data_list
    def filter(self, *args, **kwargs):  # compat simples
        return self
    def filter_by(self, **kwargs):
        # ImplementaÃ§Ã£o leve para casos .filter_by(user_telegram_id=..., symbol=...)
        def match(obj):
            return all(getattr(obj, k, None) == v for k, v in kwargs.items())
        return _QueryList([x for x in self._data if match(x)])
    def all(self):
        return list(self._data)
    def first(self):
        return self._data[0] if self._data else None

class FakeDB:
    """DB fake que suporta .query(Model) e listas de users/pendings."""
    def __init__(self, users=None, pendings=None):
        self._users = users or []
        self._pendings = pendings or []
        self.added = []
        self.deleted = []
        self.commits = 0
        self.closed = False
    def query(self, Model):
        if Model is tm.User:
            return _QueryList(self._users)
        if Model is tm.PendingSignal:
            return _QueryList(self._pendings)
        if Model is tm.Trade:
            # raramente consultado em testes; devolve vazio
            return _QueryList([])
        if Model is tm.SignalForApproval:
            return _QueryList([])
        return _QueryList([])
    def add(self, obj):
        self.added.append(obj)
        # se for PendingSignal "persistido", tambÃ©m aparece em consultas subsequentes
        if isinstance(obj, tm.PendingSignal) or getattr(obj, "__class__", None).__name__ == "DummyPending":
            self._pendings.append(obj)
    def delete(self, obj):
        self.deleted.append(obj)
        if obj in self._pendings:
            self._pendings.remove(obj)
    def commit(self):
        self.commits += 1
    def close(self):
        self.closed = True

class FakeBot:
    def __init__(self):
        self.sent = []
    async def send_message(self, **kwargs):
        self.sent.append(kwargs)

class FakeApplication(Application):
    def __init__(self):
        super().__init__()
        self.bot = FakeBot()


# ===========================
# Textos de sinais
# ===========================
MARKET_SIGNAL = textwrap.dedent("""
ğŸ #39170 - Ordem Ã  Mercado

ğŸ’ Moeda: AVAX
ğŸ“Š Tipo: SHORT (Futures)

ğŸ’° Zona de Entrada: 22.85000000 - 22.85000000
ğŸ›‘ Stop Loss: 24.22000000
Alvos:
T1: 22.69000000
T2: 22.55000000
""")

LIMIT_SIGNAL_SHORT = textwrap.dedent("""
â³ #38792 - Ordem Limite

ğŸ’ Moeda: CYBER
ğŸ“Š Tipo: SHORT (Futures)

ğŸ’° Zona de Entrada: 2.52500000 - 2.64000000
ğŸ›‘ Stop Loss: 2.90000000
Alvos:
T1: 2.44000000
T2: 2.37000000
T3: 2.29000000
T4: 2.20000000
""")

LIMIT_SIGNAL_LONG = textwrap.dedent("""
â³ #50001 - Ordem Limite

ğŸ’ Moeda: XRP
ğŸ“Š Tipo: LONG (Futures)

ğŸ’° Zona de Entrada: 0.4500 - 0.4510
ğŸ›‘ Stop Loss: 0.4400
Alvos:
T1: 0.4600
T2: 0.4700
""")

CANCEL_SIGNAL_XRP = "âš ï¸ XRP sinal cancelado"


# ===========================
# TESTES
# ===========================
@pytest.mark.asyncio
async def test_market_flow_calls_place_order(monkeypatch):
    parsed = parse_signal(MARKET_SIGNAL)
    assert parsed and parsed["type"] == SignalType.MARKET

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=999)])

    class DummyTrade:
        def __init__(self, **kwargs):
            self.kwargs = kwargs

    called = {}
    async def fake_place_order(api_key, api_secret, signal_data, user, balance):
        called["api_key"] = api_key
        called["api_secret"] = api_secret
        called["signal_data"] = signal_data
        called["user_id"] = user.telegram_id
        called["balance"] = balance
        return {"success": True, "data": {"orderId": "fake-123", "qty": "1.0"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "100.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_order", fake_place_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "Trade", DummyTrade)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # ValidaÃ§Ãµes
    assert called, "place_order nÃ£o foi chamado"
    assert called["user_id"] == 999
    assert called["signal_data"]["coin"] == "AVAXUSDT"
    assert called["signal_data"]["order_type"] == "SHORT"
    assert called["signal_data"]["entries"][0] == pytest.approx(22.85, rel=1e-6)
    assert called["signal_data"]["stop_loss"] == pytest.approx(24.22, rel=1e-6)
    assert called["balance"] == 100.0

    # Mensagem ao usuÃ¡rio
    assert app.bot.sent, "Nenhuma mensagem foi enviada"
    texts = [m.get("text", "").lower() for m in app.bot.sent]
    assert any(("ordem" in t) or ("aberta" in t) or ("sucesso" in t) for t in texts), texts


@pytest.mark.asyncio
async def test_limit_short_creates_pending_and_uses_upper_bound(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_SHORT)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "SHORT"

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=777)])

    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    called = {"market": False, "limit": None}

    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        called["limit"] = dict(signal_data)  # capturar signal_data com limit_price
        return {"success": True, "data": {"orderId": "LIM-001"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "50.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_order", fake_place_order)  # nÃ£o deve ser chamado
    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # NÃ£o deve ter chamado market
    assert not called["market"], "LIMIT (SHORT) nÃ£o deve abrir ordem a mercado"
    # Deve ter chamado limit com limit_price == high (2.64000000)
    assert called["limit"] and called["limit"].get("limit_price") == pytest.approx(2.64, rel=1e-6)
    # Deve ter criado PendingSignal e avisado usuÃ¡rio
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal nÃ£o criado"
    assert app.bot.sent, "Sem mensagem de confirmaÃ§Ã£o ao usuÃ¡rio"


@pytest.mark.asyncio
async def test_limit_long_uses_lower_bound(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_LONG)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "LONG"

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=888)])

    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    called = {"limit": None}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        called["limit"] = dict(signal_data)
        return {"success": True, "data": {"orderId": "LIM-002"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "80.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    assert called["limit"] is not None, "place_limit_order nÃ£o foi chamado"
    assert called["limit"]["limit_price"] == pytest.approx(0.4500, rel=1e-6), "LONG deve usar menor preÃ§o da faixa"
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal nÃ£o criado"
    assert app.bot.sent, "Sem mensagem ao usuÃ¡rio"


@pytest.mark.asyncio
async def test_limit_skips_when_existing_pending(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_LONG)
    assert parsed and parsed["type"] == SignalType.LIMIT

    app = FakeApplication()

    class DummyPending:
        def __init__(self, user_telegram_id, symbol, order_id="old", signal_data=None):
            self.user_telegram_id = user_telegram_id
            self.symbol = symbol
            self.order_id = order_id
            self.signal_data = signal_data or {}

    # jÃ¡ existe um pendente para o mesmo sÃ­mbolo e usuÃ¡rio
    existing = DummyPending(user_telegram_id=777, symbol="XRPUSDT")
    db = FakeDB(users=[FakeUser(telegram_id=777)], pendings=[existing])

    called = {"limit": False}
    async def fake_place_limit_order(*a, **k):
        called["limit"] = True
        return {"success": True}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")
    async def fake_get_account_info(api_key, api_secret): return {"success": True, "data": [{"totalEquity": "10"}]}

    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # nÃ£o deve chamar place_limit_order
    assert not called["limit"], "NÃ£o deveria tentar posicionar nova LIMIT com pendente existente"
    # deve ter avisado usuÃ¡rio
    assert app.bot.sent and any("jÃ¡ tem uma ordem limite pendente" in (m.get("text","")) for m in app.bot.sent)


@pytest.mark.asyncio
async def test_cancel_removes_pending_and_notifies(monkeypatch):
    # preparar db com pending XRP para user 123
    class DummyPending:
        def __init__(self, user_telegram_id, symbol, order_id="LIM-XYZ", signal_data=None):
            self.user_telegram_id = user_telegram_id
            self.symbol = symbol
            self.order_id = order_id
            self.signal_data = signal_data or {}

    pend = DummyPending(user_telegram_id=123, symbol="XRPUSDT")
    users = [FakeUser(telegram_id=123)]
    base_db = FakeDB(users=users, pendings=[pend])

    # monkeypatch SessionLocal para devolver nosso FakeDB
    def fake_SessionLocal():
        # devolve uma "nova" instÃ¢ncia por chamada, clonando o estado base
        return FakeDB(users=list(base_db._users), pendings=list(base_db._pendings))

    app = FakeApplication()

    async def fake_cancel_order(api_key, api_secret, order_id, symbol):
        return {"success": True}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "SessionLocal", fake_SessionLocal)
    monkeypatch.setattr(tm, "cancel_order", fake_cancel_order)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)

    parsed_cancel = parse_signal(CANCEL_SIGNAL_XRP)
    assert parsed_cancel and parsed_cancel["type"] == SignalType.CANCELAR

    await tm.process_new_signal(parsed_cancel, app, source_name="TEST-CHANNEL")

    # Como usamos uma instÃ¢ncia nova de FakeDB dentro do process, nÃ£o temos referÃªncia direta
    # mas podemos validar pelo envio de mensagem de sucesso
    assert app.bot.sent and any("foi cancelada com sucesso" in (m.get("text","").lower()) for m in app.bot.sent)


@pytest.mark.asyncio
async def test_cancel_without_pending_sends_info_notification(monkeypatch):
    # DB sem pendentes
    base_db = FakeDB(users=[FakeUser(telegram_id=1)], pendings=[])
    def fake_SessionLocal():
        return FakeDB(users=list(base_db._users), pendings=list(base_db._pendings))

    app = FakeApplication()
    captured = {"msg": None}

    async def fake_send_notification(application, text):
        captured["msg"] = text

    monkeypatch.setattr(tm, "SessionLocal", fake_SessionLocal)
    monkeypatch.setattr(tm, "send_notification", fake_send_notification)

    parsed_cancel = parse_signal(CANCEL_SIGNAL_XRP)
    await tm.process_new_signal(parsed_cancel, app, source_name="TEST-CHANNEL")

    assert captured["msg"] is not None
    assert "nenhuma ordem pendente foi encontrada" in captured["msg"].lower()


@pytest.mark.asyncio
async def test_market_fails_on_balance_fetch(monkeypatch):
    parsed = parse_signal(MARKET_SIGNAL)
    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=321)])

    async def fake_get_account_info(api_key, api_secret):
        return {"success": False}  # falha

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    called = {"market": False}
    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "place_order", fake_place_order)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    assert not called["market"], "NÃ£o deve tentar abrir ordem sem saldo"
    assert app.bot.sent and any("falha ao buscar seu saldo bybit" in (m.get("text","").lower()) for m in app.bot.sent)


========================================
# Arquivo: utils/__init__.py
========================================



========================================
# Arquivo: utils/config.py
========================================

import os
from dotenv import load_dotenv

load_dotenv()

TELEGRAM_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
ENCRYPTION_KEY = os.getenv('ENCRYPTION_KEY')

API_ID = os.getenv('API_ID')
API_HASH = os.getenv('API_HASH')
ADMIN_ID = int(os.getenv('ADMIN_TELEGRAM_ID', 0)) # Converte para int

========================================
# Arquivo: utils/security.py
========================================

from cryptography.fernet import Fernet
from .config import ENCRYPTION_KEY

# Inicializa o 'cofre' com a sua chave
cipher_suite = Fernet(ENCRYPTION_KEY.encode())

def encrypt_data(data: str) -> str:
    """Criptografa um texto e retorna a versÃ£o em string."""
    if not data:
        return None
    encrypted_bytes = cipher_suite.encrypt(data.encode())
    return encrypted_bytes.decode()

def decrypt_data(encrypted_data: str) -> str:
    """Descriptografa um texto e retorna a versÃ£o original."""
    if not encrypted_data:
        return None
    decrypted_bytes = cipher_suite.decrypt(encrypted_data.encode())
    return decrypted_bytes.decode()

========================================
# Arquivo: scripts/create_invite.py
========================================

import sys
from database.session import SessionLocal, init_db
from database.models import InviteCode

def create_invite_code(code: str):
    db = SessionLocal()
    try:
        existing_code = db.query(InviteCode).filter(InviteCode.code == code).first()
        if existing_code:
            print(f"CÃ³digo '{code}' jÃ¡ existe.")
            return

        new_code = InviteCode(code=code)
        db.add(new_code)
        db.commit()
        print(f"CÃ³digo de convite '{code}' criado com sucesso!")
    finally:
        db.close()

if __name__ == "__main__":
    init_db()
    # Agora ele lÃª o cÃ³digo a partir do seu comando no terminal
    if len(sys.argv) > 1:
        code_to_create = sys.argv[1]
        create_invite_code(code_to_create)
    else:
        print("Erro: Por favor, forneÃ§a um cÃ³digo para criar. Exemplo: python create_invite.py MEU-CODIGO-NOVO")

========================================
# Arquivo: bot/__init__.py
========================================



========================================
# Arquivo: bot/handlers.py
========================================

import logging
import asyncio
import pytz
from database.models import PendingSignal
from services.signal_parser import SignalType
from services.bybit_service import place_limit_order, get_account_info
from datetime import datetime, time, timedelta 
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler
from telegram.error import BadRequest
from database.session import SessionLocal
from database.models import User, InviteCode, MonitoredTarget, Trade, SignalForApproval
from .keyboards import (
    main_menu_keyboard, confirm_remove_keyboard, admin_menu_keyboard, 
    dashboard_menu_keyboard, settings_menu_keyboard, view_targets_keyboard, 
    bot_config_keyboard, performance_menu_keyboard, confirm_manual_close_keyboard)
from utils.security import encrypt_data, decrypt_data
from services.bybit_service import (
    get_open_positions, 
    get_account_info, 
    close_partial_position, 
    get_open_positions_with_pnl,
    get_market_price
)
from utils.config import ADMIN_ID
from database.crud import get_user_by_id
from core.trade_manager import _execute_trade, _execute_limit_order_for_user
from core.performance_service import generate_performance_report
from core.trade_manager import execute_signal_for_all_users
from sqlalchemy.sql import func


# Estados para as conversas
(WAITING_CODE, WAITING_API_KEY, WAITING_API_SECRET, CONFIRM_REMOVE_API) = range(4)
(ASKING_ENTRY_PERCENT, ASKING_MAX_LEVERAGE, ASKING_MIN_CONFIDENCE) = range(10, 13)
(ASKING_PROFIT_TARGET, ASKING_LOSS_LIMIT) = range(13, 15)
ASKING_COIN_WHITELIST = 15

logger = logging.getLogger(__name__)

# --- FLUXO DE USUÃRIO (START, CADASTRO, MENUS) ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    telegram_user = update.effective_user
    user_in_db = get_user_by_id(telegram_user.id)
    if user_in_db:
        await update.message.reply_text(
            "Menu Principal:",
            reply_markup=main_menu_keyboard(telegram_id=telegram_user.id)
        )
        return ConversationHandler.END
    else:
        await update.message.reply_text(
            f"OlÃ¡, {telegram_user.first_name}! Para usar o TradeFlow, insira seu cÃ³digo de convite."
        )
        return WAITING_CODE

async def receive_invite_code(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    code_text = update.message.text
    telegram_user = update.effective_user
    db = SessionLocal()
    try:
        invite_code = db.query(InviteCode).filter(InviteCode.code == code_text, InviteCode.is_used == False).first()
        if invite_code:
            new_user = User(telegram_id=telegram_user.id, first_name=telegram_user.first_name)
            db.add(new_user)
            invite_code.is_used = True
            db.commit()
            await update.message.reply_text(
                "âœ… Cadastro realizado com sucesso! O prÃ³ximo passo Ã© configurar sua API.",
                reply_markup=main_menu_keyboard(telegram_id=telegram_user.id)
            )
            return ConversationHandler.END
        else:
            await update.message.reply_text("âŒ CÃ³digo de convite invÃ¡lido ou jÃ¡ utilizado. Tente novamente.")
            return WAITING_CODE
    finally:
        db.close()

async def back_to_main_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        "Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=update.effective_user.id)
    )

# --- FLUXO DE CONFIGURAÃ‡ÃƒO DE API ---
async def config_api(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Inicia o fluxo de configuraÃ§Ã£o de API com um tutorial melhorado."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['entry_message_id'] = query.message.message_id
    
    tutorial_text = (
        "ğŸ”‘ <b>Como Criar suas Chaves de API na Bybit</b> ğŸ”‘\n\n"
        "Siga estes passos com atenÃ§Ã£o para conectar sua conta:\n\n"
        "1ï¸âƒ£  FaÃ§a login em <b>Bybit.com</b> e vÃ¡ para <i>Perfil > API</i>.\n\n"
        "2ï¸âƒ£  Clique em <b>'Criar Nova Chave'</b> e selecione <i>'Chaves Geradas pelo Sistema'</i>.\n\n"
        "3ï¸âƒ£  DÃª um nome para sua chave (ex: `TradeFlowBot`) e selecione as permissÃµes de <b>'Leitura e Escrita'</b>.\n\n"
        "4ï¸âƒ£  Nas permissÃµes, marque <b>APENAS</b> as seguintes caixas:\n"
        "   - <b>Contrato</b> (`Contract`): âœ… `Ordens` e âœ… `PosiÃ§Ãµes`\n"
        "   - <b>Trading Unificado</b> (`UTA`): âœ… `Trade`\n\n"
        "5ï¸âƒ£  ğŸ›¡ï¸ <b>MUITO IMPORTANTE:</b> Por seguranÃ§a, <b>NÃƒO</b> marque a permissÃ£o de <i>'Saque' (Withdraw)</i>.\n\n"
        "âš ï¸ <b>AtenÃ§Ã£o:</b> Este bot opera exclusivamente com pares de trade terminados em **USDT**.\n\n"
        "6ï¸âƒ£  Conclua a verificaÃ§Ã£o de seguranÃ§a e copie sua <b>API Key</b> e <b>API Secret</b>.\n\n"
        "-------------------------------------\n"
        "Pronto! Agora, por favor, envie sua <b>API Key</b>."
    )
    
    await query.edit_message_text(
        text=tutorial_text,
        parse_mode='HTML'
    )
    return WAITING_API_KEY

async def receive_api_key(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe a API Key, apaga a mensagem do usuÃ¡rio e pede a API Secret."""
    await context.bot.delete_message(
        chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    api_key = update.message.text
    context.user_data['api_key'] = api_key
    
    prompt_message = await update.message.reply_text(
        "Chave API recebida com seguranÃ§a. Agora, por favor, envie sua *API Secret*.",
        parse_mode='Markdown'
    )
    context.user_data['prompt_message_id'] = prompt_message.message_id
    
    return WAITING_API_SECRET

async def receive_api_secret(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe a API Secret, apaga as mensagens, criptografa e salva no banco."""
    await context.bot.delete_message(
        chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    prompt_message_id = context.user_data.get('prompt_message_id')
    if prompt_message_id:
        await context.bot.delete_message(
            chat_id=update.effective_chat.id,
            message_id=prompt_message_id
        )

    api_secret = update.message.text
    api_key = context.user_data.get('api_key')
    telegram_id = update.effective_user.id

    encrypted_key = encrypt_data(api_key)
    encrypted_secret = encrypt_data(api_secret)

    db = SessionLocal()
    try:
        user_to_update = db.query(User).filter(User.telegram_id == telegram_id).first()
        if user_to_update:
            user_to_update.api_key_encrypted = encrypted_key
            user_to_update.api_secret_encrypted = encrypted_secret
            db.commit()
            
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=context.user_data['entry_message_id'],
                text="âœ… Suas chaves de API foram salvas com sucesso!",
            )
            await context.bot.send_message(
                chat_id=telegram_id,
                text="Menu Principal:",
                reply_markup=main_menu_keyboard(telegram_id=telegram_id)
            )
        else:
            await update.message.reply_text("Ocorreu um erro. UsuÃ¡rio nÃ£o encontrado.")
    finally:
        db.close()
        context.user_data.clear()

    return ConversationHandler.END

# --- FLUXO DE REMOÃ‡ÃƒO DE API ---
async def remove_api_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        text="âš ï¸ VocÃª tem certeza que deseja remover suas chaves de API?",
        reply_markup=confirm_remove_keyboard()
    )
    return CONFIRM_REMOVE_API

async def remove_api_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id

    if query.data == 'remove_api_confirm':
        db = SessionLocal()
        try:
            user_to_update = db.query(User).filter(User.telegram_id == telegram_id).first()
            if user_to_update:
                user_to_update.api_key_encrypted = None
                user_to_update.api_secret_encrypted = None
                db.commit()
            await query.edit_message_text("âœ… Suas chaves de API foram removidas.")
        finally:
            db.close()
    else: # Cancelou
        await query.edit_message_text("OperaÃ§Ã£o cancelada.")

    await context.bot.send_message(
        chat_id=telegram_id,
        text="Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=telegram_id)
    )
    return ConversationHandler.END

# --- PAINÃ‰IS DO USUÃRIO ---
async def my_positions_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("Buscando suas posiÃ§Ãµes gerenciadas...")

    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if not user or not user.api_key_encrypted:
            await query.edit_message_text("VocÃª ainda nÃ£o configurou suas chaves de API.")
            return

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # Busca as posiÃ§Ãµes ativas que o bot estÃ¡ gerenciando no nosso DB
        active_trades = db.query(Trade).filter(
            Trade.user_telegram_id == user_id,
            ~Trade.status.like('%CLOSED%')
        ).all()

        if not active_trades:
            await query.edit_message_text(
                "<b>ğŸ“Š Suas PosiÃ§Ãµes Ativas</b>\n\nNenhuma posiÃ§Ã£o sendo gerenciada no momento.",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("â¬…ï¸ Voltar ao Menu", callback_data='back_to_main_menu')]])
            )
            return

        # Busca os dados ao vivo (P/L) da Bybit para essas posiÃ§Ãµes
        live_pnl_data = {}
        live_positions_result = await get_open_positions_with_pnl(api_key, api_secret)
        if live_positions_result.get("success"):
            for pos in live_positions_result.get("data", []):
                live_pnl_data[pos["symbol"]] = pos

        lines = ["<b>ğŸ“Š Suas PosiÃ§Ãµes Ativas (Gerenciadas pelo Bot)</b>", ""]
        keyboard = []

        for trade in active_trades:
            arrow = "â¬†ï¸" if trade.side == "LONG" else "â¬‡ï¸"
            pnl_info = ""
            
            # Adiciona os dados de P/L ao vivo, se disponÃ­veis
            if trade.symbol in live_pnl_data:
                live_data = live_pnl_data[trade.symbol]
                pnl = live_data["unrealized_pnl"]
                pnl_pct = live_data["unrealized_pnl_pct"]
                mark_price = live_data["mark"]
                pnl_info = (
                    f"  PreÃ§o Atual: ${mark_price:,.4f}\n"
                    f"  P/L: <b>{pnl:+.2f} USDT ({pnl_pct:+.2f}%)</b>\n"
                )
            else:
                pnl_info = f"  Status: {trade.status}\n"

            # --- NOVA LÃ“GICA PARA EXIBIR ALVOS ---
            targets_info = ""
            if trade.initial_targets:
                next_target = trade.initial_targets[0]
                remaining_count = len(trade.initial_targets)
                targets_info = f"  ğŸ¯ PrÃ³ximo Alvo: ${next_target:,.4f} ({remaining_count} restantes)\n"

            lines.append(
                f"- {arrow} <b>{trade.symbol}</b> ({trade.qty:g} unid.)\n"
                f"  Entrada: ${trade.entry_price:.4f}\n"
                f"{pnl_info}"
                f"{targets_info}"
            )

            keyboard.append([
                InlineKeyboardButton(f"Fechar {trade.symbol} âŒ", callback_data=f"confirm_close_{trade.id}")
            ])

        keyboard.append([InlineKeyboardButton("â¬…ï¸ Voltar ao Menu", callback_data='back_to_main_menu')])
        await query.edit_message_text(
            "\n".join(lines),
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    finally:
        db.close()

async def user_dashboard_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o painel financeiro com um resumo visual e completo dos saldos da carteira."""
    query = update.callback_query
    try:
        await query.answer()
    except BadRequest as e:
        logger.warning(f"NÃ£o foi possÃ­vel responder ao callback_query (pode ser antigo): {e}")
        return

    await query.edit_message_text("Buscando informaÃ§Ãµes do painel...")
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = get_user_by_id(user_id)
        if not user or not user.api_key_encrypted:
            await query.edit_message_text("VocÃª precisa configurar sua API primeiro.", reply_markup=main_menu_keyboard(telegram_id=user_id))
            return

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        account_info = await get_account_info(api_key, api_secret)

        message = "<b>Meu Painel Financeiro</b> ğŸ“Š\n\n"
        
        if account_info.get("success"):
            balance_data = account_info.get("data", {})
            total_equity = balance_data.get("total_equity", 0.0)
            
            message += f"ğŸ’° <b>PatrimÃ´nio Total:</b> ${total_equity:,.2f} USDT\n\n"
            message += "<b>Saldos em Carteira:</b>\n"

            coin_list = balance_data.get("coin_list", [])
            wallet_lines = []
            usdt_found = False

            if coin_list:
                for c in coin_list:
                    coin = (c.get("coin") or "").upper()
                    wallet_balance_str = c.get("walletBalance")
                    wallet_balance = float(wallet_balance_str) if wallet_balance_str else 0.0

                    # Exibe apenas moedas com saldo significativo
                    if wallet_balance > 0.00001:
                        if coin == "USDT":
                            wallet_lines.append(f"  - <b>{coin}: {wallet_balance:,.2f}</b>")
                            usdt_found = True
                        else:
                            wallet_lines.append(f"  - {coin}: {wallet_balance:g}")
            
            if wallet_lines:
                message += "\n".join(wallet_lines)
            else:
                message += "Nenhum saldo encontrado.\n"
            
        else:
            message += f"âŒ Erro ao buscar saldo: {account_info.get('error')}\n"

        message += "\n\nâš ï¸ <i>Este bot opera exclusivamente com pares USDT.</i>"

        await query.edit_message_text(message, parse_mode="HTML", reply_markup=dashboard_menu_keyboard())

    except Exception as e:
        logger.error(f"Erro ao montar o painel do usuÃ¡rio: {e}", exc_info=True)
        await query.edit_message_text("Ocorreu um erro ao buscar os dados do seu painel.")
    finally:
        db.close()

# --- CANCELAMENTO ---
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancela a operaÃ§Ã£o atual."""
    await update.message.reply_text("OperaÃ§Ã£o cancelada.")
    return ConversationHandler.END

# --- FLUXO DE ADMINISTRAÃ‡ÃƒO ---
async def admin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra o menu de administrador, se o usuÃ¡rio for o admin."""
    user_id = update.effective_user.id
    if user_id != ADMIN_ID:
        await update.message.reply_text("VocÃª nÃ£o tem permissÃ£o para usar este comando.")
        return

    await update.message.reply_text(
        "Bem-vindo ao painel de administraÃ§Ã£o.",
        reply_markup=admin_menu_keyboard()
    )


async def admin_view_targets_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Busca e exibe a lista de todos os canais e tÃ³picos sendo monitorados."""
    query = update.callback_query
    await query.answer()
    
    db = SessionLocal()
    try:
        targets = db.query(MonitoredTarget).all()
        
        message = "<b>ğŸ‘ï¸ Alvos Atualmente Monitorados</b>\n\n"
        
        if targets:
            for target in targets:
                if target.topic_name:
                    message += f"- <b>Grupo:</b> {target.channel_name}\n  - <b>TÃ³pico:</b> {target.topic_name}\n"
                else:
                    message += f"- <b>Canal:</b> {target.channel_name}\n"
        else:
            message += "Nenhum alvo sendo monitorado no momento."
            
        await query.edit_message_text(
            text=message,
            parse_mode='HTML',
            reply_markup=view_targets_keyboard()
        )
    finally:
        db.close()

async def back_to_admin_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usuÃ¡rio para o menu de administraÃ§Ã£o principal."""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        "Bem-vindo ao painel de administraÃ§Ã£o.",
        reply_markup=admin_menu_keyboard()
    )

async def list_channels_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Coloca um pedido na fila para listar os grupos e canais do usuÃ¡rio."""
    query = update.callback_query
    await query.answer()
    
    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue:
        await query.edit_message_text("Erro: Fila de comunicaÃ§Ã£o nÃ£o encontrada.")
        return
    
    request_data = {
        "action": "list_channels",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
    }
    
    await comm_queue.put(request_data)
    
    await query.edit_message_text("Buscando sua lista de canais... Se vocÃª tiver muitos grupos, isso pode levar atÃ© um minuto. Por favor, aguarde.")
    
async def select_channel_to_monitor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Coloca um pedido na fila para listar tÃ³picos (ou gerenciar um canal plano)."""
    query = update.callback_query
    await query.answer()
    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue: return

    user_id = update.effective_user.id
    if user_id != ADMIN_ID: return

    channel_id = int(query.data.split('_')[-1])
    
    channel_name = ""
    for row in query.message.reply_markup.inline_keyboard:
        for button in row:
            if button.callback_data == query.data:
                channel_name = button.text.replace(" âœ…", "")
                break

    request_data = {
        "action": "list_topics",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
        "channel_id": channel_id,
        "channel_name": channel_name
    }
    
    await comm_queue.put(request_data)
    await query.edit_message_text("Processando...")

async def select_topic_to_monitor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Salva/remove o tÃ³pico e pede para a fila recarregar o menu de tÃ³picos."""
    query = update.callback_query
    await query.answer() 

    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue:
        logger.error("Fila de comunicaÃ§Ã£o nÃ£o encontrada no contexto do bot.")
        return

    user_id = update.effective_user.id
    if user_id != ADMIN_ID: return

    _, _, channel_id_str, topic_id_str = query.data.split('_')
    channel_id = int(channel_id_str)
    topic_id = int(topic_id_str)
    
    db = SessionLocal()
    try:
        existing_target = db.query(MonitoredTarget).filter_by(channel_id=channel_id, topic_id=topic_id).first()
        
        if existing_target:
            db.delete(existing_target)
        else:
            topic_name = ""
            for row in query.message.reply_markup.inline_keyboard:
                for button in row:
                    if button.callback_data == query.data:
                        topic_name = button.text.replace(" âœ…", "")
                        break
            new_target = MonitoredTarget(channel_id=channel_id, topic_id=topic_id, topic_name=topic_name)
            db.add(new_target)
        
        db.commit()
    finally:
        db.close()

    request_data = {
        "action": "list_topics",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
        "channel_id": channel_id,
        "channel_name": ""
    }
    await comm_queue.put(request_data)

async def back_to_channels_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usuÃ¡rio para a lista de canais/grupos."""
    await list_channels_handler(update, context)

# --- FUNÃ‡Ã•ES DUPLICADAS REMOVIDAS PARA LIMPEZA ---
# my_dashboard_handler, my_positions_handler, back_to_main_menu_handler
# jÃ¡ estavam definidas acima.

async def user_settings_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de configuraÃ§Ãµes de trade com os valores atuais do usuÃ¡rio."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            await query.edit_message_text(
                "<b>âš™ï¸ ConfiguraÃ§Ãµes de Trade</b>\n\n"
                "Aqui vocÃª pode definir seus parÃ¢metros de risco e automaÃ§Ã£o.",
                parse_mode='HTML',
                reply_markup=settings_menu_keyboard(user)
            )
    finally:
        db.close()

async def ask_entry_percent(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuÃ¡rio qual a nova porcentagem da banca por entrada."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie a porcentagem da sua banca em USDT que vocÃª deseja usar para cada entrada.\n\n"
        "Exemplo: se vocÃª tem $100 e define `10`, cada entrada terÃ¡ o valor de $10.\n"
        "Envie apenas o nÃºmero (ex: `10` para 10%)."
    )
    return ASKING_ENTRY_PERCENT

async def receive_entry_percent(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova porcentagem de entrada."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        percent_value = float(update.message.text.replace(',', '.'))
        if not (0.1 <= percent_value <= 100):
            raise ValueError("Valor fora do range permitido (0.1 a 100)")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.entry_size_percent = percent_value
            db.commit()
            
            api_key = decrypt_data(user.api_key_encrypted)
            api_secret = decrypt_data(user.api_secret_encrypted)
            account_info = await get_account_info(api_key, api_secret)
            
            usdt_balance = 0.0
            if account_info.get("success"):
                balances = account_info.get("data", [])
                if balances:
                    coin_list = balances[0].get('coin', [])
                    for coin in coin_list:
                        if coin.get('coin') == 'USDT':
                            usdt_balance = float(coin.get('walletBalance', 0))
                            break
            
            entry_value = usdt_balance * (percent_value / 100)
            
            feedback_text = (
                f"âœ… Tamanho da entrada atualizado para <b>{percent_value:.2f}%</b>.\n\n"
                f"Com seu saldo atual, cada entrada serÃ¡ de aprox. <b>${entry_value:,.2f} USDT</b>."
            )

            if percent_value > 25:
                feedback_text += "\n\nâš ï¸ <b>AtenÃ§Ã£o:</b> Uma porcentagem acima de 25% Ã© considerada de altÃ­ssimo risco!"

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=feedback_text,
                parse_mode='HTML',
                reply_markup=settings_menu_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="âŒ Valor invÃ¡lido. Por favor, tente novamente com um nÃºmero entre 0.1 e 100 (ex: 10)."
        )
        return ASKING_ENTRY_PERCENT

    return ConversationHandler.END        

async def ask_max_leverage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuÃ¡rio qual a nova alavancagem mÃ¡xima."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Qual a alavancagem mÃ¡xima que o bot deve usar?\n"
        "Envie apenas o nÃºmero (ex: `10` para 10x)."
    )
    return ASKING_MAX_LEVERAGE

async def receive_max_leverage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova alavancagem mÃ¡xima."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    try:
        leverage_value = int(update.message.text)
        if not (1 <= leverage_value <= 125):
            raise ValueError("Alavancagem fora do limite (1-125)")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.max_leverage = leverage_value
            db.commit()
            
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"âœ… Alavancagem mÃ¡xima atualizada para {leverage_value}x.\n\n"
                     "Selecione outra opÃ§Ã£o para editar ou volte.",
                reply_markup=settings_menu_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="âŒ Valor invÃ¡lido. Por favor, tente novamente com um nÃºmero inteiro (ex: 10)."
        )
        return ASKING_MAX_LEVERAGE
    finally:
        await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    return ConversationHandler.END

async def ask_min_confidence(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuÃ¡rio qual o novo valor de confianÃ§a mÃ­nima."""
    query = update.callback_query
    await query.answer()
    context.user_data['settings_message_id'] = query.message.message_id
    await query.edit_message_text("Envie o valor da confianÃ§a mÃ­nima da IA (ex: 75 para 75%).\nSinais com confianÃ§a abaixo disso serÃ£o ignorados.")
    return ASKING_MIN_CONFIDENCE

async def receive_min_confidence(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva o novo valor de confianÃ§a."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        confidence_value = float(update.message.text.replace(',', '.'))
        if not (0 <= confidence_value <= 100):
            raise ValueError("Valor fora do range permitido (0-100)")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.min_confidence = confidence_value
            db.commit()
            
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"âœ… ConfianÃ§a mÃ­nima atualizada para {confidence_value:.2f}%.\n\n"
                     "Selecione outra opÃ§Ã£o para editar ou volte.",
                reply_markup=settings_menu_keyboard(user)
            )
        finally:
            db.close()

        return ConversationHandler.END

    except (ValueError, TypeError):
        logger.warning(f"UsuÃ¡rio {user_id} enviou um valor invÃ¡lido para confianÃ§a: {update.message.text}")
        
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="âŒ <b>Valor invÃ¡lido.</b>\nPor favor, envie apenas um nÃºmero entre 0 e 100 (ex: 75).",
            parse_mode='HTML'
        )
        
        return ASKING_MIN_CONFIDENCE
    
async def execute_manual_close_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Lida com a EXECUÃ‡ÃƒO do fechamento manual apÃ³s a confirmaÃ§Ã£o."""
    query = update.callback_query
    await query.answer("Processando fechamento...")

    # O callback_data agora serÃ¡ 'execute_close_123'
    trade_id = int(query.data.split('_')[-1])
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        trade_to_close = db.query(Trade).filter_by(id=trade_id, user_telegram_id=user_id).first()

        if not trade_to_close:
            await query.edit_message_text("Erro: Trade nÃ£o encontrado ou jÃ¡ fechado.")
            return

        user = db.query(User).filter_by(telegram_id=user_id).first()
        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        price_result = await get_market_price(trade_to_close.symbol)
        current_price = price_result["price"] if price_result.get("success") else trade_to_close.entry_price

        close_result = await close_partial_position(
            api_key, api_secret, 
            trade_to_close.symbol, 
            trade_to_close.remaining_qty, 
            trade_to_close.side
        )

        if close_result.get("success"):
            pnl = (current_price - trade_to_close.entry_price) * trade_to_close.remaining_qty if trade_to_close.side == 'LONG' else (trade_to_close.entry_price - current_price) * trade_to_close.remaining_qty
            
            trade_to_close.status = 'CLOSED_MANUAL'
            trade_to_close.closed_at = func.now()
            trade_to_close.closed_pnl = pnl
            db.commit()

            resultado_str = "LUCRO" if pnl >= 0 else "PREJUÃZO"
            emoji = "âœ…" if pnl >= 0 else "ğŸ”»"
            message_text = (
                f"{emoji} <b>PosiÃ§Ã£o Fechada Manualmente ({resultado_str})</b>\n"
                f"<b>Moeda:</b> {trade_to_close.symbol}\n"
                f"<b>Resultado:</b> ${pnl:,.2f}"
            )
            
            await query.edit_message_text(message_text, parse_mode='HTML')
            await asyncio.sleep(2)
            await my_positions_handler(update, context)
        else:
            error_msg = close_result.get('error')
            await context.bot.send_message(
                chat_id=user_id,
                text=f"âŒ Erro ao fechar a posiÃ§Ã£o para {trade_to_close.symbol}: {error_msg}"
            )
    finally:
        db.close()


async def bot_config_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de configuraÃ§Ã£o do bot com o modo de aprovaÃ§Ã£o atual."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    db = SessionLocal()
    try:
        user = get_user_by_id(user_id)
        if user:
            await query.edit_message_text(
                "<b>ğŸ¤– ConfiguraÃ§Ã£o do Bot</b>\n\n"
                "Ajuste o comportamento geral do bot.",
                parse_mode='HTML',
                reply_markup=bot_config_keyboard(user)
            )
    finally:
        db.close()

async def toggle_approval_mode_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Alterna o modo de aprovaÃ§Ã£o de ordens entre Manual e AutomÃ¡tico."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == user_id).first()
        
        if user:
            if user.approval_mode == 'AUTOMATIC':
                user.approval_mode = 'MANUAL'
            else:
                user.approval_mode = 'AUTOMATIC'
            
            db.commit() 
            
            try:
                await query.edit_message_text(
                    "<b>ğŸ¤– ConfiguraÃ§Ã£o do Bot</b>\n\n"
                    "Ajuste o comportamento geral do bot.",
                    parse_mode='HTML',
                    reply_markup=bot_config_keyboard(user)
                )
            except BadRequest as e:
                if "Message is not modified" in str(e):
                    pass
                else:
                    logger.error(f"Erro ao editar mensagem em toggle_approval_mode: {e}")
    finally:
        db.close()

async def handle_signal_approval(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Lida com a aprovaÃ§Ã£o ou rejeiÃ§Ã£o de um sinal por um usuÃ¡rio especÃ­fico."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id

    action, _, signal_id_str = query.data.partition('_signal_')
    signal_id = int(signal_id_str)
    
    db = SessionLocal()
    try:
        # Busca o sinal pendente para ESTE usuÃ¡rio especÃ­fico
        signal_to_process = db.query(SignalForApproval).filter_by(id=signal_id, user_telegram_id=user_id).first()
        if not signal_to_process:
            await query.edit_message_text("Este sinal jÃ¡ foi processado ou expirou.")
            return

        user = db.query(User).filter_by(telegram_id=user_id).first()
        signal_data = signal_to_process.signal_data
        
        if action == 'approve':
            await query.edit_message_text("âœ… **Entrada Aprovada!** Posicionando sua ordem...")
            
            # Executa o trade apenas para este usuÃ¡rio
            if signal_data.get("type") == SignalType.MARKET:
                await _execute_trade(signal_data, user, context.application, db, signal_to_process.source_name)
            elif signal_data.get("type") == SignalType.LIMIT:
                await _execute_limit_order_for_user(signal_data, user, context.application, db)
            
        elif action == 'reject':
            await query.edit_message_text("âŒ **Entrada Rejeitada.** O sinal foi descartado.")
        
        db.delete(signal_to_process)
        db.commit()
    finally:
        db.close()

# --- FLUXO DE CONFIGURAÃ‡ÃƒO DE METAS DIÃRIAS ---

async def ask_profit_target(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuÃ¡rio a nova meta de lucro diÃ¡rio."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie a sua meta de **lucro diÃ¡rio** em USDT.\n"
        "O bot irÃ¡ parar de abrir novas ordens quando o lucro do dia atingir este valor.\n\n"
        "Envie apenas o nÃºmero (ex: `100` para $100) ou `0` para desativar.",
        parse_mode='Markdown'
    )
    return ASKING_PROFIT_TARGET

async def receive_profit_target(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova meta de lucro."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        target_value = float(update.message.text.replace(',', '.'))
        if target_value < 0:
            raise ValueError("Valor nÃ£o pode ser negativo")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.daily_profit_target = target_value
            db.commit()
            
            feedback_text = f"âœ… Meta de lucro diÃ¡rio atualizada para ${target_value:.2f}."
            if target_value == 0:
                feedback_text = "âœ… Meta de lucro diÃ¡rio foi desativada."

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"{feedback_text}\n\nAjuste outra configuraÃ§Ã£o ou volte.",
                reply_markup=bot_config_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="âŒ Valor invÃ¡lido. Por favor, tente novamente com um nÃºmero (ex: 100)."
        )
        return ASKING_PROFIT_TARGET

    return ConversationHandler.END

async def ask_loss_limit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuÃ¡rio o novo limite de perda diÃ¡rio."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie o seu limite de **perda diÃ¡ria** em USDT.\n"
        "O bot irÃ¡ parar de abrir novas ordens se a perda do dia atingir este valor.\n\n"
        "Envie um nÃºmero positivo (ex: `50` para um limite de $50) ou `0` para desativar.",
        parse_mode='Markdown'
    )
    return ASKING_LOSS_LIMIT

async def receive_loss_limit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva o novo limite de perda."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        limit_value = float(update.message.text.replace(',', '.'))
        if limit_value < 0:
            raise ValueError("Valor nÃ£o pode ser negativo")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.daily_loss_limit = limit_value
            db.commit()

            feedback_text = f"âœ… Limite de perda diÃ¡rio atualizado para ${limit_value:.2f}."
            if limit_value == 0:
                feedback_text = "âœ… Limite de perda diÃ¡rio foi desativado."

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"{feedback_text}\n\nAjuste outra configuraÃ§Ã£o ou volte.",
                reply_markup=bot_config_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="âŒ Valor invÃ¡lido. Por favor, tente novamente com um nÃºmero positivo (ex: 50)."
        )
        return ASKING_LOSS_LIMIT

    return ConversationHandler.END

# --- MENU DE DESEMPENHO ---

async def performance_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o painel de desempenho e lida com a seleÃ§Ã£o de perÃ­odo, usando o fuso horÃ¡rio de SP."""
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id
    
    # --- LÃ“GICA DE FUSO HORÃRIO CORRIGIDA ---
    br_timezone = pytz.timezone("America/Sao_Paulo")
    now_br = datetime.now(br_timezone)
    
    callback_data = query.data
    start_dt, end_dt = None, None

    if callback_data == 'perf_today':
        start_dt = now_br.replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt = now_br
    elif callback_data == 'perf_yesterday':
        yesterday = now_br.date() - timedelta(days=1)
        start_dt = br_timezone.localize(datetime.combine(yesterday, time.min))
        end_dt = br_timezone.localize(datetime.combine(yesterday, time.max))
    elif callback_data == 'perf_7_days':
        start_dt = (now_br - timedelta(days=6)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt = now_br
    elif callback_data == 'perf_30_days':
        start_dt = (now_br - timedelta(days=29)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt = now_br

    if start_dt and end_dt:
        await query.edit_message_text(
            text="â³ Calculando desempenho para o perÃ­odo selecionado...",
            reply_markup=performance_menu_keyboard()
        )
        
        report_text = await generate_performance_report(user_id, start_dt, end_dt)
        
        await query.edit_message_text(
            text=report_text,
            parse_mode='HTML',
            reply_markup=performance_menu_keyboard()
        )

# --- FLUXO DE CONFIGURAÃ‡ÃƒO DE WHITELIST ---

async def ask_coin_whitelist(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuÃ¡rio sua nova whitelist de moedas."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        current_whitelist = user.coin_whitelist if user else 'todas'
    finally:
        db.close()

    instructions = (
        f"<b>âœ… Whitelist de Moedas</b>\n\n"
        f"Sua configuraÃ§Ã£o atual Ã©: <code>{current_whitelist}</code>\n\n"
        f"Envie uma lista de moedas e/ou categorias separadas por vÃ­rgula.\n\n"
        f"<b>Exemplos:</b>\n"
        f"â€¢ <code>todas</code> (para operar todos os sinais)\n"
        f"â€¢ <code>btcusdt, ethusdt, solusdt</code>\n"
        f"â€¢ <code>memecoins, btcusdt</code> (opera moedas meme + BTC)\n\n"
        f"<b>Categorias disponÃ­veis:</b> <code>memecoins</code>, <code>altcoins</code>, <code>defi</code>."
    )
    
    await query.edit_message_text(text=instructions, parse_mode='HTML')
    return ASKING_COIN_WHITELIST

async def receive_coin_whitelist(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova whitelist."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    
    # Apaga a mensagem do usuÃ¡rio para manter o chat limpo
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    # Normaliza a entrada: remove espaÃ§os extras e converte para minÃºsculas
    whitelist_text = update.message.text.lower().strip()
    
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            user.coin_whitelist = whitelist_text
            db.commit()
            
            feedback_text = (
                f"âœ… Whitelist de moedas atualizada para: <code>{whitelist_text}</code>"
            )

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=feedback_text,
                parse_mode='HTML',
                reply_markup=settings_menu_keyboard(user)
            )
    finally:
        db.close()

    return ConversationHandler.END

async def list_closed_trades_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Busca no DB e lista os Ãºltimos trades fechados do usuÃ¡rio."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    await query.edit_message_text("Buscando seu histÃ³rico de trades...")

    db = SessionLocal()
    try:
        # Busca os Ãºltimos 15 trades fechados, ordenados do mais recente para o mais antigo
        closed_trades = db.query(Trade).filter(
            Trade.user_telegram_id == user_id,
            Trade.status.like('%CLOSED%')
        ).order_by(Trade.closed_at.desc()).limit(15).all()

        message = "<b>ğŸ“œ Seus Ãšltimos Trades Fechados</b>\n\n"

        if not closed_trades:
            message += "Nenhum trade fechado encontrado no seu histÃ³rico."
        else:
            for trade in closed_trades:
                # Define o emoji e o texto do resultado com base no status e no P/L
                pnl = trade.closed_pnl if trade.closed_pnl is not None else 0.0
                resultado_str = f"<b>Resultado: ${pnl:,.2f}</b>"
                
                emoji = "â”"
                if trade.status == 'CLOSED_PROFIT':
                    emoji = "ğŸ†"
                elif trade.status == 'CLOSED_LOSS':
                    emoji = "ğŸ›‘"
                elif trade.status == 'CLOSED_MANUAL':
                    emoji = "âœ…" if pnl >= 0 else "ğŸ”»"
                elif trade.status == 'CLOSED_GHOST':
                    emoji = "â„¹ï¸"
                    resultado_str = "<i>Fechado externamente</i>"

                # Formata a data de fechamento
                data_fechamento = trade.closed_at.strftime('%d/%m %H:%M') if trade.closed_at else 'N/A'

                message += (
                    f"{emoji} <b>{trade.symbol}</b> ({trade.side})\n"
                    f"  - Fechado em: {data_fechamento}\n"
                    f"  - {resultado_str}\n\n"
                )
        
        # Cria um teclado com o botÃ£o para voltar ao menu de desempenho
        keyboard = [[InlineKeyboardButton("â¬…ï¸ Voltar ao Desempenho", callback_data='perf_today')]]
        
        await query.edit_message_text(
            text=message,
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    finally:
        db.close()

async def prompt_manual_close_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe a tela de confirmaÃ§Ã£o para o fechamento manual de uma posiÃ§Ã£o."""
    query = update.callback_query
    await query.answer()
    trade_id = int(query.data.split('_')[-1])
    
    db = SessionLocal()
    try:
        trade = db.query(Trade).filter_by(id=trade_id).first()
        if not trade:
            await query.edit_message_text("Erro: Trade nÃ£o encontrado ou jÃ¡ fechado.")
            return

        message = (
            f"âš ï¸ <b>Confirmar Fechamento</b> âš ï¸\n\n"
            f"VocÃª tem certeza que deseja fechar manualmente sua posiÃ§Ã£o em <b>{trade.symbol}</b>?\n\n"
            f"Esta aÃ§Ã£o Ã© irreversÃ­vel."
        )
        await query.edit_message_text(
            text=message,
            parse_mode='HTML',
            reply_markup=confirm_manual_close_keyboard(trade_id)
        )
    finally:
        db.close()



========================================
# Arquivo: bot/keyboards.py
========================================

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from database.crud import get_user_by_id

def main_menu_keyboard(telegram_id: int):
    """
    Retorna o teclado do menu principal de forma inteligente,
    verificando o status do usuÃ¡rio diretamente no banco de dados.
    """
    user = get_user_by_id(telegram_id)
    has_api_keys = user and user.api_key_encrypted is not None

    keyboard = []
    if has_api_keys:
        keyboard.append([InlineKeyboardButton("â„¹ï¸ Meu Painel", callback_data='user_dashboard')])
        keyboard.append([InlineKeyboardButton("ğŸ“Š Minhas PosiÃ§Ãµes", callback_data='user_positions')])
        
        # --- BOTÃƒO ADICIONADO AQUI ---
        keyboard.append([InlineKeyboardButton("ğŸ“ˆ Desempenho", callback_data='perf_today')])
        
        keyboard.append([InlineKeyboardButton("âš™ï¸ ConfiguraÃ§Ãµes de Trade", callback_data='user_settings')])
        keyboard.append([InlineKeyboardButton("ğŸ¤– ConfiguraÃ§Ã£o do Bot", callback_data='bot_config')])
    else:
        keyboard.append([InlineKeyboardButton("âš™ï¸ Configurar API Bybit", callback_data='config_api')])

    return InlineKeyboardMarkup(keyboard)

def dashboard_menu_keyboard():
    """Retorna o teclado para o painel do usuÃ¡rio, com a opÃ§Ã£o de remover a API."""
    keyboard = [
        [InlineKeyboardButton("ğŸ—‘ï¸ Remover API", callback_data='remove_api_prompt')],
        [InlineKeyboardButton("â¬…ï¸ Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def admin_menu_keyboard():
    """Retorna o teclado do menu de administrador."""
    keyboard = [
        [InlineKeyboardButton("ğŸ“¡ Listar Grupos/Canais", callback_data='admin_list_channels')],
        # --- NOVO BOTÃƒO ---
        [InlineKeyboardButton("ğŸ‘ï¸ Ver Alvos Ativos", callback_data='admin_view_targets')]
    ]
    return InlineKeyboardMarkup(keyboard)

def view_targets_keyboard():
    """Retorna o teclado para a tela de visualizaÃ§Ã£o de alvos, com um botÃ£o de voltar."""
    keyboard = [
        [InlineKeyboardButton("â¬…ï¸ Voltar ao Menu Admin", callback_data='back_to_admin_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def confirm_remove_keyboard():
    """Retorna o teclado de confirmaÃ§Ã£o para remover a API."""
    keyboard = [
        [InlineKeyboardButton("âœ… Sim, remover", callback_data='remove_api_confirm')],
        [InlineKeyboardButton("âŒ NÃ£o, cancelar", callback_data='remove_api_cancel')],
    ]
    return InlineKeyboardMarkup(keyboard)

def settings_menu_keyboard(user_settings):
    """
    Retorna o teclado do menu de configuraÃ§Ãµes, mostrando os valores atuais.
    """
    entry_percent = user_settings.entry_size_percent
    max_leverage = user_settings.max_leverage
    min_confidence = user_settings.min_confidence

    keyboard = [
        [InlineKeyboardButton(f"Tamanho da Entrada: {entry_percent:.2f}%", callback_data='set_entry_percent')],
        [InlineKeyboardButton(f"Alavancagem MÃ¡xima: {max_leverage}x", callback_data='set_max_leverage')],
        [InlineKeyboardButton(f"ConfianÃ§a MÃ­nima (IA): {min_confidence:.2f}%", callback_data='set_min_confidence')],
        # --- ADICIONE O NOVO BOTÃƒO AQUI ---
        [InlineKeyboardButton("âœ… Whitelist de Moedas", callback_data='set_coin_whitelist')],
        [InlineKeyboardButton("â¬…ï¸ Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)


def bot_config_keyboard(user_settings):
    """
    Retorna o teclado para o menu de configuraÃ§Ã£o do bot, mostrando o modo de aprovaÃ§Ã£o e as metas.
    """
    # BotÃ£o de Modo de AprovaÃ§Ã£o (lÃ³gica existente)
    mode = user_settings.approval_mode
    if mode == 'AUTOMATIC':
        approval_button_text = "Entrada de Sinais: AutomÃ¡tico âš¡"
    else:
        approval_button_text = "Entrada de Sinais: Manual ğŸ‘‹"

    # --- NOVOS BOTÃ•ES DE METAS ---
    # Formata a meta de lucro para exibiÃ§Ã£o
    profit_target = user_settings.daily_profit_target
    profit_text = f"Meta de Lucro DiÃ¡ria: ${profit_target:.2f}" if profit_target > 0 else "Meta de Lucro DiÃ¡ria: Desativada"

    # Formata o limite de perda para exibiÃ§Ã£o
    loss_limit = user_settings.daily_loss_limit
    loss_text = f"Limite de Perda DiÃ¡rio: ${loss_limit:.2f}" if loss_limit > 0 else "Limite de Perda DiÃ¡rio: Desativado"

    keyboard = [
        [InlineKeyboardButton(approval_button_text, callback_data='toggle_approval_mode')],
        # --- NOVAS LINHAS ADICIONADAS AO TECLADO ---
        [InlineKeyboardButton(profit_text, callback_data='set_profit_target')],
        [InlineKeyboardButton(loss_text, callback_data='set_loss_limit')],
        [InlineKeyboardButton("â¬…ï¸ Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def signal_approval_keyboard(signal_for_approval_id: int):
    """
    Retorna o teclado com os botÃµes de Aprovar/Rejeitar para um sinal manual.
    """
    keyboard = [
        [
            InlineKeyboardButton("âœ… Aprovar Entrada", callback_data=f'approve_signal_{signal_for_approval_id}'),
            InlineKeyboardButton("âŒ Rejeitar", callback_data=f'reject_signal_{signal_for_approval_id}')
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

def performance_menu_keyboard():
    """
    Retorna o teclado para o menu de anÃ¡lise de desempenho com filtros de perÃ­odo.
    """
    keyboard = [
        [
            InlineKeyboardButton("Hoje", callback_data='perf_today'),
            InlineKeyboardButton("Ontem", callback_data='perf_yesterday')
        ],
        [
            InlineKeyboardButton("Ãšltimos 7 Dias", callback_data='perf_7_days'),
            InlineKeyboardButton("Ãšltimos 30 Dias", callback_data='perf_30_days')
        ],
        [InlineKeyboardButton("ğŸ“œ HistÃ³rico de Trades", callback_data='list_closed_trades')],
        [InlineKeyboardButton("â¬…ï¸ Voltar ao Menu Principal", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def confirm_manual_close_keyboard(trade_id: int):
    """Retorna o teclado de confirmaÃ§Ã£o para o fechamento manual de um trade."""
    keyboard = [
        [
            InlineKeyboardButton("âœ… Sim, fechar", callback_data=f'execute_close_{trade_id}'),
            InlineKeyboardButton("âŒ Cancelar", callback_data='user_positions') # Volta para a lista de posiÃ§Ãµes
        ],
    ]
    return InlineKeyboardMarkup(keyboard)


========================================
# Arquivo: alembic/env.py
========================================

import os
import sys
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# Adiciona a raiz do projeto ao path para que possamos importar 'database.models'
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from database.models import Base

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # --- INÃCIO DA MODIFICAÃ‡ÃƒO ---
    # Pega a configuraÃ§Ã£o do alembic.ini
    configuration = config.get_section(config.config_ini_section, {})
    # Tenta pegar a URL de uma variÃ¡vel de ambiente, se nÃ£o existir, usa a do .ini
    url = os.getenv('DATABASE_URL', configuration['sqlalchemy.url'])
    configuration['sqlalchemy.url'] = url
    
    connectable = engine_from_config(
        configuration, # Usa a configuraÃ§Ã£o modificada
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


========================================
# Arquivo: alembic/versions/77721795cc18_criaÃ§Ã£o_da_estrutura_inicial_do_banco_.py
========================================

"""CriaÃ§Ã£o da estrutura inicial do banco de dados

Revision ID: 77721795cc18
Revises: 
Create Date: 2025-08-24 00:25:45.337111

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '77721795cc18'
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('invite_codes',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('code', sa.String(), nullable=False),
    sa.Column('is_used', sa.Boolean(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('code')
    )
    op.create_table('monitored_targets',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('channel_id', sa.BigInteger(), nullable=False),
    sa.Column('channel_name', sa.String(), nullable=True),
    sa.Column('topic_id', sa.BigInteger(), nullable=True),
    sa.Column('topic_name', sa.String(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('topic_id')
    )
    op.create_table('pending_signals',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('symbol', sa.String(), nullable=False),
    sa.Column('order_id', sa.String(), nullable=False),
    sa.Column('signal_data', sa.JSON(), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('order_id'),
    sa.UniqueConstraint('user_telegram_id', 'symbol', name='_user_symbol_uc')
    )
    op.create_index(op.f('ix_pending_signals_symbol'), 'pending_signals', ['symbol'], unique=False)
    op.create_index(op.f('ix_pending_signals_user_telegram_id'), 'pending_signals', ['user_telegram_id'], unique=False)
    op.create_table('signals_for_approval',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('symbol', sa.String(), nullable=False),
    sa.Column('source_name', sa.String(), nullable=True),
    sa.Column('signal_data', sa.JSON(), nullable=False),
    sa.Column('approval_message_id', sa.BigInteger(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_signals_for_approval_user_telegram_id'), 'signals_for_approval', ['user_telegram_id'], unique=False)
    op.create_table('trades',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('order_id', sa.String(), nullable=False),
    sa.Column('symbol', sa.String(), nullable=False),
    sa.Column('side', sa.String(), nullable=False),
    sa.Column('qty', sa.Float(), nullable=False),
    sa.Column('entry_price', sa.Float(), nullable=True),
    sa.Column('stop_loss', sa.Float(), nullable=True),
    sa.Column('current_stop_loss', sa.Float(), nullable=True),
    sa.Column('initial_targets', sa.JSON(), nullable=True),
    sa.Column('status', sa.String(), nullable=True),
    sa.Column('remaining_qty', sa.Float(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=True),
    sa.Column('closed_at', sa.DateTime(timezone=True), nullable=True),
    sa.Column('closed_pnl', sa.Float(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('order_id')
    )
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('first_name', sa.String(), nullable=True),
    sa.Column('api_key_encrypted', sa.String(), nullable=True),
    sa.Column('api_secret_encrypted', sa.String(), nullable=True),
    sa.Column('entry_size_percent', sa.Float(), nullable=True),
    sa.Column('max_leverage', sa.Integer(), nullable=True),
    sa.Column('min_confidence', sa.Float(), nullable=True),
    sa.Column('approval_mode', sa.String(), nullable=False),
    sa.Column('daily_profit_target', sa.Float(), nullable=False),
    sa.Column('daily_loss_limit', sa.Float(), nullable=False),
    sa.Column('coin_whitelist', sa.String(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_telegram_id'), 'users', ['telegram_id'], unique=True)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_users_telegram_id'), table_name='users')
    op.drop_table('users')
    op.drop_table('trades')
    op.drop_index(op.f('ix_signals_for_approval_user_telegram_id'), table_name='signals_for_approval')
    op.drop_table('signals_for_approval')
    op.drop_index(op.f('ix_pending_signals_user_telegram_id'), table_name='pending_signals')
    op.drop_index(op.f('ix_pending_signals_symbol'), table_name='pending_signals')
    op.drop_table('pending_signals')
    op.drop_table('monitored_targets')
    op.drop_table('invite_codes')
    # ### end Alembic commands ###


========================================
# Arquivo: services/__init__.py
========================================



========================================
# Arquivo: services/bybit_service.py
========================================

import logging
import asyncio
from typing import Dict, Any
from datetime import datetime, time, timedelta
from pybit.unified_trading import HTTP
from pybit.exceptions import InvalidRequestError
from database.models import User
from decimal import Decimal, ROUND_DOWN

logger = logging.getLogger(__name__)
INSTRUMENT_INFO_CACHE: Dict[str, Any] = {}

def _round_down_to_step(value: Decimal, step: Decimal) -> Decimal:
    # arredonda para baixo no mÃºltiplo do step
    if step <= 0:
        return value
    return (value // step) * step

def _round_down_to_tick(price: Decimal, tick: Decimal) -> Decimal:
    if tick <= 0:
        return price
    return (price // tick) * tick

async def get_instrument_info(symbol: str) -> Dict[str, Any]:
    """
    Busca as regras de um instrumento (sÃ­mbolo) da Bybit, usando um cache em memÃ³ria.
    """
    if symbol in INSTRUMENT_INFO_CACHE:
        return INSTRUMENT_INFO_CACHE[symbol]

    def _sync_call():
        try:
            # SessÃ£o nÃ£o autenticada com timeout e retentativas
            session = HTTP(testnet=False, timeout=30, retries=3)
            response = session.get_instruments_info(category="linear", symbol=symbol)
            
            if response.get("retCode") != 0:
                return {"success": False, "error": response.get("retMsg")}
            
            instrument_list = response.get("result", {}).get("list", [])
            if not instrument_list:
                return {"success": False, "error": f"SÃ­mbolo {symbol} nÃ£o encontrado na Bybit."}

            info = instrument_list[0]
            lot_size_filter = info.get("lotSizeFilter", {})
            price_filter = info.get("priceFilter", {})

            rules = {
                "success": True,
                "status": info.get("status"),
                "qtyStep": Decimal(lot_size_filter.get("qtyStep", "0")),
                "minOrderQty": Decimal(lot_size_filter.get("minOrderQty", "0")),
                "minNotionalValue": Decimal(lot_size_filter.get("minOrderIv", "0")),
                "tickSize": Decimal(price_filter.get("tickSize", "0")),
            }
            INSTRUMENT_INFO_CACHE[symbol] = rules
            return rules
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_instrument_info para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


# FunÃ§Ã£o auxiliar sÃ­ncrona, nÃ£o precisa de 'async'
def get_session(api_key: str, api_secret: str) -> HTTP:
    """Cria e retorna uma sessÃ£o HTTP para ser usada em threads."""
    return HTTP(
        testnet=False,
        api_key=api_key,
        api_secret=api_secret,
        timeout=30,
        retries=3
    )

async def get_account_info(api_key: str, api_secret: str) -> dict:
    """Busca o saldo da conta, calculando o saldo disponÃ­vel para Contas Unificadas."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.get_wallet_balance(accountType="UNIFIED")
            
            if response.get('retCode') == 0:
                account_data_list = response['result'].get('list', [])
                if not account_data_list:
                    return {"success": False, "data": {}, "error": "Lista de contas vazia na resposta da API."}
                
                account_data = account_data_list[0]
                equity_str = account_data.get('totalEquity')
                total_equity = float(equity_str) if equity_str else 0.0
                coin_list = account_data.get('coin', [])
                
                available_balance_usdt = 0.0
                for coin in coin_list:
                    if coin.get('coin') == 'USDT':
                        wallet_balance_str = coin.get('walletBalance', '0')
                        order_margin_str = coin.get('totalOrderIM', '0')
                        position_margin_str = coin.get('totalPositionIM', '0')

                        wallet_balance = float(wallet_balance_str) if wallet_balance_str else 0.0
                        order_margin = float(order_margin_str) if order_margin_str else 0.0
                        position_margin = float(position_margin_str) if position_margin_str else 0.0
                        
                        # CÃ¡lculo correto para Conta de Trading Unificada
                        available_balance_usdt = wallet_balance - order_margin - position_margin
                        break
                
                result_data = {
                    "total_equity": total_equity,
                    "available_balance_usdt": available_balance_usdt,
                    "coin_list": coin_list
                }
                return {"success": True, "data": result_data}
                
            return {"success": False, "data": {}, "error": response.get('retMsg', 'Erro desconhecido')}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_account_info: {e}", exc_info=True)
            return {"success": False, "data": {}, "error": str(e)}

    return await asyncio.to_thread(_sync_call)

async def place_order(api_key: str, api_secret: str, signal_data: dict, user_settings: User, balance: float) -> dict:
    """Abre uma nova posiÃ§Ã£o a mercado (Market) com validaÃ§Ã£o completa, incluindo verificaÃ§Ã£o de SL contra o preÃ§o atual."""
    symbol = signal_data['coin']
    
    # --- NOVA VERIFICAÃ‡ÃƒO DE PRÃ‰-VOO ---
    # Buscamos o preÃ§o de mercado ANTES de qualquer outra coisa
    price_check = await get_market_price(symbol)
    if not price_check.get("success"):
        return {"success": False, "error": f"NÃ£o foi possÃ­vel obter o preÃ§o de mercado atual para {symbol}."}
    current_market_price = Decimal(str(price_check["price"]))
    
    # Validamos o Stop Loss do sinal contra o preÃ§o atual
    side = "Buy" if (signal_data.get('order_type') or '').upper() == 'LONG' else "Sell"
    stop_loss_price = Decimal(str(signal_data.get('stop_loss')))

    if side == 'Buy' and stop_loss_price >= current_market_price:
        return {"success": False, "error": f"Stop Loss ({stop_loss_price}) invÃ¡lido para LONG. Deve ser menor que o preÃ§o atual ({current_market_price})."}
    if side == 'Sell' and stop_loss_price <= current_market_price:
        return {"success": False, "error": f"Stop Loss ({stop_loss_price}) invÃ¡lido para SHORT. Deve ser maior que o preÃ§o atual ({current_market_price})."}
    
    # Se a validaÃ§Ã£o passou, continuamos para a lÃ³gica de execuÃ§Ã£o sÃ­ncrona
    async def pre_flight_checks():
        if symbol not in INSTRUMENT_INFO_CACHE: await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            if not instrument_rules or not instrument_rules.get("success"): return instrument_rules or {"success": False, "error": f"Regras para {symbol} nÃ£o encontradas."}
            if instrument_rules["status"] != "Trading": return {"success": False, "error": f"O sÃ­mbolo {symbol} nÃ£o estÃ¡ ativo para negociaÃ§Ã£o ({instrument_rules['status']})."}

            session = get_session(api_key, api_secret)
            leverage = Decimal(str(user_settings.max_leverage))
            
            # Usamos o preÃ§o de mercado que acabamos de buscar para o cÃ¡lculo
            entry_price = current_market_price
            
            margin_in_dollars = Decimal(str(balance)) * (Decimal(str(user_settings.entry_size_percent)) / Decimal("100"))
            notional_value = margin_in_dollars * leverage
            
            if entry_price <= 0: return {"success": False, "error": f"PreÃ§o de entrada invÃ¡lido: {entry_price}"}
            qty_raw = notional_value / entry_price
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])

            if qty_adj < instrument_rules["minOrderQty"]:
                return {"success": False, "error": f"Qtd. ajustada ({qty_adj:f}) Ã© menor que a mÃ­nima permitida ({instrument_rules['minOrderQty']:f}) para {symbol}."}
            final_notional_value = qty_adj * entry_price
            if final_notional_value < instrument_rules["minNotionalValue"]:
                return {"success": False, "error": f"Valor total da ordem (${final_notional_value:.2f}) Ã© menor que o mÃ­nimo permitido de ${instrument_rules['minNotionalValue']:.2f}."}
            
            payload = {
                "category": "linear", "symbol": symbol, "side": side, "orderType": "Market", "qty": str(qty_adj),
                "takeProfit": str((signal_data.get('targets') or [None])[0]), "stopLoss": str(stop_loss_price),
            }
            try:
                session.set_leverage(category="linear", symbol=symbol, buyLeverage=str(leverage), sellLeverage=str(leverage))
            except InvalidRequestError as e:
                if "leverage not modified" in str(e).lower(): logger.warning(f"Alavancagem para {symbol} jÃ¡ estÃ¡ correta. Continuando...")
                else: return {"success": False, "error": str(e)}
            
            response = session.place_order(**{k: v for k, v in payload.items() if v is not None})
            if response.get('retCode') == 0: return {"success": True, "data": response['result']}
            return {"success": False, "error": response.get('retMsg')}
        
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao abrir ordem (Market): {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"ExceÃ§Ã£o em place_order (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}


async def get_market_price(symbol: str) -> dict:
    """Busca o preÃ§o de mercado atual de forma assÃ­ncrona."""
    def _sync_call():
        try:
            session = HTTP(testnet=False)
            response = session.get_tickers(category="linear", symbol=symbol)
            if response.get('retCode') == 0 and response['result']['list']:
                price = float(response['result']['list'][0]['lastPrice'])
                return {"success": True, "price": price}
            else:
                return {"success": False, "error": response.get('retMsg', 'PreÃ§o nÃ£o encontrado')}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao buscar preÃ§o de mercado para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def close_partial_position(api_key: str, api_secret: str, symbol: str, qty_to_close: float, side: str) -> dict:
    """Fecha parte de uma posiÃ§Ã£o com Market/ReduceOnly, usando o novo sistema de regras."""
    async def pre_flight_checks():
        if symbol not in INSTRUMENT_INFO_CACHE:
            await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            # 1. VALIDAÃ‡ÃƒO DAS REGRAS
            if not instrument_rules or not instrument_rules.get("success"):
                return instrument_rules or {"success": False, "error": f"Regras para {symbol} nÃ£o encontradas."}

            session = get_session(api_key, api_secret)
            close_side = "Sell" if side == 'LONG' else "Buy"

            # 2. CÃLCULO DE QUANTIDADE
            qty_raw = Decimal(str(qty_to_close))
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])

            logger.info(f"[bybit_service] close_partial {symbol}: raw={qty_raw}, step={instrument_rules['qtyStep']}, minQty={instrument_rules['minOrderQty']} => adj={qty_adj}")

            if qty_adj < instrument_rules["minOrderQty"]:
                # Se a quantidade a ser fechada for menor que o mÃ­nimo, ignoramos a operaÃ§Ã£o
                # Isso nÃ£o Ã© um erro, apenas nÃ£o hÃ¡ o que fazer.
                logger.warning(f"Quantidade a fechar para {symbol} ({qty_adj:f}) Ã© menor que o mÃ­nimo permitido. Ignorando fechamento parcial.")
                return {"success": True, "skipped": True, "reason": "qty_less_than_min_order_qty"}

            # 3. EXECUÃ‡ÃƒO
            response = session.place_order(
                category="linear", symbol=symbol, side=close_side,
                orderType="Market", qty=str(qty_adj), reduceOnly=True
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}

        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao fechar posiÃ§Ã£o parcial: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"ExceÃ§Ã£o em close_partial_position (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}


async def modify_position_stop_loss(api_key: str, api_secret: str, symbol: str, new_stop_loss: float) -> dict:
    """Modifica o Stop Loss de uma posiÃ§Ã£o aberta de forma assÃ­ncrona."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.set_trading_stop(
                category="linear", symbol=symbol, stopLoss=str(new_stop_loss)
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao modificar Stop Loss: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def get_open_positions(api_key: str, api_secret: str) -> dict:
    return await get_open_positions_with_pnl(api_key, api_secret)

async def get_pnl_for_period(api_key: str, api_secret: str, start_time: datetime, end_time: datetime) -> dict:
    """Busca o P/L (Lucro/PrejuÃ­zo) realizado para um perÃ­odo de tempo especÃ­fico."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            
            start_timestamp_ms = int(start_time.timestamp() * 1000)
            end_timestamp_ms = int(end_time.timestamp() * 1000)

            response = session.get_closed_pnl(
                category="linear",
                startTime=start_timestamp_ms,
                endTime=end_timestamp_ms,
                limit=200 # Aumentar o limite para buscar mais trades em perÃ­odos longos
            )

            if response.get('retCode') == 0:
                pnl_list = response.get('result', {}).get('list', [])
                total_pnl = sum(float(item.get('closedPnl', 0)) for item in pnl_list)
                return {"success": True, "pnl": total_pnl}
            else:
                error_msg = response.get('retMsg', 'Erro desconhecido ao buscar P/L.')
                logger.error(f"Erro da API Bybit ao buscar P/L: {error_msg}")
                return {"success": False, "error": error_msg}

        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_pnl_for_period: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


async def get_daily_pnl(api_key: str, api_secret: str) -> dict:
    """Busca o P/L realizado para o dia atual (agora usa a funÃ§Ã£o genÃ©rica)."""
    today_start = datetime.combine(datetime.today(), time.min)
    now = datetime.now()
    return await get_pnl_for_period(api_key, api_secret, today_start, now)


# --- FUNÃ‡ÃƒO PARA ENVIAR ORDEM LIMITE ---
async def place_limit_order(api_key: str, api_secret: str, signal_data: dict, user_settings: User, balance: float) -> dict:
    """Envia uma nova ordem limite para a Bybit com validaÃ§Ã£o completa."""
    async def pre_flight_checks():
        symbol = signal_data['coin']
        if symbol not in INSTRUMENT_INFO_CACHE:
            await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            symbol = signal_data['coin']
            
            if not instrument_rules or not instrument_rules.get("success"):
                return instrument_rules or {"success": False, "error": f"Regras para {symbol} nÃ£o encontradas."}
            if instrument_rules["status"] != "Trading":
                return {"success": False, "error": f"O sÃ­mbolo {symbol} nÃ£o estÃ¡ ativo para negociaÃ§Ã£o ({instrument_rules['status']})."}

            session = get_session(api_key, api_secret)
            side = "Buy" if (signal_data.get('order_type') or '').upper() == 'LONG' else "Sell"
            leverage = Decimal(str(user_settings.max_leverage))
            price = Decimal(str(signal_data.get('limit_price')))
            price_adj = (price // instrument_rules["tickSize"]) * instrument_rules["tickSize"]
            margin_in_dollars = Decimal(str(balance)) * (Decimal(str(user_settings.entry_size_percent)) / Decimal("100"))
            notional_value = margin_in_dollars * leverage

            if price_adj <= 0: return {"success": False, "error": f"PreÃ§o de entrada invÃ¡lido apÃ³s ajuste: {price_adj}"}
            
            qty_raw = notional_value / price_adj
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])
            
            if qty_adj < instrument_rules["minOrderQty"]:
                return {"success": False, "error": f"Qtd. ajustada ({qty_adj:f}) Ã© menor que a mÃ­nima permitida ({instrument_rules['minOrderQty']:f}) para {symbol}."}
            final_notional_value = qty_adj * price_adj
            if final_notional_value < instrument_rules["minNotionalValue"]:
                return {"success": False, "error": f"Valor total da ordem (${final_notional_value:.2f}) Ã© menor que o mÃ­nimo permitido de ${instrument_rules['minNotionalValue']:.2f}."}

            # --- LÃ“GICA CORRIGIDA ---
            payload = {
                "category": "linear", "symbol": symbol, "side": side,
                "orderType": "Limit", "qty": str(qty_adj), "price": str(price_adj),
                "takeProfit": str((signal_data.get('targets') or [None])[0]),
                "stopLoss": str(signal_data.get('stop_loss')),
            }

            try:
                session.set_leverage(category="linear", symbol=symbol, buyLeverage=str(leverage), sellLeverage=str(leverage))
            except InvalidRequestError as e:
                if "leverage not modified" in str(e).lower():
                    logger.warning(f"Alavancagem para {symbol} jÃ¡ estÃ¡ correta. Continuando...")
                else:
                    return {"success": False, "error": str(e)}

            response = session.place_order(**{k: v for k, v in payload.items() if v is not None})
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            return {"success": False, "error": response.get('retMsg')}

        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao abrir ordem (Limit): {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"ExceÃ§Ã£o em place_limit_order (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}


# --- FUNÃ‡ÃƒO PARA VERIFICAR STATUS DE UMA ORDEM ---
async def get_order_status(api_key: str, api_secret: str, order_id: str, symbol: str) -> dict:
    """Verifica o status de uma ordem especÃ­fica na Bybit, procurando em ordens abertas."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            # --- CORREÃ‡ÃƒO: MUDAMOS PARA get_open_orders ---
            response = session.get_open_orders(
                category="linear",
                symbol=symbol,
                orderId=order_id,
            )
            if response.get('retCode') == 0:
                order_list = response.get('result', {}).get('list', [])
                if order_list:
                    # A ordem foi encontrada na lista de ordens abertas
                    return {"success": True, "data": order_list[0]}
                else:
                    # Se nÃ£o estÃ¡ nas ordens abertas, pode jÃ¡ ter sido executada ou cancelada.
                    # Por seguranÃ§a, vamos verificar o histÃ³rico tambÃ©m.
                    hist_response = session.get_order_history(category="linear", orderId=order_id)
                    if hist_response.get('retCode') == 0:
                        hist_list = hist_response.get('result', {}).get('list', [])
                        if hist_list:
                            return {"success": True, "data": hist_list[0]}
                    
                    return {"success": False, "error": "Ordem nÃ£o encontrada nem nas abertas nem no histÃ³rico."}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao verificar status da ordem: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)


# --- FUNÃ‡ÃƒO PARA CANCELAR UMA ORDEM ---
async def cancel_order(api_key: str, api_secret: str, order_id: str, symbol: str) -> dict:
    """Cancela uma ordem limite pendente na Bybit."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.cancel_order(
                category="linear",
                symbol=symbol,
                orderId=order_id
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao cancelar ordem: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

# --- PNL FECHADO (PERFORMANCE) ---
async def get_closed_pnl_breakdown(api_key: str, api_secret: str, start_time: datetime, end_time: datetime) -> dict:
    """
    Retorna o P/L total e contagem de ganhos/perdas no perÃ­odo informado.
    Usa o endpoint oficial de closed PnL e pagina os resultados se o perÃ­odo for > 7 dias.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)

            total_pnl = 0.0
            total_wins = 0
            total_losses = 0
            all_items = []

            current_start = start_time

            while current_start < end_time:
                # Calcula o fim da janela atual, limitado a 7 dias ou ao fim do perÃ­odo total
                current_end = min(current_start + timedelta(days=7), end_time)

                logger.info(f"[bybit_service] Buscando PnL de {current_start.strftime('%Y-%m-%d')} a {current_end.strftime('%Y-%m-%d')}")

                resp = session.get_closed_pnl(
                    category="linear",
                    startTime=int(current_start.timestamp() * 1000),
                    endTime=int(current_end.timestamp() * 1000),
                    limit=200,
                )

                if resp.get("retCode") != 0:
                    error_msg = resp.get("retMsg", f"Erro desconhecido na paginaÃ§Ã£o de PnL (start={current_start})")
                    logger.error(f"Erro da API Bybit em get_closed_pnl_breakdown: {error_msg}")
                    # Retorna o erro da primeira falha
                    return {"success": False, "error": error_msg}

                items = resp.get("result", {}).get("list", []) or []
                all_items.extend(items)

                # AvanÃ§a o inÃ­cio da prÃ³xima janela
                current_start += timedelta(days=7)

            # Processa a lista completa de itens coletados
            for it in all_items:
                pnl = float(it.get("closedPnl", 0) or 0)
                total_pnl += pnl
                if pnl > 0:
                    total_wins += 1
                elif pnl < 0:
                    total_losses += 1

            return {
                "success": True,
                "total_pnl": total_pnl,
                "wins": total_wins,
                "losses": total_losses,
                "trades": len(all_items),
            }
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_closed_pnl_breakdown: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


# --- POSIÃ‡Ã•ES ABERTAS COM PNL ATUAL ---
async def get_open_positions_with_pnl(api_key: str, api_secret: str) -> dict:
    """
    Lista posiÃ§Ãµes abertas com avgPrice, markPrice e P/L atual (valor e %).
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            resp = session.get_positions(category="linear", settleCoin="USDT")
            if resp.get("retCode") != 0:
                return {"success": False, "error": resp.get("retMsg", "erro")}
            out = []
            for p in (resp.get("result", {}).get("list", []) or []):
                size = float(p.get("size", 0) or 0)
                if size <= 0:
                    continue
                symbol = p.get("symbol")
                side = "LONG" if (p.get("side") == "Buy") else "SHORT"
                entry = float(p.get("avgPrice", 0) or 0)
                mark = float((p.get("markPrice") or 0) or 0)
                # se mark vier 0, tenta buscar via tickers
                if not mark and symbol:
                    try:
                        t = session.get_tickers(category="linear", symbol=symbol)
                        mark = float(t["result"]["list"][0]["lastPrice"])
                    except Exception:
                        pass
                if not entry or not mark:
                    # nÃ£o dÃ¡ pra calcular PnL sem preÃ§o
                    pnl = 0.0
                    pnl_pct = 0.0
                else:
                    diff = (mark - entry) if side == "LONG" else (entry - mark)
                    pnl = diff * size
                    pnl_pct = (diff / entry) * 100.0 if entry else 0.0
                out.append({
                    "symbol": symbol,
                    "side": side,
                    "size": size,
                    "entry": entry,
                    "mark": mark,
                    "unrealized_pnl": pnl,
                    "unrealized_pnl_pct": pnl_pct,
                })
            return {"success": True, "data": out}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_open_positions_with_pnl: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def get_specific_position_size(api_key: str, api_secret: str, symbol: str) -> float:
    """
    Busca o tamanho (size) de uma posiÃ§Ã£o especÃ­fica aberta na Bybit.
    Retorna 0.0 se a posiÃ§Ã£o nÃ£o existir.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            # Usamos o filtro de sÃ­mbolo para buscar apenas a posiÃ§Ã£o de interesse
            response = session.get_positions(category="linear", symbol=symbol)
            
            if response.get('retCode') == 0:
                position_list = response.get('result', {}).get('list', [])
                if position_list and position_list[0]:
                    # Retorna o tamanho da primeira (e Ãºnica) posiÃ§Ã£o na lista
                    return float(position_list[0].get('size', 0.0))
            # Se a lista estiver vazia ou houver erro, a posiÃ§Ã£o nÃ£o existe ou nÃ£o foi encontrada
            return 0.0
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_specific_position_size para {symbol}: {e}", exc_info=True)
            return 0.0 # Em caso de erro, assumimos que nÃ£o hÃ¡ posiÃ§Ã£o para evitar fechamentos indevidos

    return await asyncio.to_thread(_sync_call)
    
async def get_order_history(api_key: str, api_secret: str, order_id: str) -> dict:
    """Busca os detalhes de uma ordem especÃ­fica no histÃ³rico."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.get_order_history(category="linear", orderId=order_id, limit=1)
            
            if response.get('retCode') == 0:
                order_list = response.get('result', {}).get('list', [])
                if order_list:
                    return {"success": True, "data": order_list[0]}
                return {"success": False, "error": "Ordem nÃ£o encontrada no histÃ³rico."}
            return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_order_history: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)

async def modify_position_take_profit(api_key: str, api_secret: str, symbol: str, new_take_profit: float) -> dict:
    """Modifica o Take Profit de uma posiÃ§Ã£o aberta."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.set_trading_stop(
                category="linear", symbol=symbol, takeProfit=str(new_take_profit)
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao modificar Take Profit: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def get_last_closed_trade_info(api_key: str, api_secret: str, symbol: str) -> dict:
    """
    FunÃ§Ã£o "Detetive": Busca o P/L fechado mais recente para um sÃ­mbolo especÃ­fico
    para determinar o resultado de um trade que jÃ¡ fechou.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            # Busca o histÃ³rico da Ãºltima hora, que Ã© suficiente para encontrar o trade
            end_time = datetime.now()
            start_time = end_time - timedelta(hours=1)
            
            response = session.get_closed_pnl(
                category="linear",
                symbol=symbol,
                startTime=int(start_time.timestamp() * 1000),
                endTime=int(end_time.timestamp() * 1000),
                limit=1  # Queremos apenas o trade mais recente
            )

            if response.get('retCode') == 0:
                pnl_list = response.get('result', {}).get('list', [])
                if pnl_list:
                    # Retorna os dados do Ãºltimo trade fechado para este sÃ­mbolo
                    return {"success": True, "data": pnl_list[0]}
                return {"success": False, "error": "Nenhum trade fechado encontrado para o sÃ­mbolo na Ãºltima hora."}
            
            return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_last_closed_trade_info: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


========================================
# Arquivo: services/notification_service.py
========================================

import logging
from telegram.ext import Application
from utils.config import ADMIN_ID

logger = logging.getLogger(__name__)

async def send_notification(application: Application, message: str):
    """
    Envia uma mensagem de notificaÃ§Ã£o para o administrador do bot.
    """
    if not application:
        logger.warning("Tentativa de enviar notificaÃ§Ã£o sem a instÃ¢ncia da aplicaÃ§Ã£o.")
        return
    try:
        await application.bot.send_message(
            chat_id=ADMIN_ID,
            text=message,
            parse_mode='HTML'
        )
        logger.info(f"NotificaÃ§Ã£o enviada para o admin: {message[:50]}...")
    except Exception as e:
        logger.error(f"Falha ao enviar notificaÃ§Ã£o para o admin: {e}")

========================================
# Arquivo: services/signal_parser.py
========================================

import re
import logging
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)

# --- DEFINIÃ‡ÃƒO CENTRALIZADA DOS TIPOS DE SINAL ---
class SignalType:
    MARKET = 'MARKET'
    LIMIT = 'LIMIT'
    CANCELAR = 'CANCELAR'


# -----------------------
# Helpers de normalizaÃ§Ã£o
# -----------------------
_FLOAT = r'[-+]?\d+(?:[.,]\d+)?'

def _to_float(x: str) -> float:
    """Converte string com vÃ­rgula ou ponto para float."""
    if x is None:
        return 0.0
    x = x.strip().replace(' ', '').replace(',', '.')
    # remove percentuais e sÃ­mbolos residuais
    x = re.sub(r'[^0-9.+-]', '', x)
    try:
        return float(x)
    except Exception:
        return 0.0

def _normalize_symbol(coin_raw: str) -> str:
    coin = (coin_raw or '').strip().upper()
    # remove emojis e lixo
    coin = re.sub(r'[^A-Z0-9]', '', coin)
    # alguns sinais usam par completo (ex.: AVAXUSDT)
    if coin.endswith('USDT') or coin.endswith('USD'):
        return coin if coin.endswith('USDT') else f'{coin}T'  # USD -> USDT (fail-safe)
    return f'{coin}USDT' if coin else coin

def _pick_first_number(text: str) -> Optional[float]:
    m = re.search(_FLOAT, text)
    return _to_float(m.group(0)) if m else None

def _findall_numbers(text: str) -> List[float]:
    return [_to_float(g) for g in re.findall(_FLOAT, text or '')]


# ----------------------------------------------------
# PadrÃµes de alto nÃ­vel (ordem importa: especÃ­ficos 1Âº)
# ----------------------------------------------------
CANCEL_PATTERN = re.compile(r'âš ï¸\s*([A-Za-z0-9]+)[^\n]*sinal\s*cancelad[oa]', re.IGNORECASE)

# â€œOrdem Limiteâ€ / â€œOrdem a/Ã  Mercadoâ€ podem aparecer em qualquer lugar
IS_MARKET_PATTERN = re.compile(r'Ordem\s*(?:Ã |a)?\s*Mercado', re.IGNORECASE)
IS_LIMIT_PATTERN  = re.compile(r'Ordem\s*Limite', re.IGNORECASE)

# Verificador de â€œsinal completoâ€
FULL_SIGNAL_GUARD = re.compile(r'(?=.*(?:Moeda|Coin|Pair)\s*:)(?=.*Tipo\s*:)(?=.*Stop\s*Loss\s*:)', re.IGNORECASE | re.DOTALL)


# ---------------------------
# Extrator de sinal â€œcompletoâ€
# ---------------------------
def _full_signal_extractor(message_text: str) -> Optional[Dict[str, Any]]:

    def find_single_value(pattern: str, text: str) -> Optional[str]:
        # Usa .*? para pular emojis e rÃ³tulos adicionais na linha
        m = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
        return m.group(1).strip() if m else None

    # --- Campos bÃ¡sicos ---
    coin_raw = find_single_value(r'(?:Moeda|Coin|Pair)\s*:\s*([A-Za-z0-9 ._-]+)', message_text)
    order_type_raw = find_single_value(r'Tipo\s*:\s*([A-Za-z ]+)', message_text)
    entry_raw = find_single_value(r'Zona\s*de\s*Entrada\s*:\s*([^\n\r]+)', message_text)
    sl_raw = find_single_value(r'Stop\s*Loss\s*:\s*([^\n\r]+)', message_text)

    # targets: T1:, T2:, ...
    targets = []
    for tlabel, val in re.findall(r'(?:^|\n)\s*T(\d+)\s*:\s*([^\n\r]+)', message_text, flags=re.IGNORECASE):
        n = _pick_first_number(val)
        if n is not None:
            targets.append(n)

    # confianÃ§a (se existir)
    conf_raw = find_single_value(r'Confian[Ã§c]a\s*:\s*([0-9.,]+)\s*%', message_text)
    confidence = _to_float(conf_raw) if conf_raw else None

    # normalizaÃ§Ãµes
    coin = _normalize_symbol(coin_raw or '')
    order_type = 'LONG'
    if order_type_raw:
        if 'SHORT' in order_type_raw.upper():
            order_type = 'SHORT'
        elif 'LONG' in order_type_raw.upper():
            order_type = 'LONG'

    # entradas
    entries: List[float] = []
    if entry_raw:
        nums = _findall_numbers(entry_raw)
        # muitos sinais colocam "x - y"; se sÃ³ tem um nÃºmero, trata como lista Ãºnica
        if len(nums) == 1:
            entries = [nums[0]]
        elif len(nums) >= 2:
            entries = [nums[0], nums[1]]
        else:
            entries = []

    # stop
    stop_loss = _pick_first_number(sl_raw or '') or 0.0

    # --- DeterminaÃ§Ã£o do tipo (MARKET x LIMIT) ---
    # 1) texto explÃ­cito
    is_market_text = bool(IS_MARKET_PATTERN.search(message_text))
    is_limit_text  = bool(IS_LIMIT_PATTERN.search(message_text))

    # 2) heurÃ­stica: â€œentrada Ãºnicaâ€ OU faixa idÃªntica => MARKET
    entries_imply_market = False
    if entries:
        if len(entries) == 1:
            entries_imply_market = True
        elif len(entries) >= 2 and abs(entries[0] - entries[1]) < 1e-10:
            entries_imply_market = True

    # decisÃ£o final
    if is_market_text or (not is_limit_text and entries_imply_market):
        signal_kind = SignalType.MARKET
        # para MARKET garantimos entries[0] preenchida (usa o primeiro nÃºmero visto no bloco de entrada)
        if not entries and entry_raw:
            n = _pick_first_number(entry_raw)
            entries = [n] if n is not None else []
    else:
        signal_kind = SignalType.LIMIT

    if not coin or not entries or stop_loss == 0.0:
        logger.debug("Parser: campos essenciais ausentes: coin=%s entries=%s stop=%s", coin, entries, stop_loss)
        return None

    return {
        "type": signal_kind,
        "coin": coin,
        "order_type": order_type,          # LONG | SHORT
        "entries": entries,                # [preÃ§o] ou [min, max]
        "stop_loss": stop_loss,
        "targets": targets,                # [t1, t2, ...]
        "confidence": confidence,          # opcional (float ou None)
    }


# -----------------
# FunÃ§Ã£o de entrada
# -----------------
def parse_signal(message_text: str) -> Optional[Dict[str, Any]]:
    """
    Identifica e extrai sinais:
      - CANCELAMENTO: 'âš ï¸ <COIN> ... sinal cancelad(o/a)'
      - ENTRADA COMPLETA: campos Moeda/Coin/Pair, Tipo, Stop Loss (com 'Ordem Limite' ou 'Ordem Ã  Mercado')
    Retorna um dicionÃ¡rio com os campos normalizados ou None se nÃ£o reconhecer.
    """
    if not message_text or not isinstance(message_text, str):
        return None

    text = message_text.strip()

    # 1) Cancelamento
    m_cancel = CANCEL_PATTERN.search(text)
    if m_cancel:
        coin = _normalize_symbol(m_cancel.group(1))
        return {"type": SignalType.CANCELAR, "coin": coin}

    # 2) Sinal de entrada (guarda)
    if not FULL_SIGNAL_GUARD.search(text):
        return None

    data = _full_signal_extractor(text)
    return data

========================================
# Arquivo: services/telethon_service.py
========================================

import logging
import asyncio
import os
import re
from telegram.ext import Application
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telethon.sync import TelegramClient
from telethon import events
from telethon.errors.rpcerrorlist import ChannelForumMissingError, ChannelInvalidError
from telethon.tl.functions.channels import GetForumTopicsRequest
from utils.config import API_ID, API_HASH
from database.session import SessionLocal
from database.models import MonitoredTarget
from .signal_parser import parse_signal

logger = logging.getLogger(__name__)

# --- LÃ“GICA DE CAMINHO DINÃ‚MICO ---
if os.path.isdir('/data'):
    SESSION_PATH = '/data/tradeflow_user'
else:
    SESSION_PATH = 'tradeflow_user'

# --- DEFINIÃ‡ÃƒO ÃšNICA E CORRETA DO CLIENTE ---
client = TelegramClient(SESSION_PATH, API_ID, API_HASH)
comm_queue = None
# Cache em memÃ³ria para armazenar os IDs das mensagens jÃ¡ processadas e evitar duplicidade.
PROCESSED_MESSAGE_IDS = set()


# --- FunÃ§Ãµes de Busca (Helpers) ---

def get_monitored_targets():
    """Busca no DB a lista de todos os alvos (canal/tÃ³pico) monitorados."""
    db = SessionLocal()
    try:
        return db.query(MonitoredTarget).all()
    finally:
        db.close()

async def list_channels():
    """Lista todos os canais e supergrupos com logging detalhado."""
    logger.info("[list_channels] Iniciando busca de diÃ¡logos...")
    channels = []
    count = 0
    try:
        async for dialog in client.iter_dialogs():
            count += 1
            if count % 50 == 0:
                logger.info(f"[list_channels] ... processou {count} diÃ¡logos...")
            
            if dialog.is_channel:
                channels.append((dialog.name, dialog.id))
        
        logger.info(f"[list_channels] Busca de diÃ¡logos finalizada. Total de {count} diÃ¡logos processados.")
    except Exception as e:
        logger.error(f"[list_channels] Erro durante iter_dialogs: {e}", exc_info=True)
        
    return channels

async def list_channel_topics(channel_id: int):
    """Busca os tÃ³picos de um canal especÃ­fico."""
    topics = []
    try:
        entity = await client.get_entity(channel_id)
        result = await client(GetForumTopicsRequest(
            channel=entity, offset_date=0, offset_id=0, offset_topic=0, limit=100
        ))
        for topic in result.topics:
            topics.append((topic.title, topic.id))
            
    except (ChannelForumMissingError, ChannelInvalidError):
        logger.warning(f"Canal {channel_id} nÃ£o possui tÃ³picos (nÃ£o Ã© um fÃ³rum).")
        
    except Exception as e:
        logger.error(f"ExceÃ§Ã£o em list_channel_topics para o canal {channel_id}: {e}", exc_info=True)
        
    return topics

# --- Listener de Sinais ---
# Em vez de filtrar por regex no decorator, ouvimos TUDO e deixamos o parser decidir.
from telethon import events

@client.on(events.NewMessage)
@client.on(events.MessageEdited)
async def signal_listener(event):
    """
    Ouve TODAS as mensagens e processa APENAS as dos alvos monitorados.
    """
    global comm_queue
    if not comm_queue: return

    chat_id = getattr(event, "chat_id", None)
    message_id = getattr(getattr(event, "message", None), "id", None)
    topic_id = event.reply_to.reply_to_msg_id if getattr(event, "reply_to", None) else None
    text = (getattr(event, "raw_text", None) or getattr(getattr(event, "message", None), "message", None) or "")

    # 1. Primeiro, verifica se a mensagem Ã© de um alvo monitorado
    monitored_targets = get_monitored_targets()
    is_target = any(
        (t.channel_id == chat_id and ((t.topic_id is None and topic_id is None) or t.topic_id == topic_id))
        for t in monitored_targets
    )

    # 2. Se nÃ£o for um alvo, a funÃ§Ã£o termina silenciosamente.
    if not is_target:
        return

    # --- LÃ“GICA DE LOG MOVIDA PARA CÃ ---
    # 3. Agora que sabemos que a mensagem Ã© importante, nÃ³s a registramos.
    preview = text.replace("\n", " ")[:120]
    logger.info(f"ğŸ“¨ [Telethon] Mensagem RELEVANTE recebida | chat_id={chat_id} | msg_id={message_id} | preview={preview!r}")

    # O resto da lÃ³gica para evitar duplicidade e processar o sinal continua a mesma...
    if message_id in PROCESSED_MESSAGE_IDS:
        logger.info(f"â­ï¸ [Telethon] Mensagem {message_id} jÃ¡ processada. Ignorando.")
        return

    from services.signal_parser import parse_signal
    parsed = parse_signal(text)

    if parsed:
        logger.info(
            "âœ… [Telethon] Ã‰ sinal! "
            f"type={parsed.get('type')} coin={parsed.get('coin')} "
            f"order={parsed.get('order_type')} entries={parsed.get('entries')} sl={parsed.get('stop_loss')}"
        )
        if message_id is not None:
            PROCESSED_MESSAGE_IDS.add(message_id)

        await comm_queue.put({
            "action": "process_signal",
            "signal_text": text,
            "source_name": f"telegram:{chat_id}"
        })

# --- Processador da Fila ---

async def queue_processor(queue: asyncio.Queue, ptb_app: Application):
    """Processa pedidos da fila, agora passando o 'source_name' adiante."""
    global comm_queue
    comm_queue = queue
    from core.trade_manager import process_new_signal

    while True:
        request = await queue.get()
        action = request.get("action")
        logger.info(f"[Queue Processor] ==> Pedido recebido! AÃ§Ã£o: '{action}'")
        
        try:
            if action == "list_channels":
                logger.info("[Queue Processor] ... Entrou no bloco de 'list_channels'.")
                chat_id = request.get("chat_id")
                message_id = request.get("message_id")
                channels = await list_channels()
                db = SessionLocal()
                monitored_channels_ids = {target.channel_id for target in db.query(MonitoredTarget).all()}
                db.close()
                keyboard = []
                
                if channels:
                    for channel_name, channel_id in channels:
                        suffix = " âœ…" if channel_id in monitored_channels_ids else ""
                        keyboard.append([InlineKeyboardButton(f"{channel_name}{suffix}", callback_data=f"monitor_channel_{channel_id}")])
                
                if keyboard:
                    await ptb_app.bot.edit_message_text(
                        chat_id=chat_id, message_id=message_id,
                        text="Selecione um grupo/canal (âœ… = algum monitoramento ativo):",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    await ptb_app.bot.edit_message_text(chat_id=chat_id, message_id=message_id, text="Nenhum canal ou supergrupo encontrado.")

            elif action == "list_topics":
                logger.info("[Queue Processor] ... Entrou no bloco de 'list_topics'.")
                channel_id = request.get("channel_id")
                chat_id = request.get("chat_id")
                message_id = request.get("message_id")
                channel_name = request.get("channel_name")
                
                topics = await list_channel_topics(channel_id)
                db = SessionLocal()
                
                try:
                    if topics:
                        monitored_topic_ids = {t.topic_id for t in db.query(MonitoredTarget).filter_by(channel_id=channel_id).all() if t.topic_id}
                        keyboard = [[InlineKeyboardButton("â¬…ï¸ Voltar para Grupos", callback_data="admin_list_channels")]]
                        for name, topic_id in topics:
                            suffix = " âœ…" if topic_id in monitored_topic_ids else ""
                            keyboard.append([InlineKeyboardButton(f"{name}{suffix}", callback_data=f"monitor_topic_{channel_id}_{topic_id}")])
                        
                        await ptb_app.bot.edit_message_text(
                            chat_id=chat_id, message_id=message_id,
                            text="Selecione o tÃ³pico para monitorar (âœ… = jÃ¡ monitorado):",
                            reply_markup=InlineKeyboardMarkup(keyboard)
                        )
                    else:
                        existing = db.query(MonitoredTarget).filter_by(channel_id=channel_id, topic_id=None).first()
                        if existing:
                            db.delete(existing)
                            feedback_msg = f"âŒ Canal '{channel_name}' removido da lista de monitoramento."
                        else:
                            new_target = MonitoredTarget(channel_id=channel_id, channel_name=channel_name)
                            db.add(new_target)
                            feedback_msg = f"âœ… Canal '{channel_name}' adicionado Ã  lista de monitoramento."
                        
                        db.commit()
                        await ptb_app.bot.edit_message_text(chat_id=chat_id, message_id=message_id, text=feedback_msg)
                finally:
                    db.close()

            elif action == "process_signal":
                logger.info("[Queue Processor] ... Entrou no bloco de 'process_signal'.")
                signal_text = request.get("signal_text")
                source_name = request.get("source_name", "Fonte Desconhecida")
                
                signal_data = parse_signal(signal_text)
                if signal_data:
                    await process_new_signal(signal_data, ptb_app, source_name)
                else:
                    logger.info("Mensagem da fila nÃ£o Ã© um sinal vÃ¡lido.")
            
            else:
                logger.warning(f"[Queue Processor] AÃ§Ã£o desconhecida ou nula recebida: '{action}'")

        except Exception as e:
            logger.error(f"Erro CRÃTICO no processador da fila ao manusear a aÃ§Ã£o '{action}': {e}", exc_info=True)
        finally:
            queue.task_done()
            logger.info(f"[Queue Processor] <== Pedido '{action}' finalizado.")

# --- FunÃ§Ã£o Principal do ServiÃ§o ---

async def start_signal_monitor(queue: asyncio.Queue):
    """Inicia o cliente Telethon, o ouvinte de sinais e o processador da fila."""
    logger.info("Iniciando monitor de sinais com Telethon...")
    
    await client.start()
    
    ptb_app = await queue.get()

    logger.info("âœ… Monitor de sinais e processador de fila ativos.")
    
    asyncio.create_task(queue_processor(queue, ptb_app))
    
    await client.run_until_disconnected()

