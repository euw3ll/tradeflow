========================================
# Arquivo: Dockerfile
========================================

# Usa uma imagem oficial do Python como base
FROM python:3.11-slim

# Define o diretÃ³rio de trabalho dentro do container
WORKDIR /app

# Copia o arquivo de dependÃªncias primeiro
COPY requirements.txt .

# Instala as dependÃªncias do Python
RUN pip install --no-cache-dir -r requirements.txt

# Copia todo o resto do cÃ³digo do projeto
COPY . .

# Comando que serÃ¡ executado quando o container iniciar, usando o script simplificado
CMD ["./start.sh"]

========================================
# Arquivo: main.py
========================================

import logging
import asyncio
from telegram import Update
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, 
    ConversationHandler, CallbackQueryHandler, ContextTypes
)
from telegram.error import TelegramError
from utils.config import TELEGRAM_TOKEN
from bot.handlers import (
    start, receive_invite_code, cancel, WAITING_CODE,
    config_api, receive_api_key, receive_api_secret, WAITING_API_KEY, WAITING_API_SECRET,
    remove_api_prompt, remove_api_action, CONFIRM_REMOVE_API,
    my_positions_handler, user_dashboard_handler, user_settings_handler,
    back_to_main_menu_handler,
    ask_entry_percent, receive_entry_percent, ASKING_ENTRY_PERCENT,
    ask_max_leverage, receive_max_leverage, ASKING_MAX_LEVERAGE,
    ask_min_confidence, receive_min_confidence, ASKING_MIN_CONFIDENCE,
    toggle_stop_strategy_handler,
    signal_filters_menu_handler, toggle_ma_filter_handler, toggle_rsi_filter_handler,
    ask_ma_period, receive_ma_period, ASKING_MA_PERIOD,
    admin_menu, list_channels_handler, select_channel_to_monitor, select_topic_to_monitor,
    admin_view_targets_handler, back_to_admin_menu_handler,
    bot_config_handler, toggle_approval_mode_handler, handle_signal_approval, 
    ask_profit_target, receive_profit_target, ASKING_PROFIT_TARGET,
    ask_loss_limit, receive_loss_limit, ASKING_LOSS_LIMIT, 
    ask_coin_whitelist, receive_coin_whitelist, ASKING_COIN_WHITELIST,
    performance_menu_handler, list_closed_trades_handler,
    prompt_manual_close_handler, execute_manual_close_handler,
    toggle_bot_status_handler,
    ask_stop_gain_trigger, receive_stop_gain_trigger, ASKING_STOP_GAIN_TRIGGER,
    ask_stop_gain_lock, receive_stop_gain_lock, ASKING_STOP_GAIN_LOCK,
    ask_circuit_threshold, receive_circuit_threshold, ASKING_CIRCUIT_THRESHOLD,
    ask_circuit_pause, receive_circuit_pause, ASKING_CIRCUIT_PAUSE,
    ask_ma_timeframe, set_ma_timeframe,
    ask_rsi_oversold, receive_rsi_oversold, ASKING_RSI_OVERSOLD,
    ask_rsi_overbought, receive_rsi_overbought, ASKING_RSI_OVERBOUGHT,
    show_risk_menu_handler, show_stopgain_menu_handler, show_circuit_menu_handler,
    back_to_settings_menu_handler, back_from_whitelist_handler
)
from database.session import init_db
from services.telethon_service import start_signal_monitor
from core.position_tracker import run_tracker

import warnings
warnings.filterwarnings("ignore", category=UserWarning, module="telegram.ext.conversationhandler")
logging.getLogger("telegram").setLevel(logging.ERROR)
logging.getLogger("telegram.ext").setLevel(logging.ERROR)

# --- ConfiguraÃ§Ã£o do Logging ---
logging.basicConfig(
    format="%(asctime)s - [%(levelname)s] - %(name)s - %(message)s",
    level=logging.INFO
)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("telegram").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)

async def run_ptb(application: Application, queue: asyncio.Queue):
    """Inicializa e roda a aplicaÃ§Ã£o python-telegram-bot."""
    application.bot_data['comm_queue'] = queue
    logger.info("Inicializando o bot do Telegram (PTB)...")
    await application.initialize()
    await application.start()
    await application.updater.start_polling()
    logger.info("âœ… Bot do Telegram (PTB) ativo.")

async def on_error(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Error handler global: loga a exceÃ§Ã£o e avisa o usuÃ¡rio (em chat privado)."""
    logger = logging.getLogger(__name__)
    logger.error("Unhandled error", exc_info=context.error)
    try:
        if update and update.effective_chat and update.effective_chat.type == "private":
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="âš ï¸ Ocorreu um erro inesperado. JÃ¡ registrei aqui e vou corrigir.",
            )
    except TelegramError:
        # Evita encadear erros caso o envio falhe
        pass

async def main():
    """Configura os handlers e inicia o PTB e o Telethon em paralelo."""
    init_db()
    comm_queue = asyncio.Queue()
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    await comm_queue.put(application)

    # --- Handlers de Conversa ---
    register_conv = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={ WAITING_CODE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_invite_code)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    api_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(config_api, pattern='^config_api$')],
        states={
            WAITING_API_KEY: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_api_key)],
            WAITING_API_SECRET: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_api_secret)],
        },
        # MUDANÃ‡A: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    remove_api_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(remove_api_prompt, pattern='^remove_api_prompt$')],
        states={ CONFIRM_REMOVE_API: [CallbackQueryHandler(remove_api_action, pattern='^remove_api_confirm|remove_api_cancel$')] },
        # MUDANÃ‡A: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    settings_entry_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_entry_percent, pattern='^set_entry_percent$')],
        states={ ASKING_ENTRY_PERCENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_entry_percent)] },
        # MUDANÃ‡A: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    settings_leverage_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_max_leverage, pattern='^set_max_leverage$')],
        states={ ASKING_MAX_LEVERAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_max_leverage)] },
        # MUDANÃ‡A: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    settings_confidence_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_min_confidence, pattern='^set_min_confidence$')],
        states={ ASKING_MIN_CONFIDENCE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_min_confidence)] },
        # MUDANÃ‡A: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    profit_target_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_profit_target, pattern='^set_profit_target$')],
        states={ ASKING_PROFIT_TARGET: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_profit_target)] },
        # MUDANÃ‡A: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    loss_limit_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_loss_limit, pattern='^set_loss_limit$')],
        states={ ASKING_LOSS_LIMIT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_loss_limit)] },
        # MUDANÃ‡A: 'per_message' alterado para False para manter o estado da conversa.
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    whitelist_conv = ConversationHandler(
    entry_points=[CallbackQueryHandler(ask_coin_whitelist, pattern='^set_coin_whitelist$')],
    states={
        ASKING_COIN_WHITELIST: [
            # novo: permite clicar em "Voltar" enquanto estÃ¡ no prompt
            CallbackQueryHandler(back_from_whitelist_handler, pattern='^back_to_settings_menu$'),
            # jÃ¡ existia: captura o texto enviado com a lista
            MessageHandler(filters.TEXT & ~filters.COMMAND, receive_coin_whitelist),
        ]
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    per_message=False, per_user=True,
)
    stop_gain_trigger_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_stop_gain_trigger, pattern='^set_stop_gain_trigger$')],
        states={ ASKING_STOP_GAIN_TRIGGER: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_stop_gain_trigger)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    stop_gain_lock_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_stop_gain_lock, pattern='^set_stop_gain_lock$')],
        states={ ASKING_STOP_GAIN_LOCK: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_stop_gain_lock)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    circuit_threshold_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_circuit_threshold, pattern='^set_circuit_threshold$')],
        states={ ASKING_CIRCUIT_THRESHOLD: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_circuit_threshold)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    circuit_pause_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_circuit_pause, pattern='^set_circuit_pause$')],
        states={ ASKING_CIRCUIT_PAUSE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_circuit_pause)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    ma_period_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_ma_period, pattern='^set_ma_period$')],
        states={ ASKING_MA_PERIOD: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_ma_period)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    rsi_oversold_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_rsi_oversold, pattern='^set_rsi_oversold$')],
        states={ ASKING_RSI_OVERSOLD: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_rsi_oversold)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )
    rsi_overbought_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_rsi_overbought, pattern='^set_rsi_overbought$')],
        states={ ASKING_RSI_OVERBOUGHT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_rsi_overbought)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False, per_user=True,
    )

    # Adicionando todos os handlers
    application.add_handler(register_conv)
    application.add_handler(api_conv)
    application.add_handler(remove_api_conv)
    application.add_handler(settings_entry_conv)
    application.add_handler(settings_leverage_conv)
    application.add_handler(settings_confidence_conv)
    application.add_handler(profit_target_conv)
    application.add_handler(loss_limit_conv)
    application.add_handler(whitelist_conv)
    application.add_handler(stop_gain_trigger_conv)
    application.add_handler(stop_gain_lock_conv)
    
    application.add_handler(CommandHandler("admin", admin_menu))
    application.add_handler(CallbackQueryHandler(list_channels_handler, pattern='^admin_list_channels$'))
    application.add_handler(CallbackQueryHandler(select_channel_to_monitor, pattern='^monitor_channel_'))
    application.add_handler(CallbackQueryHandler(select_topic_to_monitor, pattern='^monitor_topic_'))
    application.add_handler(CallbackQueryHandler(admin_view_targets_handler, pattern='^admin_view_targets$'))
    application.add_handler(CallbackQueryHandler(back_to_admin_menu_handler, pattern='^back_to_admin_menu$'))

    application.add_handler(CommandHandler("start", start))
    
    application.add_handler(CallbackQueryHandler(my_positions_handler, pattern='^user_positions$'))
    application.add_handler(CallbackQueryHandler(user_settings_handler, pattern='^user_settings$'))
    application.add_handler(CallbackQueryHandler(user_dashboard_handler, pattern='^user_dashboard$'))
    application.add_handler(CallbackQueryHandler(toggle_bot_status_handler, pattern='^toggle_bot_status$'))
    application.add_handler(CallbackQueryHandler(back_to_main_menu_handler, pattern='^back_to_main_menu$'))
    application.add_handler(CallbackQueryHandler(prompt_manual_close_handler, pattern='^confirm_close_'))
    application.add_handler(CallbackQueryHandler(execute_manual_close_handler, pattern='^execute_close_'))

    application.add_handler(CallbackQueryHandler(toggle_stop_strategy_handler, pattern='^set_stop_strategy$'))

    application.add_handler(CallbackQueryHandler(performance_menu_handler, pattern='^perf_'))
    
    application.add_handler(CallbackQueryHandler(list_closed_trades_handler, pattern='^list_closed_trades$'))

    application.add_handler(CallbackQueryHandler(bot_config_handler, pattern='^bot_config$'))
    application.add_handler(CallbackQueryHandler(toggle_approval_mode_handler, pattern='^toggle_approval_mode$'))

    application.add_handler(CallbackQueryHandler(handle_signal_approval, pattern=r'^(approve_signal_|reject_signal_)'))

    application.add_handler(stop_gain_lock_conv)
    application.add_handler(circuit_threshold_conv)
    application.add_handler(circuit_pause_conv)

    application.add_handler(CallbackQueryHandler(signal_filters_menu_handler, pattern='^signal_filters_menu$'))
    application.add_handler(CallbackQueryHandler(toggle_ma_filter_handler, pattern='^toggle_ma_filter$'))
    application.add_handler(CallbackQueryHandler(toggle_rsi_filter_handler, pattern='^toggle_rsi_filter$'))
    application.add_handler(ma_period_conv)

    application.add_handler(CallbackQueryHandler(ask_ma_timeframe, pattern='^ask_ma_timeframe$'))
    application.add_handler(CallbackQueryHandler(set_ma_timeframe, pattern='^set_ma_timeframe_'))
    application.add_handler(rsi_oversold_conv)
    application.add_handler(rsi_overbought_conv)

    application.add_handler(CallbackQueryHandler(show_risk_menu_handler, pattern='^settings_risk$'))
    application.add_handler(CallbackQueryHandler(show_stopgain_menu_handler, pattern='^settings_stopgain$'))
    application.add_handler(CallbackQueryHandler(show_circuit_menu_handler, pattern='^settings_circuit$'))
    application.add_handler(CallbackQueryHandler(back_to_settings_menu_handler, pattern='^back_to_settings_menu$'))

    application.add_error_handler(on_error)

    logger.info("Bot configurado. Iniciando todos os serviÃ§os...")

    await asyncio.gather(
        run_ptb(application, comm_queue),
        start_signal_monitor(comm_queue),
        run_tracker(application)
    )

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Bot desligado pelo usuÃ¡rio.")
    except Exception as e:
        logger.critical(f"Erro crÃ­tico nÃ£o tratado: {e}", exc_info=True)

========================================
# Arquivo: start.sh
========================================

#!/bin/sh

echo "Aplicando migraÃ§Ãµes do banco de dados..."
# Este comando garante que o DB esteja sempre na versÃ£o mais recente
# alembic upgrade head

echo "Iniciando o bot TradeFlow..."
python main.py

========================================
# Arquivo: database/__init__.py
========================================



========================================
# Arquivo: database/bootstrap_schema.py
========================================

# database/bootstrap_schema.py
from sqlalchemy import text
from .session import SessionLocal

def ensure_trades_columns():
    s = SessionLocal()
    try:
        conn = s.connection()
        cols = [row[1] for row in conn.execute(text("PRAGMA table_info(trades)")).fetchall()]

        if "missing_cycles" not in cols:
            conn.execute(text(
                "ALTER TABLE trades ADD COLUMN missing_cycles INTEGER NOT NULL DEFAULT 0"
            ))

        if "last_seen_at" not in cols:
            conn.execute(text(
                "ALTER TABLE trades ADD COLUMN last_seen_at DATETIME"
            ))

        s.commit()
    except Exception:
        s.rollback()
        raise
    finally:
        s.close()

========================================
# Arquivo: database/crud.py
========================================

from .session import SessionLocal
from .models import User

def get_user_by_id(telegram_id: int):
    """Busca um usuÃ¡rio no banco de dados pelo seu ID do Telegram."""
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == telegram_id).first()
        return user
    finally:
        db.close()

========================================
# Arquivo: database/models.py
========================================

from sqlalchemy import (Column, Integer, String, BigInteger, Boolean, Float, JSON, DateTime, UniqueConstraint)
from sqlalchemy.orm import declarative_base
from sqlalchemy.sql import func

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)
    first_name = Column(String)
    api_key_encrypted = Column(String)
    api_secret_encrypted = Column(String)
    entry_size_percent = Column(Float, default=5.0)
    max_leverage = Column(Integer, default=10)
    min_confidence = Column(Float, default=0.0)
    approval_mode = Column(String, default='AUTOMATIC', nullable=False)
    daily_profit_target = Column(Float, default=0.0, nullable=False)
    daily_loss_limit = Column(Float, default=0.0, nullable=False)
    coin_whitelist = Column(String, default='todas', nullable=False)
    stop_strategy = Column(String(20), default='BREAK_EVEN', nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    stop_gain_trigger_pct = Column(Float, default=0.0, nullable=False)
    stop_gain_lock_pct = Column(Float, default=0.0, nullable=False)
    circuit_breaker_threshold = Column(Integer, default=0, nullable=False)
    circuit_breaker_pause_minutes = Column(Integer, default=60, nullable=False)
    long_trades_paused_until = Column(DateTime(timezone=True), nullable=True)
    short_trades_paused_until = Column(DateTime(timezone=True), nullable=True)
    is_sleep_mode_enabled = Column(Boolean, default=False, nullable=False)
    # Filtros de AnÃ¡lise TÃ©cnica
    is_ma_filter_enabled = Column(Boolean, default=False, nullable=False)
    ma_period = Column(Integer, default=50, nullable=False)
    ma_timeframe = Column(String(10), default='60', nullable=False) # '60' para 1 hora
    is_rsi_filter_enabled = Column(Boolean, default=False, nullable=False)
    rsi_timeframe = Column(String(10), default='60', nullable=False)
    rsi_oversold_threshold = Column(Integer, default=30, nullable=False)
    rsi_overbought_threshold = Column(Integer, default=70, nullable=False)

class InviteCode(Base):
    __tablename__ = 'invite_codes'
    id = Column(Integer, primary_key=True)
    code = Column(String, unique=True, nullable=False)
    is_used = Column(Boolean, default=False)

class MonitoredTarget(Base):
    __tablename__ = 'monitored_targets'
    id = Column(Integer, primary_key=True)
    channel_id = Column(BigInteger, nullable=False)
    channel_name = Column(String)
    topic_id = Column(BigInteger, unique=True, nullable=True)
    topic_name = Column(String)

class Trade(Base):
    __tablename__ = 'trades'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False)
    order_id = Column(String, unique=True, nullable=False)
    notification_message_id = Column(BigInteger, nullable=True)
    symbol = Column(String, nullable=False)
    side = Column(String, nullable=False)
    qty = Column(Float, nullable=False)
    entry_price = Column(Float)
    stop_loss = Column(Float)
    current_stop_loss = Column(Float)
    initial_targets = Column(JSON)
    total_initial_targets = Column(Integer, nullable=True)
    status = Column(String, default='ACTIVE')
    remaining_qty = Column(Float)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    closed_at = Column(DateTime(timezone=True), nullable=True)
    closed_pnl = Column(Float, nullable=True)
    is_breakeven = Column(Boolean, default=False, nullable=False)
    trail_high_water_mark = Column(Float, nullable=True)
    is_stop_gain_active = Column(Boolean, default=False, nullable=False)
    unrealized_pnl_pct = Column(Float, nullable=True)
    missing_cycles = Column(Integer, default=0, nullable=False)
    last_seen_at = Column(DateTime(timezone=True), nullable=True)

class PendingSignal(Base):
    __tablename__ = 'pending_signals'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False, index=True)
    symbol = Column(String, nullable=False, index=True) 
    order_id = Column(String, unique=True, nullable=False)
    signal_data = Column(JSON, nullable=False)
    notification_message_id = Column(BigInteger, nullable=True)
    __table_args__ = (UniqueConstraint('user_telegram_id', 'symbol', name='_user_symbol_uc'),)

class SignalForApproval(Base):
    __tablename__ = 'signals_for_approval'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False, index=True)
    symbol = Column(String, nullable=False)
    source_name = Column(String)
    signal_data = Column(JSON, nullable=False)
    approval_message_id = Column(BigInteger)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

========================================
# Arquivo: database/session.py
========================================

# database/session.py
import os
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from .models import Base

# --- Caminho dinÃ¢mico (Docker vs local) ---
# Docker: a imagem monta o DB em /app/data/tradeflow.db
# Local: usa ./tradeflow.db
if os.path.isdir("/app/data"):
    DATABASE_URL = "sqlite:////app/data/tradeflow.db"
else:
    DATABASE_URL = "sqlite:///./tradeflow.db"

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def init_db():
    """Cria tabelas conhecidas e garante colunas novas no 'trades'."""
    # 1) Cria tabelas definidas nos models (se nÃ£o existirem)
    Base.metadata.create_all(bind=engine)

    # 2) Bootstrap de schema para colunas novas (idempotente)
    with engine.begin() as conn:
        # lista colunas atuais da tabela trades
        cols = [row[1] for row in conn.execute(text("PRAGMA table_info(trades)")).fetchall()]

        # missing_cycles
        if "missing_cycles" not in cols:
            conn.execute(text(
                "ALTER TABLE trades ADD COLUMN missing_cycles INTEGER NOT NULL DEFAULT 0"
            ))

        # last_seen_at
        if "last_seen_at" not in cols:
            conn.execute(text(
                "ALTER TABLE trades ADD COLUMN last_seen_at DATETIME"
            ))

========================================
# Arquivo: core/__init__.py
========================================



========================================
# Arquivo: core/performance_service.py
========================================

from services.bybit_service import get_closed_pnl_breakdown, get_account_info
from utils.security import decrypt_data
from database.session import SessionLocal
from database.models import Trade, User
from datetime import datetime
import logging
import asyncio

logger = logging.getLogger(__name__)

async def generate_performance_report(user_id: int, start_dt: datetime, end_dt: datetime) -> str:
    """Gera relatÃ³rio de desempenho, incluindo a rentabilidade sobre o patrimÃ´nio."""
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if not user or not user.api_key_encrypted:
            return "VocÃª precisa ter uma chave de API configurada para ver o desempenho."

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # Busca os dados de P/L e o saldo da conta em paralelo
        pnl_result, account_info = await asyncio.gather(
            get_closed_pnl_breakdown(api_key, api_secret, start_dt, end_dt),
            get_account_info(api_key, api_secret)
        )

        if not pnl_result.get("success"):
            return f"NÃ£o foi possÃ­vel calcular seu desempenho: {pnl_result.get('error')}"

        total_pnl = pnl_result["total_pnl"]
        wins = pnl_result["wins"]
        losses = pnl_result["losses"]
        trades = pnl_result["trades"]
        hit_rate = (wins / trades * 100.0) if trades else 0.0
        
        # --- NOVO CÃLCULO DE RENTABILIDADE ---
        rentabilidade_str = ""
        if account_info.get("success"):
            total_equity = account_info.get("data", {}).get("total_equity", 0.0)
            if total_equity > 0:
                rentabilidade = (total_pnl / total_equity) * 100
                rentabilidade_str = f"ğŸš€ <b>Rentabilidade:</b> {rentabilidade:+.2f}%\n\n"
        
        lucro_str = f"ğŸ“ˆ <b>Lucro:</b> ${total_pnl:,.2f}" if total_pnl >= 0 else f"ğŸ“‰ <b>PrejuÃ­zo:</b> ${abs(total_pnl):,.2f}"

        msg = (
            f"<b>ğŸ“Š Desempenho do PerÃ­odo</b>\n"
            f"<i>De {start_dt:%d/%m/%Y} a {end_dt:%d/%m/%Y}</i>\n\n"
            f"{rentabilidade_str}"
            f"{lucro_str}\n\n"
            f"ğŸ¯ <b>Taxa de Acerto:</b> {hit_rate:.2f}%\n"
            f"ğŸ“¦ <b>Total de Trades:</b> {trades}\n"
            f"  - Ganhos: {wins}\n"
            f"  - Perdas: {losses}\n"
        )
        return msg

    except Exception as e:
        logger.error(f"Erro ao gerar relatÃ³rio de performance para {user_id}: {e}", exc_info=True)
        return "Ocorreu um erro ao gerar seu relatÃ³rio."
    finally:
        db.close()


========================================
# Arquivo: core/position_tracker.py
========================================

import asyncio
import logging
import time
from telegram.ext import Application
from sqlalchemy.orm import Session
from database.session import SessionLocal
from database.models import Trade, User, PendingSignal
from services.bybit_service import (
    get_market_price, close_partial_position,
    modify_position_stop_loss, get_order_status,
    get_specific_position_size, modify_position_take_profit,
    get_last_closed_trade_info, get_open_positions_with_pnl,
    cancel_order
)
from services.notification_service import send_notification
from utils.security import decrypt_data
from sqlalchemy.sql import func
from telegram.error import BadRequest
from typing import Optional, Callable, Awaitable, Dict, Any, Set, Tuple, List

logger = logging.getLogger(__name__)

# cache em memÃ³ria para evitar reediÃ§Ãµes repetidas
# chave: trade.id, valor: {"sync_notified": bool}
_SYNC_CACHE = {}

def _generate_trade_status_message(trade: Trade, status_title: str, pnl_data: dict = None, current_price: float = None) -> str:
    """Dashboard compacto e rico para a mensagem de status do trade (HTML)."""
    arrow = "â¬†ï¸" if trade.side == "LONG" else "â¬‡ï¸"

    # --- Dados base ---
    entry = float(trade.entry_price or 0.0)
    curr  = float(current_price or 0.0)
    qty   = float(trade.qty or 0.0)
    rem   = float(trade.remaining_qty if trade.remaining_qty is not None else qty)

    # --- P/L ao vivo (fraÃ§Ã£o â†’ sempre formatar x100 na exibiÃ§Ã£o) ---
    unreal_val = float((pnl_data or {}).get("unrealized_pnl", 0.0))
    unreal_frac = float((pnl_data or {}).get("unrealized_pnl_frac", 0.0))  # ex.: 0.015 = 1.5%
    unreal_pct = unreal_frac * 100.0

    # --- TP progress / prÃ³ximo alvo ---
    total_tps = int(trade.total_initial_targets or 0)
    remaining_targets = list(trade.initial_targets or [])
    hit_tps = max(0, total_tps - len(remaining_targets))
    next_tp = remaining_targets[0] if remaining_targets else None

    # Barrinha de progresso de TPs (ex.: â– â– â–¡â–¡ para 2/4)
    filled = "â– " * min(hit_tps, total_tps)
    empty  = "â–¡" * max(0, total_tps - hit_tps)
    tp_bar = f"{filled}{empty}" if total_tps > 0 else "â€”"

    # --- Stop Loss (rÃ³tulos Ãºteis) ---
    sl = trade.current_stop_loss
    sl_badge = []
    if trade.is_breakeven:
        sl_badge.append("BE")
    if trade.is_stop_gain_active:
        sl_badge.append("LOCK")
    if trade.trail_high_water_mark is not None:
        sl_badge.append("TS")
    sl_tag = f" [{' / '.join(sl_badge)}]" if sl_badge else ""

    # --- Datas/metadata ---
    created_str = ""
    try:
        if trade.created_at:
            created_str = trade.created_at.strftime("%d/%m %H:%M")
    except Exception:
        pass

    # --- Montagem da mensagem ---
    lines = []
    lines.append(f"{arrow} <b>{trade.symbol} â€” {trade.side}</b>")
    if status_title:
        lines.append(f"ğŸŸ¦ <b>{status_title}</b>")
    lines.append("")

    # PreÃ§os e tamanhos
    lines.append(f"â¡ï¸ <b>Entrada:</b> ${entry:,.4f}")
    if curr:
        lines.append(f"ğŸ“Š <b>Atual:</b> ${curr:,.4f}")
    lines.append(f"ğŸ“¦ <b>Qtd. Total:</b> {qty:g} | <b>Restante:</b> {rem:g}")
    notional = entry * qty
    lines.append(f"ğŸ’µ <b>Notional (aprox.):</b> ${notional:,.2f}")
    lines.append("")

    # P/L
    lines.append(f"ğŸ“ˆ <b>P/L Atual:</b> {unreal_val:+.2f} USDT ({unreal_pct:+.2f}%)")

    # Stop
    if sl:
        lines.append(f"ğŸ›¡ï¸ <b>Stop Loss:</b> ${float(sl):,.4f}{sl_tag}")
    else:
        lines.append("ğŸ›¡ï¸ <b>Stop Loss:</b> â€”")
    lines.append("")

    # TPs
    if total_tps > 0:
        lines.append(f"ğŸ¯ <b>TPs:</b> {hit_tps}/{total_tps}  {tp_bar}")
        if next_tp is not None:
            lines.append(f"   â†³ <i>PrÃ³ximo:</i> ${float(next_tp):,.4f}")
        lines.append("")

    if created_str:
        lines.append(f"â± <i>Aberto em:</i> {created_str}")

    return "\n".join(lines)

async def check_pending_orders_for_user(application: Application, user: User, db: Session):
    """Verifica as ordens limite pendentes e envia notificaÃ§Ã£o na execuÃ§Ã£o.
    OFF: cancela todas as pendentes e encerra. ON: acompanha e promove para Trade quando 'Filled'.
    """

    pending_orders = db.query(PendingSignal).filter_by(user_telegram_id=user.telegram_id).all()
    if not pending_orders:
        return

    # ğŸ”‘ DECRIPTA UMA ÃšNICA VEZ (antes do branch ON/OFF)
    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)

    # Se o bot estiver OFF, cancela todas as pendentes e sai
    if not user.is_active:
        for order in pending_orders:
            try:
                await cancel_order(api_key, api_secret, order.order_id, order.symbol)
            except Exception as e:
                logger.error(f"[tracker:OFF] ExceÃ§Ã£o ao cancelar {order.order_id} ({order.symbol}): {e}", exc_info=True)
            db.delete(order)
        db.commit()
        logger.info(f"[tracker:OFF] PendingSignals do usuÃ¡rio {user.telegram_id} cancelados/limpos.")
        return

    # Bot ON: segue o fluxo normal
    for order in pending_orders:
        status_result = await get_order_status(api_key, api_secret, order.order_id, order.symbol)
        if not status_result.get("success"):
            logger.error(f"Falha ao obter status da ordem {order.order_id}: {status_result.get('error')}")
            continue

        order_data = status_result.get("data") or {}
        order_status = (order_data.get("orderStatus") or "").strip()

        if order_status == 'Filled':
            logger.info(f"Ordem Limite {order.order_id} EXECUTADA para o usuÃ¡rio {user.telegram_id}.")
            signal_data = order.signal_data or {}
            
            qty = float(order_data.get('cumExecQty', 0.0))
            entry_price = float(order_data.get('avgPrice', 0.0))
            
            if qty <= 0 or entry_price <= 0:
                logger.warning(f"Ordem {order.order_id} Filled, mas com qty/preÃ§o zerado. Removendo.")
                db.delete(order)
                await application.bot.send_message(chat_id=user.telegram_id, text=f"â„¹ï¸ Sua ordem limite para <b>{order.symbol}</b> foi finalizada sem execuÃ§Ã£o reportada.", parse_mode='HTML')
                continue

            side = signal_data.get('order_type')
            leverage = user.max_leverage
            margin = (qty * entry_price) / leverage if leverage > 0 else 0
            stop_loss = signal_data.get('stop_loss')
            all_targets = signal_data.get('targets') or []
            take_profit_1 = all_targets[0] if all_targets else "N/A"
            num_targets = len(all_targets)
            tp_text = f"${float(take_profit_1):,.4f}" if isinstance(take_profit_1, (int, float)) else take_profit_1
            if num_targets > 1:
                tp_text += f" (de {num_targets} alvos)"
            
            message = (
                f"ğŸ“ˆ <b>Ordem Limite Executada!</b>\n\n"
                f"  - ğŸ“Š <b>Tipo:</b> {side} | <b>Alavancagem:</b> {leverage}x\n"
                f"  - ğŸ’ <b>Moeda:</b> {order.symbol}\n"
                f"  - ğŸ”¢ <b>Quantidade:</b> {qty:g}\n"
                f"  - ğŸ’µ <b>PreÃ§o de Entrada:</b> ${entry_price:,.4f}\n"
                f"  - ğŸ’° <b>Margem:</b> ${margin:,.2f}\n"
                f"  - ğŸ›¡ï¸ <b>Stop Loss:</b> ${stop_loss:,.4f}\n"
                f"  - ğŸ¯ <b>Take Profit 1:</b> {tp_text}"
            )

            message_id_to_update = order.notification_message_id
            sent_message = None
            
            if message_id_to_update:
                try:
                    sent_message = await application.bot.edit_message_text(
                        chat_id=user.telegram_id,
                        message_id=message_id_to_update,
                        text=message,
                        parse_mode='HTML'
                    )
                except BadRequest as e:
                    logger.warning(f"NÃ£o foi possÃ­vel editar a mensagem {message_id_to_update}. Enviando uma nova. Erro: {e}")
                    sent_message = await application.bot.send_message(chat_id=user.telegram_id, text=message, parse_mode='HTML')
            else:
                # Fallback para ordens antigas que nÃ£o tinham o ID da mensagem salvo.
                sent_message = await application.bot.send_message(chat_id=user.telegram_id, text=message, parse_mode='HTML')

            new_trade = Trade(
                user_telegram_id=order.user_telegram_id, order_id=order.order_id,
                notification_message_id=sent_message.message_id, # Passa o ID correto para o trade
                symbol=order.symbol, side=side, qty=qty, entry_price=entry_price,
                stop_loss=stop_loss, current_stop_loss=stop_loss,
                initial_targets=all_targets,
                total_initial_targets=num_targets,
                status='ACTIVE', remaining_qty=qty
            )
            db.add(new_trade)
            logger.info("[order->trade] %s %s qty=%.6f entry=%.6f msg_id=%s",
                new_trade.symbol, new_trade.side, new_trade.qty, new_trade.entry_price,
                str(getattr(new_trade, "notification_message_id", None)))

            db.delete(order)


async def check_active_trades_for_user(application: Application, user: User, db: Session):
    """
    Verifica e gerencia os trades ativos, com ediÃ§Ã£o de mensagem para atualizaÃ§Ãµes.
    Regras:
    - TP sÃ³ Ã© considerado 'executado' apÃ³s sucesso na reduÃ§Ã£o (retCode == 0).
    - BREAK_EVEN/TRAILING_STOP podem ser ativados de duas formas:
        (A) PadrÃ£o: apÃ³s o 1Âº TP.
        (B) Opcional por PnL: se user.be_trigger_pct / user.ts_trigger_pct > 0 (sem depender do 1Âº TP).
    Esses campos sÃ£o opcionais no modelo; se nÃ£o existirem ou forem 0/None, ignora-se o gatilho por PnL.
    - SemÃ¢ntica do OFF (user.is_active == False): nÃ£o abre novas posiÃ§Ãµes nem deixa ordens pendentes,
      mas ESTE gerenciador continua atuando normalmente nas posiÃ§Ãµes abertas.
    """
    active_trades = db.query(Trade).filter(
        Trade.user_telegram_id == user.telegram_id,
        ~Trade.status.like('%CLOSED%')
    ).all()
    if not active_trades:
        return

    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)

    # PosiÃ§Ãµes ao vivo + PnL
    live_pnl_result = await get_open_positions_with_pnl(api_key, api_secret)
    if not live_pnl_result.get("success"):
        logger.warning(f"[tracker] Falha temporÃ¡ria ao buscar P/L para {user.telegram_id}. Ignorando ciclo.")
        return

    live_pnl_map = {p['symbol']: p for p in (live_pnl_result.get('data') or [])}

    # Gatilhos opcionais por PnL (se o modelo nÃ£o tiver os campos, getattr devolve 0)
    be_trigger_pct = float(getattr(user, "be_trigger_pct", 0) or 0.0)      # ativa BE quando PnL% >= X
    ts_trigger_pct = float(getattr(user, "ts_trigger_pct", 0) or 0.0)      # inicia TS quando PnL% >= Y

    for trade in active_trades:
        position_data = live_pnl_map.get(trade.symbol)
        live_position_size = float(position_data['size']) if position_data else 0.0

        message_was_edited = False
        status_title_update = ""
        current_price = 0.0

        # Cache de P/L no DB (fraÃ§Ã£o, ex.: 0.015 = 1.5%)
        if position_data:
            trade.unrealized_pnl_pct = position_data.get("unrealized_pnl_frac", 0.0)

        if live_position_size > 0:
            # PreÃ§o de mercado
            price_result = await get_market_price(trade.symbol)
            if not price_result.get("success"):
                continue
            current_price = price_result["price"]

            # Dados de PnL atuais (fraÃ§Ã£o â†’ % sÃ³ para comparaÃ§Ã£o/exibiÃ§Ã£o)
            pnl_data = live_pnl_map.get(trade.symbol) or {}
            pnl_frac = float(pnl_data.get("unrealized_pnl_frac") or 0.0)
            pnl_pct = pnl_frac * 100.0

            # --- STOP-GAIN por gatilho (independente de BE/TS) ---
            if (user.stop_gain_trigger_pct or 0) > 0 and not trade.is_stop_gain_active and not trade.is_breakeven:
                if pnl_pct >= float(user.stop_gain_trigger_pct):
                    log_prefix = f"[Stop-Gain {trade.symbol}]"
                    if trade.side == 'LONG':
                        new_sl = trade.entry_price * (1 + (float(user.stop_gain_lock_pct or 0) / 100))
                    else:
                        new_sl = trade.entry_price * (1 - (float(user.stop_gain_lock_pct or 0) / 100))

                    is_improvement = (trade.side == 'LONG' and new_sl > (trade.current_stop_loss or float('-inf'))) or \
                                     (trade.side == 'SHORT' and new_sl < (trade.current_stop_loss or float('inf')))
                    is_valid_to_set = (trade.side == 'LONG' and new_sl < current_price) or \
                                      (trade.side == 'SHORT' and new_sl > current_price)

                    if is_improvement and is_valid_to_set:
                        sl_result = await modify_position_stop_loss(api_key, api_secret, trade.symbol, new_sl, reason="lock")
                        if sl_result.get("success"):
                            trade.is_stop_gain_active = True
                            trade.current_stop_loss = new_sl
                            message_was_edited = True
                            status_title_update = f"ğŸ’° Stop-Gain Ativado (+{float(user.stop_gain_lock_pct or 0):.2f}%)"
                            logger.info(f"{log_prefix} SL â†’ ${new_sl:.4f}")
                        else:
                            logger.error(f"{log_prefix} Falha ao mover SL (lock): {sl_result.get('error', 'desconhecido')}")

            # --- TAKE PROFIT (confirmaÃ§Ã£o sÃ³ apÃ³s reduÃ§Ã£o bem-sucedida) ---
            targets_executados_este_ciclo = []
            if trade.initial_targets:
                for target_price in list(trade.initial_targets):
                    hit = (trade.side == 'LONG' and current_price >= target_price) or \
                          (trade.side == 'SHORT' and current_price <= target_price)
                    if not hit:
                        continue

                    if not trade.total_initial_targets or trade.total_initial_targets <= 0:
                        logger.warning(f"{trade.symbol}: total_initial_targets invÃ¡lido ({trade.total_initial_targets}).")
                        continue

                    qty_to_close = trade.qty / trade.total_initial_targets
                    position_idx_to_close = 1 if trade.side == 'LONG' else 2  # em one-way a Bybit ignora

                    logger.info("[tp:crossed] %s %s TP=%.4f last=%.4f -> tentando reduzir",
                                trade.symbol, trade.side, float(target_price), float(current_price))

                    close_result = await close_partial_position(
                        api_key, api_secret, trade.symbol, qty_to_close, trade.side, position_idx_to_close
                    )
                    if close_result.get("success"):
                        targets_executados_este_ciclo.append(target_price)
                        try:
                            trade.remaining_qty = (trade.remaining_qty or trade.qty) - qty_to_close
                            if trade.remaining_qty < 0:
                                trade.remaining_qty = 0.0
                        except Exception:
                            trade.remaining_qty = max(0.0, (trade.remaining_qty or 0.0) - qty_to_close)

                        message_was_edited = True
                        status_title_update = "ğŸ¯ Take Profit EXECUTADO!"
                        logger.info("[tp:executed] %s %s TP=%.4f closed=%.6f remaining=%.6f",
                                    trade.symbol, trade.side, float(target_price),
                                    float(qty_to_close), float(trade.remaining_qty or 0.0))
                    else:
                        logger.error("[tp:failed] %s %s TP=%.4f reason=%s",
                                     trade.symbol, trade.side, float(target_price),
                                     close_result.get("error", "desconhecido"))

            if targets_executados_este_ciclo:
                trade.initial_targets = [t for t in trade.initial_targets if t not in targets_executados_este_ciclo]
                message_was_edited = True
                if not status_title_update:
                    status_title_update = "ğŸ¯ Take Profit EXECUTADO!"

            # --- BREAK-EVEN ---
            be_trigger_hit = False
            if be_trigger_pct > 0 and not trade.is_breakeven:
                # Opcional: ativa BE por PnL, sem depender de 1Âº TP
                if pnl_pct >= be_trigger_pct:
                    desired_sl = float(trade.entry_price)
                    be_trigger_hit = True
            # Modo padrÃ£o: 1Âº TP move para BE / TPs seguintes avanÃ§am
            if user.stop_strategy == 'BREAK_EVEN':
                if targets_executados_este_ciclo or be_trigger_hit:
                    if targets_executados_este_ciclo:
                        tp_ref = max(targets_executados_este_ciclo) if trade.side == 'LONG' else min(targets_executados_este_ciclo)
                        if trade.is_breakeven:
                            desired_sl = float(tp_ref)  # avanÃ§a para o TP atingido
                            reason = f"Break-Even AvanÃ§ado (TP {tp_ref:.4f})"
                        else:
                            desired_sl = float(trade.entry_price)
                            reason = "Break-Even Ativado (1Âº TP)"
                    else:
                        # veio do gatilho por PnL
                        reason = f"Break-Even por PnL ({pnl_pct:.2f}%)"

                    is_improvement = (trade.side == 'LONG' and desired_sl > (trade.current_stop_loss or float('-inf'))) or \
                                     (trade.side == 'SHORT' and desired_sl < (trade.current_stop_loss or float('inf')))
                    is_valid_to_set = (trade.side == 'LONG' and desired_sl < current_price) or \
                                      (trade.side == 'SHORT' and desired_sl > current_price)

                    if is_improvement and is_valid_to_set:
                        sl_result = await modify_position_stop_loss(api_key, api_secret, trade.symbol, desired_sl, reason="be")
                        if sl_result.get("success"):
                            trade.is_breakeven = True
                            trade.current_stop_loss = desired_sl
                            message_was_edited = True
                            status_title_update = f"ğŸ›¡ï¸ {reason}"
                            logger.info("[be:set] %s %s SL=%.4f last=%.4f", trade.symbol, trade.side, desired_sl, float(current_price))
                        else:
                            logger.error("[be:failed] %s SL=%.4f reason=%s", trade.symbol, desired_sl, sl_result.get('error', 'desconhecido'))

            # --- TRAILING STOP ---
            if user.stop_strategy == 'TRAILING_STOP':
                # ComeÃ§o do TS: (A) apÃ³s 1Âº TP (padrÃ£o) ou (B) por PnL opcional
                first_tp_hit = trade.total_initial_targets is not None and \
                                 trade.initial_targets is not None and \
                               len(trade.initial_targets) < trade.total_initial_targets
                ts_started = first_tp_hit or (ts_trigger_pct > 0 and pnl_pct >= ts_trigger_pct)

                if ts_started:
                    log_prefix = f"[Trailing Stop {trade.symbol}]"
                    if not trade.is_breakeven:
                        # Primeiro passo do TS = mover para BE
                        new_sl = float(trade.entry_price)
                        sl_result = await modify_position_stop_loss(api_key, api_secret, trade.symbol, new_sl, reason="ts")
                        if sl_result.get("success"):
                            trade.is_breakeven = True
                            trade.current_stop_loss = new_sl
                            trade.trail_high_water_mark = new_sl
                            message_was_edited = True
                            status_title_update = "ğŸ›¡ï¸ Stop Movido (Break-Even)"
                            logger.info(f"{log_prefix} SL â†’ BE (${new_sl:.4f}) (gatilho: {'TP' if first_tp_hit else f'PnL {pnl_pct:.2f}%'})")
                        else:
                            logger.error(f"{log_prefix} Falha ao mover SL para BE: {sl_result.get('error', 'desconhecido')}")
                    else:
                        # Atualiza HWM e recalcula SL "seguindo" o preÃ§o
                        if trade.trail_high_water_mark is None:
                            trade.trail_high_water_mark = trade.entry_price
                        new_hwm = trade.trail_high_water_mark
                        if trade.side == 'LONG' and current_price > new_hwm:
                            new_hwm = current_price
                        elif trade.side == 'SHORT' and current_price < new_hwm:
                            new_hwm = current_price

                        if new_hwm != trade.trail_high_water_mark:
                            logger.info(f"{log_prefix} Novo pico: ${new_hwm:.4f}")
                            trade.trail_high_water_mark = new_hwm

                        # DistÃ¢ncia do rastro: usa SL inicial se houver; fallback 2% da entrada
                        trail_distance = abs(trade.entry_price - (trade.stop_loss or trade.entry_price * 0.98)) \
                                         if trade.stop_loss is not None else trade.entry_price * 0.02
                        potential_new_sl = new_hwm - trail_distance if trade.side == 'LONG' else new_hwm + trail_distance

                        is_improvement = (trade.side == 'LONG' and potential_new_sl > (trade.current_stop_loss or float('-inf'))) or \
                                         (trade.side == 'SHORT' and potential_new_sl < (trade.current_stop_loss or float('inf')))
                        if is_improvement:
                            is_valid_to_set = (trade.side == 'LONG' and potential_new_sl < current_price) or \
                                              (trade.side == 'SHORT' and potential_new_sl > current_price)
                            if is_valid_to_set:
                                sl_result = await modify_position_stop_loss(api_key, api_secret, trade.symbol, potential_new_sl, reason="ts")
                                if sl_result.get("success"):
                                    trade.current_stop_loss = potential_new_sl
                                    message_was_edited = True
                                    status_title_update = "ğŸ“ˆ Trailing Stop Ajustado"
                                else:
                                    logger.error(f"{log_prefix} Falha ao mover Trailing SL: {sl_result.get('error', 'desconhecido')}")

            # --- Mensagem viva (status em aberto) ---
            if message_was_edited:
                pnl_data_for_msg = live_pnl_map.get(trade.symbol)
                msg_text = _generate_trade_status_message(trade, status_title_update, pnl_data_for_msg, current_price)
                await _send_or_edit_trade_message(application, user, trade, db, msg_text)

async def run_tracker(application: Application):
    """FunÃ§Ã£o principal que roda o verificador em loop para TODOS os usuÃ¡rios."""
    logger.info("Iniciando Rastreador de PosiÃ§Ãµes e Ordens (Modo MultiusuÃ¡rio)...")
    while True:
        cycle_started = time.perf_counter()
        total_users = 0
        adopted_count = 0

        db = SessionLocal()
        try:
            # --- LÃ“GICA DE SINCRONIZAÃ‡ÃƒO APRIMORADA ---
            all_api_users_for_sync = db.query(User).filter(User.api_key_encrypted.isnot(None)).all()
            for user in all_api_users_for_sync:
                total_users += 1
                sync_api_key = decrypt_data(user.api_key_encrypted)
                sync_api_secret = decrypt_data(user.api_secret_encrypted)

                # Wrapper para o detetive: usa suas credenciais e adapta o formato
                async def _fetch_closed_info(symbol: str) -> Optional[Dict[str, Any]]:
                    res = await get_last_closed_trade_info(sync_api_key, sync_api_secret, symbol)
                    if not res or not res.get("success"):
                        return None
                    d = res.get("data") or {}
                    # padroniza campos esperados pelo detetive
                    return {
                        "pnl": float(d.get("closedPnl", 0.0)) if d.get("closedPnl") is not None else None,
                        "exit_type": d.get("exitType"),
                        "exit_price": d.get("exitPrice"),
                        "closed_at": d.get("closedAt"),
                    }

                bybit_positions_result = await get_open_positions_with_pnl(sync_api_key, sync_api_secret)
                if not bybit_positions_result.get("success"):
                    logger.error(f"SincronizaÃ§Ã£o: Falha ao buscar posiÃ§Ãµes da Bybit para o usuÃ¡rio {user.telegram_id}. Pulando.")
                    continue

                bybit_list = bybit_positions_result.get("data", []) or []
                bybit_keys = {(p["symbol"], p["side"]) for p in bybit_list}
                bybit_map = {(p["symbol"], p["side"]): p for p in bybit_list}

                # [NOVO] conjunto sÃ³ por sÃ­mbolo (ignora side)
                bybit_symbols = {p["symbol"] for p in bybit_list}

                # [NOVO] mapa por sÃ­mbolo -> se tiver mais de uma entrada do mesmo sÃ­mbolo,
                # fica com a de maior tamanho absoluto (mais relevante)
                bybit_map_by_symbol: Dict[str, Dict[str, Any]] = {}
                for p in bybit_list:
                    sym = p["symbol"]
                    if sym not in bybit_map_by_symbol:
                        bybit_map_by_symbol[sym] = p
                    else:
                        prev = bybit_map_by_symbol[sym]
                        if abs(float(p.get("size") or 0)) > abs(float(prev.get("size") or 0)):
                            bybit_map_by_symbol[sym] = p

                db_active_trades = db.query(Trade).filter(
                    Trade.user_telegram_id == user.telegram_id,
                    ~Trade.status.like('%CLOSED%')
                ).all()
            
                db_pending_signals = db.query(PendingSignal).filter(
                    PendingSignal.user_telegram_id == user.telegram_id
                ).all()
                db_pending_symbols = {s.symbol for s in db_pending_signals}

                # [NOVO] Adotar Ã³rfÃ£s por SÃMBOLO (ignora side)
                db_active_symbols = {t.symbol for t in db_active_trades}
                # db_pending_symbols vocÃª JÃ construiu acima e Ã© um set de strings: {s.symbol for s in db_pending_signals}

                symbols_to_adopt = bybit_symbols - db_active_symbols - db_pending_symbols
                for symbol in symbols_to_adopt:
                    adopted_count += 1
                    pos = bybit_map_by_symbol.get(symbol)
                    if not pos:
                        continue  # seguranÃ§a

                    side = pos.get("side")
                    entry = float(pos.get("entry", 0) or 0)
                    size = float(pos.get("size", 0) or 0)
                    curr_sl = pos.get("stop_loss") or None

                    new_trade = Trade(
                        user_telegram_id=user.telegram_id,
                        order_id=f"sync_{symbol}_{int(time.time())}",
                        symbol=symbol,
                        side=side,
                        qty=size,
                        remaining_qty=size,
                        entry_price=entry,
                        status='ACTIVE_SYNCED',
                        stop_loss=curr_sl,
                        current_stop_loss=curr_sl,
                        initial_targets=[],
                        total_initial_targets=0
                    )

                    cand = db.query(PendingSignal).filter_by(
                        user_telegram_id=user.telegram_id, symbol=symbol
                    ).order_by(PendingSignal.id.desc()).first()
                    if cand and cand.signal_data:
                        try:
                            tps = cand.signal_data.get('targets') or []
                            new_trade.initial_targets = tps
                            new_trade.total_initial_targets = len(tps)
                            if not curr_sl and cand.signal_data.get('stop_loss'):
                                new_trade.stop_loss = cand.signal_data['stop_loss']
                                new_trade.current_stop_loss = new_trade.stop_loss
                            db.delete(cand)
                            logger.info("[sync:recover-signal] %s: recuperados %d TP(s) e SL.", symbol, len(tps))
                        except Exception:
                            logger.exception("[sync:recover-signal] falhou ao mapear sinal para %s", symbol)

                    db.add(new_trade)

                    msg = (
                        f"âš ï¸ <b>PosiÃ§Ã£o Sincronizada</b>\n"
                        f"Moeda: <b>{symbol}</b> | Lado: <b>{side}</b>\n"
                        f"A posiÃ§Ã£o foi encontrada aberta na Bybit e adotada pelo bot.\n"
                        f"{'Alvos/SL recuperados.' if new_trade.total_initial_targets else 'Sem alvos conhecidos.'}"
                    )
                    await application.bot.send_message(chat_id=user.telegram_id, text=msg, parse_mode='HTML')

                # [NOVO] Fechar fantasmas com tolerÃ¢ncia (aplica janela de 3 ciclos)
                await apply_missing_cycles_policy(
                    application=application,
                    user=user,
                    db=db,
                    db_active_trades=db_active_trades,
                    bybit_keys=bybit_keys,
                    threshold=3,  # configurÃ¡vel no futuro via env/setting se necessÃ¡rio
                    get_last_closed_trade_info=_fetch_closed_info,
                )

            duration = time.perf_counter() - cycle_started
            logger.info("[cycle] resumo: usuarios=%d, adotadas=%d, duracao=%.2fs",
            total_users, adopted_count, duration)

            db.commit()

            # --- LÃ³gica de verificaÃ§Ã£o normal ---
            all_users = db.query(User).filter(User.api_key_encrypted.isnot(None)).all()
            if all_users:
                logger.info(f"Rastreador: Verificando assets para {len(all_users)} usuÃ¡rio(s).")
                for user in all_users:
                    await check_pending_orders_for_user(application, user, db)
                    await check_active_trades_for_user(application, user, db)
                db.commit()
            else:
                logger.info("Rastreador: Nenhum usuÃ¡rio com API para verificar.")

        except Exception as e:
            logger.critical(f"Erro crÃ­tico no loop do rastreador: {e}", exc_info=True)
            db.rollback()
        finally:
            db.close()

        await asyncio.sleep(60)

async def notify_sync_status(application, user, trade, text: Optional[str] = None) -> None:
    """
    Edita o card para estado 'sincronizando' no 2Âº ciclo ausente.
    Evita repetir a mesma ediÃ§Ã£o em ciclos seguintes.
    """
    if trade is None or not getattr(trade, "notification_message_id", None):
        return

    cache = _SYNC_CACHE.setdefault(trade.id, {"sync_notified": False})
    if cache["sync_notified"]:
        return  # jÃ¡ notificou este estado; nÃ£o spammar

    sync_text = text or (
        "â³ <b>Sincronizando com a corretoraâ€¦</b>\n"
        "Estamos confirmando o status desta posiÃ§Ã£o. O card serÃ¡ atualizado automaticamente."
    )
    try:
        await application.bot.edit_message_text(
            chat_id=user.telegram_id,
            message_id=trade.notification_message_id,
            text=sync_text,
            parse_mode="HTML",
        )
        cache["sync_notified"] = True
        logger.info("[sync] %s/%s marcado como 'sincronizando' (2Âº ciclo ausente).",
                    trade.symbol, trade.side)
    except Exception:
        logger.exception("[sync] Falha ao editar mensagem para estado 'sincronizando' (%s).", trade.symbol)

def clear_sync_flag(trade_id: int) -> None:
    """Reseta a flag de sync para quando a posiÃ§Ã£o reaparece ou fecha definitivamente."""
    state = _SYNC_CACHE.get(trade_id)
    if state:
        state["sync_notified"] = False

async def confirm_and_close_trade(
    *,
    application,
    user,
    trade,
    get_last_closed_trade_info: Optional[Callable[[str], Awaitable[Optional[Dict[str, Any]]]]] = None,
    attempts: int = 3,
    delay_seconds: float = 6.0,
    fallback_text: Optional[str] = None,
) -> None:
    """
    Antes de marcar CLOSED_GHOST, tenta confirmar fechamento real.
    Se encontrar dados, edita o card com resumo e fecha; senÃ£o, usa fallback simples.
    """
    info = None
    if get_last_closed_trade_info:
        for i in range(1, attempts + 1):
            try:
                info = await get_last_closed_trade_info(trade.symbol)
                if info:
                    break
            except Exception:
                logger.exception("[close-confirm] tentativa %d falhou para %s", i, trade.symbol)
            await asyncio.sleep(delay_seconds)

        # Monta texto final (UX padronizada)
    def _fmt_money(v):
        try:
            return f"${float(v):,.2f}"
        except Exception:
            return str(v)

    side = getattr(trade, "side", "") or ""
    qty  = getattr(trade, "qty", None)
    entry = getattr(trade, "entry_price", None)

    if info:
        pnl = info.get("pnl")
        exit_type = (info.get("exit_type") or "Fechamento").strip()
        exit_price = info.get("exit_price")
        closed_at = info.get("closed_at")

        # TÃ­tulo amigÃ¡vel por tipo
        if str(exit_type).lower().startswith("take"):
            title = "ğŸ† PosiÃ§Ã£o Fechada (Take Profit)"
        elif str(exit_type).lower().startswith("stop"):
            title = "ğŸ›¡ï¸ PosiÃ§Ã£o Fechada (Stop)"
        else:
            title = "âœ… PosiÃ§Ã£o Fechada"

        lines = [f"<b>{title}</b> â€” <b>{trade.symbol}</b> {side}"]
        if qty is not None:
            lines.append(f"â€¢ Quantidade: <b>{qty:g}</b>")
        if entry is not None:
            lines.append(f"â€¢ Entrada: <b>{_fmt_money(entry)}</b>")
        if exit_price is not None:
            lines.append(f"â€¢ SaÃ­da: <b>{_fmt_money(exit_price)}</b>")
        if pnl is not None:
            pnl_prefix = "Lucro" if float(pnl) >= 0 else "PrejuÃ­zo"
            lines.append(f"â€¢ {pnl_prefix}: <b>{_fmt_money(pnl)}</b>")
        if closed_at:
            lines.append(f"â€¢ HorÃ¡rio: <b>{closed_at}</b>")

        final_text = "\n".join(lines)
    else:
        # Fallback neutro e informativo
        lines = [
            f"â„¹ï¸ <b>PosiÃ§Ã£o Encerrada</b> â€” <b>{trade.symbol}</b> {side}",
        ]
        if qty is not None:
            lines.append(f"â€¢ Quantidade: <b>{qty:g}</b>")
        if entry is not None:
            lines.append(f"â€¢ Entrada: <b>{_fmt_money(entry)}</b>")
        lines.append("â€¢ Detalhes de saÃ­da/PnL nÃ£o disponÃ­veis no momento.")
        lines.append("â€¢ O resumo pode aparecer nas prÃ³ximas sincronizaÃ§Ãµes.")
        final_text = "\n".join(lines)

    try:
        if getattr(trade, "notification_message_id", None):
            await application.bot.edit_message_text(
                chat_id=user.telegram_id,
                message_id=trade.notification_message_id,
                text=final_text,
                parse_mode="HTML",
            )
    except Exception:
        logger.exception("[close-confirm] Falha ao editar mensagem final para %s.", trade.symbol)

# [ATUALIZAÃ‡ÃƒO] polÃ­tica de tolerÃ¢ncia + UX etapa 2
async def apply_missing_cycles_policy(
    application,
    user,
    db,
    db_active_trades,
    bybit_keys,
    threshold: int = 3,
    get_last_closed_trade_info: Optional[Callable[[str], Awaitable[Optional[Dict[str, Any]]]]] = None,
):
    """
    - Vistas neste ciclo: zera missing_cycles, atualiza last_seen_at e limpa flag de sync.
    - Ausentes: incrementa missing_cycles.
      * 2Âº ciclo: edita mensagem para 'â³ Sincronizando...'
      * >=3Âº ciclo: roda detetive; se confirmar, edita resumo; senÃ£o, fallback; entÃ£o fecha.
    """
    bybit_symbols = {k[0] for k in bybit_keys}  # extrai sÃ³ o sÃ­mbolo do par (symbol, side)

    # 1) Trades vistas: reset + limpar flag de sync
    for t in db_active_trades:
        if t.symbol in bybit_symbols:
            if getattr(t, "missing_cycles", 0) != 0:
                logger.info("[sync] %s/%s visto novamente. Reset %dâ†’0.", t.symbol, t.side, t.missing_cycles)
            t.missing_cycles = 0
            t.last_seen_at = func.now()
            if getattr(t, "id", None) is not None:
                clear_sync_flag(t.id)

    # 2) Trades ausentes
    # ignoramos side: ausente se o sÃ­mbolo nÃ£o estÃ¡ vindo da Bybit
    for t in db_active_trades:
        if t.symbol in bybit_symbols:
            continue

        prev = int(getattr(t, "missing_cycles", 0) or 0)
        t.missing_cycles = prev + 1
        logger.warning("[sync] %s/%s ausente (ciclo %d/%d).", t.symbol, t.side, t.missing_cycles, threshold)

        # 2Âº ciclo â†’ mensagem neutra
        if t.missing_cycles == 2:
            await notify_sync_status(application, user, t)

            logger.info("[sync] %s/%s entrou em estado 'sincronizando' (ciclo 2/%d).", t.symbol, t.side, threshold)

        # 3Âº ciclo+ â†’ detetive e fechamento
        if t.missing_cycles >= threshold:

            logger.info("[sync] %s/%s atingiu limiar de fechamento (ciclo %d/%d). Iniciando detetiveâ€¦",
            t.symbol, t.side, t.missing_cycles, threshold)

            await confirm_and_close_trade(
                application=application,
                user=user,
                trade=t,
                get_last_closed_trade_info=get_last_closed_trade_info,
            )
            # marca fechado (mantÃ©m status por compatibilidade)
            t.status = "CLOSED_GHOST"
            t.closed_at = func.now()
            t.closed_pnl = t.closed_pnl or 0.0
            t.remaining_qty = 0.0
            if getattr(t, "id", None) is not None:
                clear_sync_flag(t.id)

async def _send_or_edit_trade_message(
    application: Application,
    user: User,
    trade: Trade,
    db: Session,
    text: str
) -> None:
    """
    Atualiza a 'mensagem viva' do trade de forma resiliente:
    - Se existe message_id â†’ tenta editar.
    - Se a ediÃ§Ã£o falhar (mensagem apagada/nÃ£o editÃ¡vel) â†’ envia nova
      e atualiza trade.notification_message_id no banco.
    """
    # 1) Tenta editar se jÃ¡ temos uma mensagem anterior
    if getattr(trade, "notification_message_id", None):
        try:
            await application.bot.edit_message_text(
                chat_id=user.telegram_id,
                message_id=trade.notification_message_id,
                text=text,
                parse_mode="HTML",
            )
            return  # sucesso, nada mais a fazer
        except BadRequest:
            # Qualquer falha tÃ­pica de ediÃ§Ã£o (apagada, muito antiga, etc.) â†’ recriar
            pass
        except Exception:
            # Falha inesperada â†’ tambÃ©m tenta recriar como fallback
            pass

    # 2) NÃ£o havia mensagem ou ediÃ§Ã£o falhou â†’ envia nova
    new_msg = await application.bot.send_message(
        chat_id=user.telegram_id,
        text=text,
        parse_mode="HTML",
    )
    trade.notification_message_id = new_msg.message_id
    logger.info("[msg:new] %s/%s nova_msg_id=%s",
            trade.symbol, trade.side, str(trade.notification_message_id))

    # 3) Persiste o novo ID no banco
    try:
        db.commit()
    except Exception:
        db.rollback()
        raise


========================================
# Arquivo: core/trade_manager.py
========================================

import os
import asyncio
import logging
import pytz
import pandas as pd
import pandas_ta as ta
from typing import Tuple
from telegram.ext import Application
from sqlalchemy.orm import Session
from database.session import SessionLocal
from database.models import User, Trade, PendingSignal, SignalForApproval
from services.bybit_service import (
    place_order, get_account_info,
    place_limit_order, cancel_order,
    get_order_history,
    get_historical_klines
)
from services.notification_service import send_notification
from utils.security import decrypt_data
from utils.config import ADMIN_ID
from bot.keyboards import signal_approval_keyboard
from services.signal_parser import SignalType
from core.whitelist_service import is_coin_in_whitelist
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)


async def _avaliar_sinal(signal_data: dict, user_settings: User) -> Tuple[bool, str]:
    """
    Avalia um sinal com base na confianÃ§a mÃ­nima e nos filtros de anÃ¡lise tÃ©cnica (MA e RSI), se ativos.
    """
    # Filtro 1: ConfianÃ§a MÃ­nima (lÃ³gica existente)
    min_confidence = user_settings.min_confidence
    signal_confidence = signal_data.get('confidence', 0.0)
    if signal_confidence is not None and signal_confidence < min_confidence:
        motivo = f"ConfianÃ§a ({signal_confidence:.2f}%) Ã© menor que o seu mÃ­nimo ({min_confidence:.2f}%)"
        return False, motivo

    # --- INÃCIO DA NOVA LÃ“GICA DE FILTROS TÃ‰CNICOS ---
    
    # Se nenhum filtro tÃ©cnico estiver ativo, aprova o sinal aqui
    if not user_settings.is_ma_filter_enabled and not user_settings.is_rsi_filter_enabled:
        return True, "Sinal aprovado pelos seus critÃ©rios."

    symbol = signal_data.get("coin")
    side = signal_data.get("order_type")
    
    # Unifica a busca de dados se os timeframes forem os mesmos para MA e RSI
    required_timeframes = set()
    if user_settings.is_ma_filter_enabled:
        required_timeframes.add(user_settings.ma_timeframe)
    if user_settings.is_rsi_filter_enabled:
        required_timeframes.add(user_settings.rsi_timeframe)

    hist_data_map = {}
    for tf in required_timeframes:
        klines_result = await get_historical_klines(symbol=symbol, interval=tf, limit=200)
        if not klines_result.get("success"):
            logger.warning(f"NÃ£o foi possÃ­vel obter dados histÃ³ricos para {symbol} no timeframe {tf}. Filtros para este timeframe serÃ£o ignorados.")
            hist_data_map[tf] = None
            continue
        
        # Converte os dados para um DataFrame do Pandas
        df = pd.DataFrame(klines_result['data'], columns=['startTime', 'open', 'high', 'low', 'close', 'volume', 'turnover'])
        df['close'] = pd.to_numeric(df['close']) # Garante que os preÃ§os sÃ£o numÃ©ricos
        hist_data_map[tf] = df

    # Filtro 2: MÃ©dia MÃ³vel (MA)
    if user_settings.is_ma_filter_enabled:
        df_ma = hist_data_map.get(user_settings.ma_timeframe)
        if df_ma is not None:
            ma_period = user_settings.ma_period
            df_ma.ta.sma(length=ma_period, append=True) # Calcula e adiciona a coluna da MA
            
            latest_close = df_ma['close'].iloc[0]
            latest_ma = df_ma[f'SMA_{ma_period}'].iloc[0]

            if side == 'LONG' and latest_close < latest_ma:
                return False, f"Rejeitado por MÃ©dia MÃ³vel (preÃ§o {latest_close:.4f} < MA {latest_ma:.4f})"
            if side == 'SHORT' and latest_close > latest_ma:
                return False, f"Rejeitado por MÃ©dia MÃ³vel (preÃ§o {latest_close:.4f} > MA {latest_ma:.4f})"

    # Filtro 3: Ãndice de ForÃ§a Relativa (RSI)
    if user_settings.is_rsi_filter_enabled:
        df_rsi = hist_data_map.get(user_settings.rsi_timeframe)
        if df_rsi is not None:
            oversold = user_settings.rsi_oversold_threshold
            overbought = user_settings.rsi_overbought_threshold
            df_rsi.ta.rsi(append=True) # Calcula e adiciona a coluna do RSI
            
            latest_rsi = df_rsi['RSI_14'].iloc[0]

            if side == 'LONG' and latest_rsi > overbought:
                return False, f"Rejeitado por RSI (RSI {latest_rsi:.2f} > Sobrecompra {overbought})"
            if side == 'SHORT' and latest_rsi < oversold:
                return False, f"Rejeitado por RSI (RSI {latest_rsi:.2f} < Sobrevenda {oversold})"
    
    # --- FIM DA NOVA LÃ“GICA ---

    return True, "Sinal aprovado pelos seus critÃ©rios e filtros tÃ©cnicos."

async def _execute_trade(signal_data: dict, user: User, application: Application, db: Session, source_name: str):
    """Executa uma ordem a MERCADO, busca os detalhes da execuÃ§Ã£o e envia uma notificaÃ§Ã£o detalhada."""
    if not user.is_active:
        await application.bot.send_message(
            chat_id=user.telegram_id,
            text="â¸ï¸ Bot estÃ¡ PAUSADO: nÃ£o abrirei novas posiÃ§Ãµes. (As posiÃ§Ãµes abertas seguem sendo gerenciadas.)"
        )
        return
    
    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)
    
    account_info = await get_account_info(api_key, api_secret)
    if not account_info.get("success"):
        await application.bot.send_message(chat_id=user.telegram_id, text=f"âŒ Falha ao buscar seu saldo Bybit para operar {signal_data['coin']}.")
        return

    balance_data = account_info.get("data", {})
    balance = float(balance_data.get('available_balance_usdt', 0))

    order_result = await place_order(api_key, api_secret, signal_data, user, balance)
    
    if order_result.get("success"):
        order_data = order_result['data']
        order_id = order_data['orderId']
        
        await asyncio.sleep(2)
        final_order_data_result = await get_order_history(api_key, api_secret, order_id)
        if not final_order_data_result.get("success"):
            await application.bot.send_message(chat_id=user.telegram_id, text=f"âš ï¸ Ordem {signal_data['coin']} enviada, mas falha ao confirmar detalhes. Verifique na corretora.")
            return
        final_order_data = final_order_data_result['data']
        
        symbol = signal_data['coin']
        side = signal_data['order_type']
        leverage = user.max_leverage
        qty = float(final_order_data.get('cumExecQty', 0))
        entry_price = float(final_order_data.get('avgPrice', 0))
        
        if qty == 0 or entry_price == 0:
            await application.bot.send_message(chat_id=user.telegram_id, text=f"âš ï¸ Ordem {symbol} enviada, mas a execuÃ§Ã£o reportou quantidade/preÃ§o zerado.")
            return
            
        margin = (qty * entry_price) / leverage if leverage > 0 else 0
        stop_loss = signal_data['stop_loss']
        
        all_targets = signal_data.get('targets') or []
        num_targets = len(all_targets)

        # COMENTÃRIO: LÃ³gica de formataÃ§Ã£o dos TPs foi refatorada para listar todos os alvos.
        tp_text_lines = []
        if all_targets:
            tp_text_lines.append("  - ğŸ¯ <b>Alvos (TPs):</b>")
            for i, target in enumerate(all_targets, 1):
                price = float(target)
                tp_text_lines.append(f"    - T{i}: ${price:,.4f}")
        else:
            tp_text_lines.append("  - ğŸ¯ <b>Take Profit:</b> N/A")
        tp_text = "\n".join(tp_text_lines)

        confidence_text = ""
        signal_confidence = signal_data.get('confidence')
        if signal_confidence is not None:
            confidence_text = f"  - ğŸŸ¢ <b>ConfianÃ§a:</b> {signal_confidence:.2f}%\n"

        message = (
            f"ğŸ“ˆ <b>Ordem a Mercado Aberta!</b>\n\n"
            f"{confidence_text}"
            f"  - ğŸ“Š <b>Tipo:</b> {side} | <b>Alavancagem:</b> {leverage}x\n"
            f"  - ğŸ’ <b>Moeda:</b> {symbol}\n"
            f"  - ğŸ”¢ <b>Quantidade:</b> {qty:g}\n"
            f"  - ğŸ’µ <b>PreÃ§o de Entrada:</b> ${entry_price:,.4f}\n"
            f"  - ğŸ’° <b>Margem:</b> ${margin:,.2f}\n"
            f"  - ğŸ›¡ï¸ <b>Stop Loss:</b> ${stop_loss:,.4f}\n"
            f"{tp_text}"
        )
        sent_message = await application.bot.send_message(chat_id=user.telegram_id, text=message, parse_mode='HTML')

        new_trade = Trade(
            user_telegram_id=user.telegram_id, order_id=order_id,
            notification_message_id=sent_message.message_id,
            symbol=symbol, side=side, qty=qty, entry_price=entry_price,
            stop_loss=stop_loss, current_stop_loss=stop_loss,
            initial_targets=all_targets,
            total_initial_targets=num_targets,
            status='ACTIVE',
            remaining_qty=qty
        )
        db.add(new_trade)
        logger.info(f"Trade {order_id} para o usuÃ¡rio {user.telegram_id} salvo no DB com dados de execuÃ§Ã£o.")

async def process_new_signal(signal_data: dict, application: Application, source_name: str):
    """Processa um novo sinal, verificando a preferÃªncia de cada usuÃ¡rio individualmente."""
    signal_type = signal_data.get("type")
    symbol = signal_data.get("coin")
    db = SessionLocal()
    try:
        if signal_type == SignalType.CANCELAR:
            # --- INÃCIO DA LÃ“GICA DE CANCELAMENTO CORRIGIDA ---
            logger.info(f"Recebido sinal de cancelamento para {symbol}. Buscando ordens pendentes...")
            
            pending_orders_to_cancel = db.query(PendingSignal).filter(PendingSignal.symbol == symbol).all()

            if not pending_orders_to_cancel:
                logger.info(f"Nenhuma ordem limite pendente encontrada para {symbol}. Nenhuma aÃ§Ã£o necessÃ¡ria.")
                return

            logger.info(f"Encontradas {len(pending_orders_to_cancel)} ordem(ns) pendente(s) para {symbol} para cancelar.")
            
            for pending in pending_orders_to_cancel:
                user = db.query(User).filter(User.telegram_id == pending.user_telegram_id).first()
                if not user or not user.api_key_encrypted:
                    logger.warning(f"NÃ£o foi possÃ­vel encontrar usuÃ¡rio ou chaves de API para a ordem pendente ID:{pending.id}. Pulando.")
                    continue

                api_key = decrypt_data(user.api_key_encrypted)
                api_secret = decrypt_data(user.api_secret_encrypted)

                cancel_result = await cancel_order(
                    api_key=api_key,
                    api_secret=api_secret,
                    order_id=pending.order_id,
                    symbol=pending.symbol
                )

                if cancel_result.get("success"):
                    logger.info(f"Ordem {pending.order_id} ({symbol}) cancelada com sucesso para o usuÃ¡rio {user.telegram_id}.")
                    db.delete(pending)
                    await application.bot.send_message(
                        chat_id=user.telegram_id,
                        text=f"â„¹ï¸ Sua ordem limite pendente para <b>{symbol}</b> foi cancelada pela fonte do sinal.",
                        parse_mode='HTML'
                    )
                else:
                    error_msg = cancel_result.get("error", "Erro desconhecido")
                    logger.error(f"Falha ao cancelar ordem {pending.order_id} ({symbol}) para o usuÃ¡rio {user.telegram_id}. Erro: {error_msg}")
                    await application.bot.send_message(
                        chat_id=user.telegram_id,
                        text=f"âš ï¸ Falha ao tentar cancelar sua ordem limite para <b>{symbol}</b>. Verifique na corretora.\n<b>Motivo:</b> {error_msg}",
                        parse_mode='HTML'
                    )
            
            db.commit()
            return

        elif signal_type in [SignalType.MARKET, SignalType.LIMIT]:
            all_users = db.query(User).filter(User.api_key_encrypted.isnot(None)).all()
            if not all_users:
                logger.info("Nenhum usuÃ¡rio com API para processar o sinal.")
                return

            logger.info(f"Sinal para {symbol} recebido. Verificando preferÃªncias de {len(all_users)} usuÃ¡rio(s)...")

            for user in all_users:
                if user.is_sleep_mode_enabled:
                    br_timezone = pytz.timezone("America/Sao_Paulo")
                    now_br = datetime.now(br_timezone).time()
                    
                    # O bot fica offline das 00:00 (incluso) atÃ© 07:00 (excluso)
                    if 0 <= now_br.hour < 7:
                        logger.info(f"Sinal para {symbol} ignorado para o usuÃ¡rio {user.telegram_id} devido ao Modo Dormir ativo.")
                        continue # Pula para o prÃ³ximo usuÃ¡rio

                # 1. Verifica se hÃ¡ uma pausa ativa para a direÃ§Ã£o do sinal
                signal_side = signal_data.get('order_type')
                is_paused = False
                if signal_side == 'LONG' and user.long_trades_paused_until and datetime.utcnow() < user.long_trades_paused_until:
                    is_paused = True
                elif signal_side == 'SHORT' and user.short_trades_paused_until and datetime.utcnow() < user.short_trades_paused_until:
                    is_paused = True
                
                if is_paused:
                    logger.info(f"Sinal de {signal_side} para {symbol} ignorado para o usuÃ¡rio {user.telegram_id} devido Ã  pausa do disjuntor.")
                    continue

                # 2. Se nÃ£o estiver pausado, verifica se o gatilho de perdas Ã© atingido
                if user.circuit_breaker_threshold > 0:
                    losing_trades_count = db.query(Trade).filter(
                        Trade.user_telegram_id == user.telegram_id,
                        Trade.side == signal_side,
                        Trade.status == 'ACTIVE',
                        Trade.unrealized_pnl_pct < 0
                    ).count()

                    if losing_trades_count >= user.circuit_breaker_threshold:
                        logger.warning(f"DISJUNTOR ATIVADO para {signal_side} para o usuÃ¡rio {user.telegram_id}. ({losing_trades_count} perdas ativas)")
                        
                        # Ativa a pausa
                        pause_until = datetime.now(pytz.utc) + timedelta(minutes=user.circuit_breaker_pause_minutes)
                        if signal_side == 'LONG':
                            user.long_trades_paused_until = pause_until
                        else: # SHORT
                            user.short_trades_paused_until = pause_until
                        
                        # Notifica o usuÃ¡rio
                        await application.bot.send_message(
                            chat_id=user.telegram_id,
                            text=f"ğŸš¨ <b>Disjuntor de Performance Ativado!</b> ğŸš¨\n\n"
                                 f"Detectamos {losing_trades_count} operaÃ§Ãµes de <b>{signal_side}</b> em prejuÃ­zo.\n"
                                 f"Para sua seguranÃ§a, novas operaÃ§Ãµes de <b>{signal_side}</b> estÃ£o pausadas por {user.circuit_breaker_pause_minutes} minutos.",
                            parse_mode='HTML'
                        )
                        continue # Rejeita o sinal atual

                # Adiciona uma verificaÃ§Ã£o para ver se o bot do usuÃ¡rio estÃ¡ ativo.
                if not user.is_active:
                    logger.info(f"Sinal para {symbol} ignorado para o usuÃ¡rio {user.telegram_id} porque o bot estÃ¡ pausado.")
                    continue

                # 1. Avalia o sinal contra os filtros do usuÃ¡rio
                aprovado, motivo = await _avaliar_sinal(signal_data, user)
                if not aprovado:
                    logger.info(f"Sinal para {symbol} ignorado para o usuÃ¡rio {user.telegram_id}: {motivo}")
                    continue
                
                # 2. Verifica a whitelist do usuÃ¡rio
                if not is_coin_in_whitelist(symbol, user.coin_whitelist):
                    logger.info(f"Sinal para {symbol} ignorado para o usuÃ¡rio {user.telegram_id} devido Ã  whitelist.")
                    continue

                # 3. Verifica o modo de aprovaÃ§Ã£o individual do usuÃ¡rio
                if user.approval_mode == 'AUTOMATIC':
                    logger.info(f"UsuÃ¡rio {user.telegram_id} em modo AUTOMÃTICO. Executando trade para {symbol}.")
                    if signal_type == SignalType.MARKET:
                        await _execute_trade(signal_data, user, application, db, source_name)
                    elif signal_type == SignalType.LIMIT:
                        await _execute_limit_order_for_user(signal_data, user, application, db)

                elif user.approval_mode == 'MANUAL':
                    logger.info(f"UsuÃ¡rio {user.telegram_id} em modo MANUAL. Enviando sinal para sua aprovaÃ§Ã£o.")
                    
                    new_signal_for_approval = SignalForApproval(
                        user_telegram_id=user.telegram_id,  # <-- Agora salva o ID do usuÃ¡rio correto
                        symbol=symbol,
                        source_name=source_name,
                        signal_data=signal_data
                    )
                    db.add(new_signal_for_approval)
                    db.commit() # Commit para obter o ID

                    signal_details = (
                        f"<b>Sinal Recebido para AprovaÃ§Ã£o</b>\n\n"
                        f"<b>Moeda:</b> {signal_data['coin']}\n"
                        f"<b>Tipo:</b> {signal_data['order_type']}\n<b>Entrada:</b> {signal_data['entries'][0]}\n"
                        f"<b>Stop:</b> {signal_data['stop_loss']}\n<b>Alvo 1:</b> {signal_data['targets'][0]}\n\n"
                        f"O sinal passou nos seus filtros. VocÃª aprova a entrada?"
                    )
                    sent_message = await application.bot.send_message(
                        chat_id=user.telegram_id, # <-- Envia para o usuÃ¡rio especÃ­fico
                        text=signal_details, parse_mode='HTML',
                        reply_markup=signal_approval_keyboard(new_signal_for_approval.id)
                    )
                    new_signal_for_approval.approval_message_id = sent_message.message_id
        
        db.commit()
    finally:
        db.close()

async def _execute_limit_order_for_user(signal_data: dict, user: User, application: Application, db: Session):
    """FunÃ§Ã£o auxiliar para posicionar uma ordem limite para um Ãºnico usuÃ¡rio."""
    if not user.is_active:
        await application.bot.send_message(
            chat_id=user.telegram_id,
            text="â¸ï¸ Bot estÃ¡ PAUSADO: nÃ£o abrirei novas posiÃ§Ãµes. (As posiÃ§Ãµes abertas seguem sendo gerenciadas.)"
        )
        return

    symbol = signal_data.get("coin")
    existing_pending = db.query(PendingSignal).filter_by(user_telegram_id=user.telegram_id, symbol=symbol).first()
    if existing_pending:
        await application.bot.send_message(chat_id=user.telegram_id, text=f"â„¹ï¸ VocÃª jÃ¡ tem uma ordem limite pendente para <b>{symbol}</b>.", parse_mode='HTML')
        return

    entries = (signal_data.get('entries') or [])[:2]
    if not entries:
        logger.warning(f"Sinal LIMIT para {symbol} sem preÃ§os de entrada vÃ¡lidos.")
        return

    limit_price = float(min(entries)) if (signal_data.get('order_type') or '').upper() == 'LONG' else float(max(entries))
    signal_data['limit_price'] = limit_price

    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)
    account_info = await get_account_info(api_key, api_secret)
    if not account_info.get("success"):
        logger.error(f"Falha ao buscar saldo para usuÃ¡rio {user.telegram_id} ao posicionar LIMIT em {symbol}.")
        return

    balance = float(account_info.get("data", {}).get('available_balance_usdt', 0))
    limit_order_result = await place_limit_order(api_key, api_secret, signal_data, user, balance)

    if limit_order_result.get("success"):
        order_id = limit_order_result["data"]["orderId"]
        
        # COMENTÃRIO: LÃ³gica de formataÃ§Ã£o dos TPs foi refatorada para listar todos os alvos.
        all_targets = signal_data.get('targets') or []
        tp_text_lines = []
        if all_targets:
            tp_text_lines.append("  - ğŸ¯ <b>Alvos (TPs):</b>")
            for i, target in enumerate(all_targets, 1):
                price = float(target)
                tp_text_lines.append(f"    - T{i}: ${price:,.4f}")
        else:
            tp_text_lines.append("  - ğŸ¯ <b>Take Profit:</b> N/A")
        tp_text = "\n".join(tp_text_lines)
        
        confidence_text = ""
        signal_confidence = signal_data.get('confidence')
        if signal_confidence is not None:
            confidence_text = f"  - ğŸŸ¢ <b>ConfianÃ§a:</b> {signal_confidence:.2f}%\n"

        message = (
            f"âœ… <b>Ordem Limite Posicionada!</b>\n\n"
            f"{confidence_text}"
            f"  - ğŸ“Š <b>Tipo:</b> {signal_data.get('order_type')} | <b>Alavancagem:</b> {user.max_leverage}x\n"
            f"  - ğŸ’ <b>Moeda:</b> {symbol}\n"
            f"  - ğŸ¯ <b>PreÃ§o de Entrada:</b> ${limit_price:,.4f}\n"
            f"  - ğŸ›¡ï¸ <b>Stop Loss:</b> ${signal_data.get('stop_loss'):,.4f}\n"
            f"{tp_text}\n\n"
            f"ğŸ‘€ Monitorando a execuÃ§Ã£oâ€¦"
        )
   
        sent_message = await application.bot.send_message(chat_id=user.telegram_id, text=message, parse_mode='HTML')
        
        db.add(PendingSignal(
            user_telegram_id=user.telegram_id, 
            symbol=symbol, 
            order_id=order_id, 
            signal_data=signal_data,
            notification_message_id=sent_message.message_id
        ))
    else:
        error = limit_order_result.get('error') or "Erro desconhecido"
        await application.bot.send_message(chat_id=user.telegram_id, text=f"âŒ Falha ao posicionar sua ordem limite para <b>{symbol}</b>.\n<b>Motivo:</b> {error}", parse_mode='HTML')


========================================
# Arquivo: core/whitelist_service.py
========================================

import logging
from typing import Set

logger = logging.getLogger(__name__)

# --- CATEGORIAS DE MOEDAS ---
# Usamos Sets para performance e para evitar duplicatas.
# As listas foram expandidas para incluir o mÃ¡ximo de ativos relevantes dentro das categorias originais.

# Moedas "blue chips" clÃ¡ssicas, de altÃ­ssima capitalizaÃ§Ã£o.
BLUECHIPS: Set[str] = {
    'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT'
}

# Moedas de grande capitalizaÃ§Ã£o e projetos estabelecidos (Layer 1 e Layer 2)
ALTCOINS_L1_L2: Set[str] = {
    'ADAUSDT', 'ALGOUSDT', 'APTUSDT', 'ARBUSDT', 'ATOMUSDT', 'AVAXUSDT', 'DOTUSDT', 
    'EGLDUSDT', 'EOSUSDT', 'ETCUSDT', 'FTMUSDT', 'HBARUSDT', 'ICPUSDT', 'IMXUSDT', 
    'INJUSDT', 'KASUSDT', 'KSMUSDT', 'LTCUSDT', 'MATICUSDT', 'MINAUSDT', 'NEARUSDT', 
    'OPUSDT', 'SEIUSDT', 'STXUSDT', 'SUIUSDT', 'TIAUSDT', 'TONUSDT', 'TRXUSDT', 
    'VETUSDT', 'XLMUSDT', 'XMRUSDT', 'XRPUSDT', 'XTZUSDT', 'ZECUSDT', 'ZENUSDT'
}

# Moedas relacionadas a FinanÃ§as Descentralizadas (DeFi)
DEFI: Set[str] = {
    '1INCHUSDT', 'AAVEUSDT', 'BALUSDT', 'CAKEUSDT', 'COMPUSDT', 'CRVUSDT', 
    'CVXUSDT', 'DYDXUSDT', 'GMXUSDT', 'JUPUSDT', 'KNCUSDT', 'LDOUSDT', 'LINKUSDT', 
    'LRCUSDT', 'MKRUSDT', 'PENDLEUSDT', 'RUNEUSDT', 'SNXUSDT', 'SUSHIUSDT', 
    'UMAUSDT', 'UNIUSDT', 'WOOUSDT', 'YFIUSDT', 'ZRXUSDT'
}

# Moedas de "memes" com alta volatilidade
MEMECOINS: Set[str] = {
    'BONKUSDT', 'DOGEUSDT', 'FLOKIUSDT', 'MEMEUSDT', 'ORDIUSDT', 'PEPEUSDT', 
    'SATSUSDT', 'SHIBUSDT', 'WIFUSDT'
}

# Camada de infraestrutura, orÃ¡culos e DePIN (Redes de Infraestrutura FÃ­sica Descentralizada)
INFRA: Set[str] = {
    'ANKRUSDT', 'ARUSDT', 'BTTUSDT', 'FILUSDT', 'GRTUSDT', 'HNTUSDT', 'LINKUSDT', 
    'OCEANUSDT', 'RNDRUSDT', 'STORJUSDT', 'THETAUSDT'
}


# DicionÃ¡rio que mapeia a palavra-chave da categoria para o Set de moedas
CATEGORIES = {
    'bluechips': BLUECHIPS,
    'altcoins': ALTCOINS_L1_L2,
    'defi': DEFI,
    'infra': INFRA,
    'memecoins': MEMECOINS,
}

def is_coin_in_whitelist(symbol: str, user_whitelist_str: str) -> bool:
    """
    Verifica se um sÃ­mbolo de moeda estÃ¡ na whitelist de um usuÃ¡rio.

    A whitelist pode conter:
    - O keyword 'todas'.
    - SÃ­mbolos especÃ­ficos (ex: 'btcusdt').
    - Keywords de categorias (ex: 'memecoins').
    """
    if not user_whitelist_str or 'todas' in user_whitelist_str.lower():
        return True

    # Normaliza a entrada do usuÃ¡rio: minÃºsculas, remove espaÃ§os, divide por vÃ­rgula
    user_list = {item.strip() for item in user_whitelist_str.lower().split(',')}
    
    # 1. Verifica se o sÃ­mbolo exato estÃ¡ na lista do usuÃ¡rio
    if symbol.lower() in user_list:
        return True

    # 2. Verifica se alguma das categorias da lista do usuÃ¡rio contÃ©m o sÃ­mbolo
    for category_keyword in user_list:
        if category_keyword in CATEGORIES and symbol.upper() in CATEGORIES[category_keyword]:
            return True
            
    # Se nenhuma das condiÃ§Ãµes acima for atendida, a moeda nÃ£o estÃ¡ na whitelist
    return False

========================================
# Arquivo: tests/__init__.py
========================================



========================================
# Arquivo: tests/test_missing_cycles_policy.py
========================================

import asyncio
import types

class FakeBot:
    def __init__(self): self.edits = []
    async def edit_message_text(self, chat_id, message_id, text, parse_mode=None):
        self.edits.append((chat_id, message_id, text))

class FakeApp:
    def __init__(self): self.bot = FakeBot()

class T:
    # Mock minimal de Trade
    def __init__(self, symbol, side, missing_cycles=0, notification_message_id=123):
        self.symbol = symbol; self.side = side
        self.status = "ACTIVE"; self.closed_pnl = None
        self.remaining_qty = 1.0; self.notification_message_id = notification_message_id
        self.missing_cycles = missing_cycles
        self.last_seen_at = None

async def _run(policy, bybit_keys, trades, threshold=3):
    app = FakeApp()
    user = types.SimpleNamespace(telegram_id=111)
    db = object()
    await policy(app, user, db, trades, bybit_keys, threshold)
    return app.bot.edits

def test_nao_fecha_em_1_ou_2_ciclos(event_loop=None):
    from main import apply_missing_cycles_policy  # ajuste o import conforme onde vocÃª adicionou a funÃ§Ã£o

    trades = [T("TIAUSDT", "LONG")]
    # 1Âº ciclo ausente
    edits = asyncio.get_event_loop().run_until_complete(_run(apply_missing_cycles_policy, set(), trades))
    assert trades[0].missing_cycles == 1
    assert trades[0].status == "ACTIVE"
    assert edits == []

    # 2Âº ciclo ausente
    edits = asyncio.get_event_loop().run_until_complete(_run(apply_missing_cycles_policy, set(), trades))
    assert trades[0].missing_cycles == 2
    assert trades[0].status == "ACTIVE"
    assert edits == []

def test_fecha_no_3o_ciclo(event_loop=None):
    from main import apply_missing_cycles_policy

    trades = [T("TIAUSDT", "LONG", missing_cycles=2)]
    edits = asyncio.get_event_loop().run_until_complete(_run(apply_missing_cycles_policy, set(), trades))
    assert trades[0].missing_cycles == 3
    assert trades[0].status == "CLOSED_GHOST"
    assert trades[0].remaining_qty == 0.0
    assert len(edits) == 1  # mensagem de remoÃ§Ã£o enviada

def test_reset_quando_volta_a_aparecer(event_loop=None):
    from main import apply_missing_cycles_policy

    trades = [T("TIAUSDT", "LONG", missing_cycles=2)]
    edits = asyncio.get_event_loop().run_until_complete(_run(apply_missing_cycles_policy, {("TIAUSDT","LONG")}, trades))
    assert trades[0].missing_cycles == 0
    assert trades[0].status == "ACTIVE"
    assert len(edits) == 0

========================================
# Arquivo: tests/test_signal_cyber_e2e.py
========================================

# tests/test_signal_cyber_e2e.py
import sys
import types
import textwrap
import pytest

# ======== STUBS mÃ­nimos (telegram e keyboards) ========
telegram = types.ModuleType("telegram")
telegram_ext = types.ModuleType("telegram.ext")
telegram_constants = types.ModuleType("telegram.constants")

class InlineKeyboardButton:
    def __init__(self, text, callback_data=None, url=None):
        self.text = text; self.callback_data = callback_data; self.url = url

class InlineKeyboardMarkup:
    def __init__(self, keyboard): self.keyboard = keyboard

class Application:
    def __init__(self): self.bot = None

telegram.InlineKeyboardButton = InlineKeyboardButton
telegram.InlineKeyboardMarkup = InlineKeyboardMarkup
telegram.constants = telegram_constants
telegram_ext.Application = Application

sys.modules.setdefault("telegram", telegram)
sys.modules.setdefault("telegram.ext", telegram_ext)
sys.modules.setdefault("telegram.constants", telegram_constants)

bot_pkg = types.ModuleType("bot")
bot_keyboards = types.ModuleType("bot.keyboards")
def signal_approval_keyboard(signal_id: int):
    return InlineKeyboardMarkup([[InlineKeyboardButton("Aprovar", callback_data=f"approve:{signal_id}")]])
bot_keyboards.signal_approval_keyboard = signal_approval_keyboard
sys.modules.setdefault("bot", bot_pkg)
sys.modules.setdefault("bot.keyboards", bot_keyboards)

# ======== Imports reais do projeto ========
from services.signal_parser import parse_signal, SignalType
import core.trade_manager as tm

# ======== Fakes utilitÃ¡rios ========
class FakeUser:
    def __init__(self, telegram_id=111, api_key_encrypted="enc_k", api_secret_encrypted="enc_s"):
        self.telegram_id = telegram_id
        self.api_key_encrypted = api_key_encrypted
        self.api_secret_encrypted = api_secret_encrypted

class _QueryList:
    def __init__(self, data_list): self._data = data_list
    def filter(self, *a, **k): return self
    def filter_by(self, **k):
        def ok(obj): return all(getattr(obj, kk, None) == vv for kk, vv in k.items())
        return _QueryList([x for x in self._data if ok(x)])
    def all(self): return list(self._data)
    def first(self): return self._data[0] if self._data else None

class FakeDB:
    def __init__(self, users=None, pendings=None):
        self._users = users or []
        self._pendings = pendings or []
        self.added = []; self.deleted = []; self.commits = 0
    def query(self, Model):
        if Model is tm.User: return _QueryList(self._users)
        if Model is tm.PendingSignal: return _QueryList(self._pendings)
        return _QueryList([])
    def add(self, obj):
        self.added.append(obj)
        if isinstance(obj, tm.PendingSignal) or getattr(obj, "__class__", None).__name__ == "DummyPending":
            self._pendings.append(obj)
    def delete(self, obj):
        self.deleted.append(obj)
        if obj in self._pendings: self._pendings.remove(obj)
    def commit(self): self.commits += 1

class FakeBot:
    def __init__(self): self.sent = []
    async def send_message(self, **kwargs): self.sent.append(kwargs)

class FakeApplication(Application):
    def __init__(self): super().__init__(); self.bot = FakeBot()

# ======== Sinal CYBER (LIMIT/SHORT) ========
CYBER_SIGNAL = textwrap.dedent("""
â³ #38792 - Ordem Limite

ğŸ’ Moeda: CYBER
ğŸ“Š Tipo: SHORT (Futures)

ğŸ’° Zona de Entrada: 2.52500000 - 2.64000000
ğŸ›‘ Stop Loss: 2.90000000 (12.2943%)
ğŸ¯ Alvos:
T1: 2.44000000 (5.52%)
T2: 2.37000000 (8.23%)
T3: 2.29000000 (11.33%)
T4: 2.20000000 (14.81%)
""")

@pytest.mark.asyncio
async def test_cyber_limit_short_positions_limit_order(monkeypatch):
    parsed = parse_signal(CYBER_SIGNAL)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "SHORT"
    assert parsed["coin"] == "CYBERUSDT"
    assert parsed["entries"] == [2.525, 2.64]
    assert parsed["stop_loss"] == 2.9

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=777)])

    # dummy PendingSignal para nÃ£o depender de SQLAlchemy real
    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    # Capturas
    called = {"market": False, "limit_payload": None}

    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        # guardamos o payload passado â€” deve conter limit_price = 2.64
        called["limit_payload"] = dict(signal_data)
        return {"success": True, "data": {"orderId": "CYB-LIM-001"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "123.45"}]}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    # patches
    monkeypatch.setattr(tm, "place_order", fake_place_order)  # nÃ£o deve ser chamado
    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # 1) NÃƒO abriu a mercado
    assert not called["market"], "LIMIT/SHORT nÃ£o deve abrir ordem a mercado"

    # 2) Chamou limit com limit_price = 2.64 (maior da faixa)
    assert called["limit_payload"] is not None, "place_limit_order nÃ£o foi chamado"
    assert called["limit_payload"].get("limit_price") == pytest.approx(2.64, rel=1e-6)

    # 3) Criou PendingSignal
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal nÃ£o foi criado"

    # 4) Enviou mensagem ao usuÃ¡rio
    assert app.bot.sent, "Nenhuma mensagem foi enviada ao usuÃ¡rio"
    texts = [m.get("text", "").lower() for m in app.bot.sent]
    assert any("limite" in t or "monitorando" in t for t in texts), texts


========================================
# Arquivo: tests/test_signal_parser.py
========================================

import textwrap

from services.signal_parser import parse_signal, SignalType


def test_parse_signal_without_diamond():
    message = textwrap.dedent(
        """
        â³ #1 - Ordem Limite
        Moeda: SOL
        Tipo: SHORT (Futures)
        Zona de Entrada: 182.66 - 182.66
        Stop Loss: 186.36
        Alvos:
        T1: 181.18
        """
    )

    data = parse_signal(message)

    assert data["coin"] == "SOLUSDT"
    assert data["type"] == SignalType.LIMIT


def test_parse_signal_with_coin_synonym():
    message = textwrap.dedent(
        """
        â³ #2 - Ordem Limite
        Coin: NMR
        Tipo: SHORT (Futures)
        Zona de Entrada: 8.04 - 8.28
        Stop Loss: 8.55
        Alvos:
        T1: 7.99
        """
    )

    data = parse_signal(message)

    assert data["coin"] == "NMRUSDT"
    assert data["type"] == SignalType.LIMIT


def test_parse_complex_signal_with_emojis_and_extra_text():
    message = textwrap.dedent(
        """
        â³ #38792 - Ordem Limite

        ğŸ“¢ Canal: GRE - 58
        ğŸŒ Plataforma: telegram

        ğŸ’ Moeda: CYBER
        ğŸ“Š Tipo: SHORT (Futures)
        ğŸ“ˆ Alavancagem: 10x

        ğŸ’° Zona de Entrada: 2.52500000 - 2.64000000
        ğŸ›‘ Stop Loss: 2.90000000 (12.2943%)
        ğŸ¯ Alvos:
        T1: 2.44000000 (5.52%)
        T2: 2.37000000 (8.23%)
        T3: 2.29000000 (11.33%)
        T4: 2.20000000 (14.81%)
        â˜¯ï¸ R/R ratio: 0.4

        ğŸ“Š Status: Sinal aberto

        ğŸŸ¢ ConfianÃ§a: 66.67%  ğŸ§­ Consenso: 4/6
        """
    )

    data = parse_signal(message)

    assert data is not None, "O parser nÃ£o deveria retornar None para este sinal"
    assert data["type"] == SignalType.LIMIT
    assert data["coin"] == "CYBERUSDT"
    assert data["order_type"] == "SHORT"
    assert data["entries"] == [2.525, 2.64]
    assert data["stop_loss"] == 2.9
    assert data["targets"] == [2.44, 2.37, 2.29, 2.2]
    assert data["confidence"] == 66.67



# --- NOVO TESTE: MARKET (Ordem Ã  Mercado) ---
def test_parse_market_signal_with_accent():
    message = textwrap.dedent(
        """
        ğŸ #39170 - Ordem Ã  Mercado

        ğŸ’ Moeda: AVAX
        ğŸ“Š Tipo: SHORT (Futures)

        ğŸ’° Zona de Entrada: 22.85000000 - 22.85000000
        ğŸ›‘ Stop Loss: 24.22000000
        Alvos:
        T1: 22.69000000
        T2: 22.55000000
        """
    )

    data = parse_signal(message)

    assert data is not None
    assert data["type"] == SignalType.MARKET
    assert data["coin"] == "AVAXUSDT"
    assert data["order_type"] == "SHORT"
    assert data["entries"][0] == 22.85
    assert data["stop_loss"] == 24.22
    assert 22.69 in data["targets"]
    assert 22.55 in data["targets"]


# --- NOVO TESTE: CANCELAR ---
def test_parse_cancel_signal():
    message = textwrap.dedent(
        """
        âš ï¸ BTC sinal cancelado
        """
    )

    data = parse_signal(message)

    assert data is not None
    assert data["type"] == SignalType.CANCELAR
    assert data["coin"] == "BTCUSDT"


========================================
# Arquivo: tests/test_trade_manager_e2e.py
========================================

# tests/test_trade_manager_e2e.py

import sys
import types
import textwrap
import pytest

# ===========================
# STUBS: telegram e bot.keyboards
# ===========================
telegram = types.ModuleType("telegram")
telegram_ext = types.ModuleType("telegram.ext")
telegram_constants = types.ModuleType("telegram.constants")

class InlineKeyboardButton:
    def __init__(self, text, callback_data=None, url=None):
        self.text = text
        self.callback_data = callback_data
        self.url = url

class InlineKeyboardMarkup:
    def __init__(self, keyboard):
        self.keyboard = keyboard

class Application:
    def __init__(self):
        self.bot = None

# expÃµe no mÃ³dulo stub
telegram.InlineKeyboardButton = InlineKeyboardButton
telegram.InlineKeyboardMarkup = InlineKeyboardMarkup
telegram.constants = telegram_constants
telegram_ext.Application = Application

# registra stubs
sys.modules.setdefault("telegram", telegram)
sys.modules.setdefault("telegram.ext", telegram_ext)
sys.modules.setdefault("telegram.constants", telegram_constants)

# bot.keyboards stub (para satisfazer "from bot.keyboards import signal_approval_keyboard")
bot_pkg = types.ModuleType("bot")
bot_keyboards = types.ModuleType("bot.keyboards")
def signal_approval_keyboard(signal_id: int):
    return InlineKeyboardMarkup([[InlineKeyboardButton("Aprovar", callback_data=f"approve:{signal_id}")]])
bot_keyboards.signal_approval_keyboard = signal_approval_keyboard
sys.modules.setdefault("bot", bot_pkg)
sys.modules.setdefault("bot.keyboards", bot_keyboards)

# ===========================
# Imports reais do projeto
# ===========================
from services.signal_parser import parse_signal, SignalType
import core.trade_manager as tm


# ===========================
# Fakes utilitÃ¡rios
# ===========================
class FakeUser:
    def __init__(self, telegram_id=111, api_key_encrypted="enc_k", api_secret_encrypted="enc_s", min_confidence=0.0, approval_mode="AUTOMATIC"):
        self.telegram_id = telegram_id
        self.api_key_encrypted = api_key_encrypted
        self.api_secret_encrypted = api_secret_encrypted
        self.min_confidence = min_confidence
        self.approval_mode = approval_mode

class _QueryList:
    def __init__(self, data_list):
        self._data = data_list
    def filter(self, *args, **kwargs):  # compat simples
        return self
    def filter_by(self, **kwargs):
        # ImplementaÃ§Ã£o leve para casos .filter_by(user_telegram_id=..., symbol=...)
        def match(obj):
            return all(getattr(obj, k, None) == v for k, v in kwargs.items())
        return _QueryList([x for x in self._data if match(x)])
    def all(self):
        return list(self._data)
    def first(self):
        return self._data[0] if self._data else None

class FakeDB:
    """DB fake que suporta .query(Model) e listas de users/pendings."""
    def __init__(self, users=None, pendings=None):
        self._users = users or []
        self._pendings = pendings or []
        self.added = []
        self.deleted = []
        self.commits = 0
        self.closed = False
    def query(self, Model):
        if Model is tm.User:
            return _QueryList(self._users)
        if Model is tm.PendingSignal:
            return _QueryList(self._pendings)
        if Model is tm.Trade:
            # raramente consultado em testes; devolve vazio
            return _QueryList([])
        if Model is tm.SignalForApproval:
            return _QueryList([])
        return _QueryList([])
    def add(self, obj):
        self.added.append(obj)
        # se for PendingSignal "persistido", tambÃ©m aparece em consultas subsequentes
        if isinstance(obj, tm.PendingSignal) or getattr(obj, "__class__", None).__name__ == "DummyPending":
            self._pendings.append(obj)
    def delete(self, obj):
        self.deleted.append(obj)
        if obj in self._pendings:
            self._pendings.remove(obj)
    def commit(self):
        self.commits += 1
    def close(self):
        self.closed = True

class FakeBot:
    def __init__(self):
        self.sent = []
    async def send_message(self, **kwargs):
        self.sent.append(kwargs)

class FakeApplication(Application):
    def __init__(self):
        super().__init__()
        self.bot = FakeBot()


# ===========================
# Textos de sinais
# ===========================
MARKET_SIGNAL = textwrap.dedent("""
ğŸ #39170 - Ordem Ã  Mercado

ğŸ’ Moeda: AVAX
ğŸ“Š Tipo: SHORT (Futures)

ğŸ’° Zona de Entrada: 22.85000000 - 22.85000000
ğŸ›‘ Stop Loss: 24.22000000
Alvos:
T1: 22.69000000
T2: 22.55000000
""")

LIMIT_SIGNAL_SHORT = textwrap.dedent("""
â³ #38792 - Ordem Limite

ğŸ’ Moeda: CYBER
ğŸ“Š Tipo: SHORT (Futures)

ğŸ’° Zona de Entrada: 2.52500000 - 2.64000000
ğŸ›‘ Stop Loss: 2.90000000
Alvos:
T1: 2.44000000
T2: 2.37000000
T3: 2.29000000
T4: 2.20000000
""")

LIMIT_SIGNAL_LONG = textwrap.dedent("""
â³ #50001 - Ordem Limite

ğŸ’ Moeda: XRP
ğŸ“Š Tipo: LONG (Futures)

ğŸ’° Zona de Entrada: 0.4500 - 0.4510
ğŸ›‘ Stop Loss: 0.4400
Alvos:
T1: 0.4600
T2: 0.4700
""")

CANCEL_SIGNAL_XRP = "âš ï¸ XRP sinal cancelado"


# ===========================
# TESTES
# ===========================
@pytest.mark.asyncio
async def test_market_flow_calls_place_order(monkeypatch):
    parsed = parse_signal(MARKET_SIGNAL)
    assert parsed and parsed["type"] == SignalType.MARKET

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=999)])

    class DummyTrade:
        def __init__(self, **kwargs):
            self.kwargs = kwargs

    called = {}
    async def fake_place_order(api_key, api_secret, signal_data, user, balance):
        called["api_key"] = api_key
        called["api_secret"] = api_secret
        called["signal_data"] = signal_data
        called["user_id"] = user.telegram_id
        called["balance"] = balance
        return {"success": True, "data": {"orderId": "fake-123", "qty": "1.0"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "100.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_order", fake_place_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "Trade", DummyTrade)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # ValidaÃ§Ãµes
    assert called, "place_order nÃ£o foi chamado"
    assert called["user_id"] == 999
    assert called["signal_data"]["coin"] == "AVAXUSDT"
    assert called["signal_data"]["order_type"] == "SHORT"
    assert called["signal_data"]["entries"][0] == pytest.approx(22.85, rel=1e-6)
    assert called["signal_data"]["stop_loss"] == pytest.approx(24.22, rel=1e-6)
    assert called["balance"] == 100.0

    # Mensagem ao usuÃ¡rio
    assert app.bot.sent, "Nenhuma mensagem foi enviada"
    texts = [m.get("text", "").lower() for m in app.bot.sent]
    assert any(("ordem" in t) or ("aberta" in t) or ("sucesso" in t) for t in texts), texts


@pytest.mark.asyncio
async def test_limit_short_creates_pending_and_uses_upper_bound(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_SHORT)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "SHORT"

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=777)])

    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    called = {"market": False, "limit": None}

    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        called["limit"] = dict(signal_data)  # capturar signal_data com limit_price
        return {"success": True, "data": {"orderId": "LIM-001"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "50.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_order", fake_place_order)  # nÃ£o deve ser chamado
    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # NÃ£o deve ter chamado market
    assert not called["market"], "LIMIT (SHORT) nÃ£o deve abrir ordem a mercado"
    # Deve ter chamado limit com limit_price == high (2.64000000)
    assert called["limit"] and called["limit"].get("limit_price") == pytest.approx(2.64, rel=1e-6)
    # Deve ter criado PendingSignal e avisado usuÃ¡rio
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal nÃ£o criado"
    assert app.bot.sent, "Sem mensagem de confirmaÃ§Ã£o ao usuÃ¡rio"


@pytest.mark.asyncio
async def test_limit_long_uses_lower_bound(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_LONG)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "LONG"

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=888)])

    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    called = {"limit": None}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        called["limit"] = dict(signal_data)
        return {"success": True, "data": {"orderId": "LIM-002"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "80.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    assert called["limit"] is not None, "place_limit_order nÃ£o foi chamado"
    assert called["limit"]["limit_price"] == pytest.approx(0.4500, rel=1e-6), "LONG deve usar menor preÃ§o da faixa"
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal nÃ£o criado"
    assert app.bot.sent, "Sem mensagem ao usuÃ¡rio"


@pytest.mark.asyncio
async def test_limit_skips_when_existing_pending(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_LONG)
    assert parsed and parsed["type"] == SignalType.LIMIT

    app = FakeApplication()

    class DummyPending:
        def __init__(self, user_telegram_id, symbol, order_id="old", signal_data=None):
            self.user_telegram_id = user_telegram_id
            self.symbol = symbol
            self.order_id = order_id
            self.signal_data = signal_data or {}

    # jÃ¡ existe um pendente para o mesmo sÃ­mbolo e usuÃ¡rio
    existing = DummyPending(user_telegram_id=777, symbol="XRPUSDT")
    db = FakeDB(users=[FakeUser(telegram_id=777)], pendings=[existing])

    called = {"limit": False}
    async def fake_place_limit_order(*a, **k):
        called["limit"] = True
        return {"success": True}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")
    async def fake_get_account_info(api_key, api_secret): return {"success": True, "data": [{"totalEquity": "10"}]}

    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # nÃ£o deve chamar place_limit_order
    assert not called["limit"], "NÃ£o deveria tentar posicionar nova LIMIT com pendente existente"
    # deve ter avisado usuÃ¡rio
    assert app.bot.sent and any("jÃ¡ tem uma ordem limite pendente" in (m.get("text","")) for m in app.bot.sent)


@pytest.mark.asyncio
async def test_cancel_removes_pending_and_notifies(monkeypatch):
    # preparar db com pending XRP para user 123
    class DummyPending:
        def __init__(self, user_telegram_id, symbol, order_id="LIM-XYZ", signal_data=None):
            self.user_telegram_id = user_telegram_id
            self.symbol = symbol
            self.order_id = order_id
            self.signal_data = signal_data or {}

    pend = DummyPending(user_telegram_id=123, symbol="XRPUSDT")
    users = [FakeUser(telegram_id=123)]
    base_db = FakeDB(users=users, pendings=[pend])

    # monkeypatch SessionLocal para devolver nosso FakeDB
    def fake_SessionLocal():
        # devolve uma "nova" instÃ¢ncia por chamada, clonando o estado base
        return FakeDB(users=list(base_db._users), pendings=list(base_db._pendings))

    app = FakeApplication()

    async def fake_cancel_order(api_key, api_secret, order_id, symbol):
        return {"success": True}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "SessionLocal", fake_SessionLocal)
    monkeypatch.setattr(tm, "cancel_order", fake_cancel_order)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)

    parsed_cancel = parse_signal(CANCEL_SIGNAL_XRP)
    assert parsed_cancel and parsed_cancel["type"] == SignalType.CANCELAR

    await tm.process_new_signal(parsed_cancel, app, source_name="TEST-CHANNEL")

    # Como usamos uma instÃ¢ncia nova de FakeDB dentro do process, nÃ£o temos referÃªncia direta
    # mas podemos validar pelo envio de mensagem de sucesso
    assert app.bot.sent and any("foi cancelada com sucesso" in (m.get("text","").lower()) for m in app.bot.sent)


@pytest.mark.asyncio
async def test_cancel_without_pending_sends_info_notification(monkeypatch):
    # DB sem pendentes
    base_db = FakeDB(users=[FakeUser(telegram_id=1)], pendings=[])
    def fake_SessionLocal():
        return FakeDB(users=list(base_db._users), pendings=list(base_db._pendings))

    app = FakeApplication()
    captured = {"msg": None}

    async def fake_send_notification(application, text):
        captured["msg"] = text

    monkeypatch.setattr(tm, "SessionLocal", fake_SessionLocal)
    monkeypatch.setattr(tm, "send_notification", fake_send_notification)

    parsed_cancel = parse_signal(CANCEL_SIGNAL_XRP)
    await tm.process_new_signal(parsed_cancel, app, source_name="TEST-CHANNEL")

    assert captured["msg"] is not None
    assert "nenhuma ordem pendente foi encontrada" in captured["msg"].lower()


@pytest.mark.asyncio
async def test_market_fails_on_balance_fetch(monkeypatch):
    parsed = parse_signal(MARKET_SIGNAL)
    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=321)])

    async def fake_get_account_info(api_key, api_secret):
        return {"success": False}  # falha

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    called = {"market": False}
    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "place_order", fake_place_order)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    assert not called["market"], "NÃ£o deve tentar abrir ordem sem saldo"
    assert app.bot.sent and any("falha ao buscar seu saldo bybit" in (m.get("text","").lower()) for m in app.bot.sent)


========================================
# Arquivo: utils/__init__.py
========================================



========================================
# Arquivo: utils/config.py
========================================

import os
from dotenv import load_dotenv

load_dotenv()

TELEGRAM_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
ENCRYPTION_KEY = os.getenv('ENCRYPTION_KEY')

API_ID = os.getenv('API_ID')
API_HASH = os.getenv('API_HASH')
ADMIN_ID = int(os.getenv('ADMIN_TELEGRAM_ID', 0)) # Converte para int

========================================
# Arquivo: utils/security.py
========================================

from cryptography.fernet import Fernet
from .config import ENCRYPTION_KEY

# Inicializa o 'cofre' com a sua chave
cipher_suite = Fernet(ENCRYPTION_KEY.encode())

def encrypt_data(data: str) -> str:
    """Criptografa um texto e retorna a versÃ£o em string."""
    if not data:
        return None
    encrypted_bytes = cipher_suite.encrypt(data.encode())
    return encrypted_bytes.decode()

def decrypt_data(encrypted_data: str) -> str:
    """Descriptografa um texto e retorna a versÃ£o original."""
    if not encrypted_data:
        return None
    decrypted_bytes = cipher_suite.decrypt(encrypted_data.encode())
    return decrypted_bytes.decode()

========================================
# Arquivo: scripts/cleanup_trades.py
========================================

import sys
import os
import argparse
from sqlalchemy.orm import Session
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# Adiciona o diretÃ³rio raiz ao path para permitir a importaÃ§Ã£o de mÃ³dulos do projeto
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from database.models import Base, Trade
from database.session import DATABASE_URL  # Importa a URL do banco de dados

def cleanup_trades(db: Session, status: str, user_id: int = None, dry_run: bool = True):
    """
    Busca e, opcionalmente, exclui trades com base em seu status e ID de usuÃ¡rio.
    """
    query = db.query(Trade).filter(Trade.status == status)
    
    if user_id:
        query = query.filter(Trade.user_telegram_id == user_id)
        
    trades_to_delete = query.all()
    count = len(trades_to_delete)
    
    user_filter_str = f" para o usuÃ¡rio com ID {user_id}" if user_id else ""
    
    if count == 0:
        print(f"Nenhum trade com o status '{status}' encontrado{user_filter_str}.")
        return

    print(f"Encontrados {count} trades com o status '{status}'{user_filter_str}.")

    if dry_run:
        print("\n--- MODO DE SIMULAÃ‡ÃƒO (DRY-RUN) ---")
        print("Os seguintes trades seriam excluÃ­dos:")
        for trade in trades_to_delete:
            print(f"  - ID: {trade.id}, SÃ­mbolo: {trade.symbol}, UsuÃ¡rio: {trade.user_telegram_id}, Data: {trade.closed_at}")
        print("\nNenhuma alteraÃ§Ã£o foi feita no banco de dados.")
    else:
        # ConfirmaÃ§Ã£o final antes de excluir
        confirm = input(f"\n!!! ATENÃ‡ÃƒO !!! VocÃª tem certeza que deseja excluir permanentemente estes {count} trades? (s/N): ")
        if confirm.lower() == 's':
            try:
                # Usa delete() em vez de um loop para mais performance
                query.delete(synchronize_session=False)
                db.commit()
                print(f"\nâœ… Sucesso! {count} trades foram excluÃ­dos permanentemente.")
            except Exception as e:
                db.rollback()
                print(f"\nâŒ Erro ao excluir trades: {e}")
        else:
            print("\nOperaÃ§Ã£o cancelada pelo usuÃ¡rio.")

def main():
    """
    FunÃ§Ã£o principal para executar o script via linha de comando.
    """
    parser = argparse.ArgumentParser(description="Script de limpeza para trades no banco de dados.")
    parser.add_argument("--status", type=str, required=True, help="O status dos trades a serem excluÃ­dos (ex: CLOSED_GHOST).")
    parser.add_argument("--user-id", type=int, help="(Opcional) ID de usuÃ¡rio do Telegram para filtrar a exclusÃ£o.")
    parser.add_argument("--dry-run", action="store_true", help="Apenas simula a exclusÃ£o, sem fazer alteraÃ§Ãµes no banco.")
    
    args = parser.parse_args()

    # ConfiguraÃ§Ã£o da sessÃ£o do banco de dados
    engine = create_engine(DATABASE_URL)
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    db = SessionLocal()
    
    try:
        cleanup_trades(db, status=args.status, user_id=args.user_id, dry_run=args.dry_run)
    finally:
        db.close()

if __name__ == "__main__":
    main()

========================================
# Arquivo: scripts/create_invite.py
========================================

import sys
from database.session import SessionLocal, init_db
from database.models import InviteCode

def create_invite_code(code: str):
    db = SessionLocal()
    try:
        existing_code = db.query(InviteCode).filter(InviteCode.code == code).first()
        if existing_code:
            print(f"CÃ³digo '{code}' jÃ¡ existe.")
            return

        new_code = InviteCode(code=code)
        db.add(new_code)
        db.commit()
        print(f"CÃ³digo de convite '{code}' criado com sucesso!")
    finally:
        db.close()

if __name__ == "__main__":
    init_db()
    # Agora ele lÃª o cÃ³digo a partir do seu comando no terminal
    if len(sys.argv) > 1:
        code_to_create = sys.argv[1]
        create_invite_code(code_to_create)
    else:
        print("Erro: Por favor, forneÃ§a um cÃ³digo para criar. Exemplo: python create_invite.py MEU-CODIGO-NOVO")

========================================
# Arquivo: bot/__init__.py
========================================



========================================
# Arquivo: bot/handlers.py
========================================

import logging
import asyncio
import pytz
from database.models import PendingSignal
from services.signal_parser import SignalType
from services.bybit_service import place_limit_order, get_account_info, cancel_order 
from datetime import datetime, time, timedelta 
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler
from telegram.error import BadRequest
from database.session import SessionLocal
from database.models import User, InviteCode, MonitoredTarget, Trade, SignalForApproval
from .keyboards import (
    main_menu_keyboard, confirm_remove_keyboard, admin_menu_keyboard, 
    dashboard_menu_keyboard, settings_menu_keyboard, view_targets_keyboard, 
    bot_config_keyboard, performance_menu_keyboard, confirm_manual_close_keyboard,
    signal_filters_keyboard, ma_timeframe_keyboard, risk_menu_keyboard,
    stopgain_menu_keyboard, circuit_menu_keyboard,
    )
from utils.security import encrypt_data, decrypt_data
from services.bybit_service import (
    get_open_positions, 
    get_account_info, 
    close_partial_position, 
    get_open_positions_with_pnl,
    get_market_price
)
from utils.config import ADMIN_ID
from database.crud import get_user_by_id
from core.trade_manager import _execute_trade, _execute_limit_order_for_user
from core.performance_service import generate_performance_report
from services.currency_service import get_usd_to_brl_rate
from sqlalchemy.sql import func
from core.whitelist_service import CATEGORIES

# Estados para as conversas
(WAITING_CODE, WAITING_API_KEY, WAITING_API_SECRET, CONFIRM_REMOVE_API) = range(4)
(ASKING_ENTRY_PERCENT, ASKING_MAX_LEVERAGE, ASKING_MIN_CONFIDENCE) = range(10, 13)
(ASKING_PROFIT_TARGET, ASKING_LOSS_LIMIT) = range(13, 15)
ASKING_STOP_GAIN_TRIGGER, ASKING_STOP_GAIN_LOCK = range(16, 18)
ASKING_CIRCUIT_THRESHOLD, ASKING_CIRCUIT_PAUSE = range(18, 20)
ASKING_COIN_WHITELIST = 15
(
    ASKING_MA_PERIOD, ASKING_MA_TIMEFRAME,
    ASKING_RSI_OVERSOLD, ASKING_RSI_OVERBOUGHT
) = range(20, 24)

logger = logging.getLogger(__name__)

# ---- helpers (resumos no topo dos submenus) ----
def _risk_summary(user) -> str:
    try:
        return (
            f"â€¢ Entrada: {float(getattr(user,'entry_size_percent',0) or 0):.1f}%  |  "
            f"Alav.: {int(getattr(user,'max_leverage',0) or 0)}x  |  "
            f"Conf.: {float(getattr(user,'min_confidence',0) or 0):.1f}%"
        )
    except Exception:
        return "â€¢ ParÃ¢metros indisponÃ­veis"

def _stopgain_summary(user) -> str:
    try:
        return (
            f"â€¢ Gatilho: {float(getattr(user,'stop_gain_trigger_pct',0) or 0):.2f}%  |  "
            f"Trava: {float(getattr(user,'stop_gain_lock_pct',0) or 0):.2f}%"
        )
    except Exception:
        return "â€¢ ParÃ¢metros indisponÃ­veis"

def _circuit_summary(user) -> str:
    try:
        return (
            f"â€¢ Limite: {int(getattr(user,'circuit_breaker_threshold',0) or 0)}  |  "
            f"Pausa: {int(getattr(user,'circuit_breaker_pause_minutes',0) or 0)} min"
        )
    except Exception:
        return "â€¢ ParÃ¢metros indisponÃ­veis"

# --- FLUXO DE USUÃRIO (START, CADASTRO, MENUS) ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    telegram_user = update.effective_user
    user_in_db = get_user_by_id(telegram_user.id)
    if user_in_db:
        await update.message.reply_text(
            "Menu Principal:",
            reply_markup=main_menu_keyboard(telegram_id=telegram_user.id)
        )
        return ConversationHandler.END
    else:
        await update.message.reply_text(
            f"OlÃ¡, {telegram_user.first_name}! Para usar o TradeFlow, insira seu cÃ³digo de convite."
        )
        return WAITING_CODE

async def receive_invite_code(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    code_text = update.message.text
    telegram_user = update.effective_user
    db = SessionLocal()
    try:
        invite_code = db.query(InviteCode).filter(InviteCode.code == code_text, InviteCode.is_used == False).first()
        if invite_code:
            new_user = User(telegram_id=telegram_user.id, first_name=telegram_user.first_name)
            db.add(new_user)
            invite_code.is_used = True
            db.commit()
            await update.message.reply_text(
                "âœ… Cadastro realizado com sucesso! O prÃ³ximo passo Ã© configurar sua API.",
                reply_markup=main_menu_keyboard(telegram_id=telegram_user.id)
            )
            return ConversationHandler.END
        else:
            await update.message.reply_text("âŒ CÃ³digo de convite invÃ¡lido ou jÃ¡ utilizado. Tente novamente.")
            return WAITING_CODE
    finally:
        db.close()

async def back_to_main_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        "Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=update.effective_user.id)
    )

# --- FLUXO DE CONFIGURAÃ‡ÃƒO DE API ---
async def config_api(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Inicia o fluxo de configuraÃ§Ã£o de API com um tutorial melhorado."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['entry_message_id'] = query.message.message_id
    
    tutorial_text = (
        "ğŸ”‘ <b>Como Criar suas Chaves de API na Bybit</b> ğŸ”‘\n\n"
        "Siga estes passos com atenÃ§Ã£o para conectar sua conta:\n\n"
        "1ï¸âƒ£  FaÃ§a login em <b>Bybit.com</b> e vÃ¡ para <i>Perfil > API</i>.\n\n"
        "2ï¸âƒ£  Clique em <b>'Criar Nova Chave'</b> e selecione <i>'Chaves Geradas pelo Sistema'</i>.\n\n"
        "3ï¸âƒ£  DÃª um nome para sua chave (ex: `TradeFlowBot`) e selecione as permissÃµes de <b>'Leitura e Escrita'</b>.\n\n"
        "4ï¸âƒ£  Nas permissÃµes, marque <b>APENAS</b> as seguintes caixas:\n"
        "   - <b>Contrato</b> (`Contract`): âœ… `Ordens` e âœ… `PosiÃ§Ãµes`\n"
        "   - <b>Trading Unificado</b> (`UTA`): âœ… `Trade`\n\n"
        "5ï¸âƒ£  ğŸ›¡ï¸ <b>MUITO IMPORTANTE:</b> Por seguranÃ§a, <b>NÃƒO</b> marque a permissÃ£o de <i>'Saque' (Withdraw)</i>.\n\n"
        "âš ï¸ <b>AtenÃ§Ã£o:</b> Este bot opera exclusivamente com pares de trade terminados em **USDT**.\n\n"
        "6ï¸âƒ£  Conclua a verificaÃ§Ã£o de seguranÃ§a e copie sua <b>API Key</b> e <b>API Secret</b>.\n\n"
        "-------------------------------------\n"
        "Pronto! Agora, por favor, envie sua <b>API Key</b>."
    )
    
    await query.edit_message_text(
        text=tutorial_text,
        parse_mode='HTML'
    )
    return WAITING_API_KEY

async def receive_api_key(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe a API Key, apaga a mensagem do usuÃ¡rio e pede a API Secret."""
    await context.bot.delete_message(
        chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    api_key = update.message.text
    context.user_data['api_key'] = api_key
    
    prompt_message = await update.message.reply_text(
        "Chave API recebida com seguranÃ§a. Agora, por favor, envie sua *API Secret*.",
        parse_mode='Markdown'
    )
    context.user_data['prompt_message_id'] = prompt_message.message_id
    
    return WAITING_API_SECRET

async def receive_api_secret(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe a API Secret, apaga as mensagens, criptografa e salva no banco."""
    await context.bot.delete_message(
        chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    prompt_message_id = context.user_data.get('prompt_message_id')
    if prompt_message_id:
        await context.bot.delete_message(
            chat_id=update.effective_chat.id,
            message_id=prompt_message_id
        )

    api_secret = update.message.text
    api_key = context.user_data.get('api_key')
    telegram_id = update.effective_user.id

    encrypted_key = encrypt_data(api_key)
    encrypted_secret = encrypt_data(api_secret)

    db = SessionLocal()
    try:
        user_to_update = db.query(User).filter(User.telegram_id == telegram_id).first()
        if user_to_update:
            user_to_update.api_key_encrypted = encrypted_key
            user_to_update.api_secret_encrypted = encrypted_secret
            db.commit()
            
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=context.user_data['entry_message_id'],
                text="âœ… Suas chaves de API foram salvas com sucesso!",
            )
            await context.bot.send_message(
                chat_id=telegram_id,
                text="Menu Principal:",
                reply_markup=main_menu_keyboard(telegram_id=telegram_id)
            )
        else:
            await update.message.reply_text("Ocorreu um erro. UsuÃ¡rio nÃ£o encontrado.")
    finally:
        db.close()
        context.user_data.clear()

    return ConversationHandler.END

# --- FLUXO DE REMOÃ‡ÃƒO DE API ---
async def remove_api_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        text="âš ï¸ VocÃª tem certeza que deseja remover suas chaves de API?",
        reply_markup=confirm_remove_keyboard()
    )
    return CONFIRM_REMOVE_API

async def remove_api_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id

    if query.data == 'remove_api_confirm':
        db = SessionLocal()
        try:
            user_to_update = db.query(User).filter(User.telegram_id == telegram_id).first()
            if user_to_update:
                user_to_update.api_key_encrypted = None
                user_to_update.api_secret_encrypted = None
                db.commit()
            await query.edit_message_text("âœ… Suas chaves de API foram removidas.")
        finally:
            db.close()
    else: # Cancelou
        await query.edit_message_text("OperaÃ§Ã£o cancelada.")

    await context.bot.send_message(
        chat_id=telegram_id,
        text="Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=telegram_id)
    )
    return ConversationHandler.END

async def my_positions_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    try:
        await query.answer()
    except BadRequest as e:
        logger.warning(f"NÃ£o foi possÃ­vel responder ao callback_query (pode ser antigo): {e}")
        return

    try:
        await query.edit_message_text("Buscando suas posiÃ§Ãµes gerenciadas...")
    except BadRequest as e:
        logger.warning(f"Falha ao editar mensagem para 'Buscando suas posiÃ§Ãµes...': {e}")
        return

    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if not user or not user.api_key_encrypted:
            await query.edit_message_text("VocÃª ainda nÃ£o configurou suas chaves de API.")
            return

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        active_trades = db.query(Trade).filter(
            Trade.user_telegram_id == user_id,
            ~Trade.status.like('%CLOSED%')
        ).order_by(Trade.created_at.desc()).all()

        if not active_trades:
            await query.edit_message_text(
                "<b>ğŸ“Š Suas PosiÃ§Ãµes Ativas</b>\n\nNenhuma posiÃ§Ã£o sendo gerenciada.",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup(
                    [[InlineKeyboardButton("â¬…ï¸ Voltar ao Menu", callback_data='back_to_main_menu')]]
                )
            )
            return

        live_pnl_data = {}
        live_positions_result = await get_open_positions_with_pnl(api_key, api_secret)
        if live_positions_result.get("success"):
            for pos in live_positions_result.get("data", []):
                live_pnl_data[pos["symbol"]] = pos

        lines = ["<b>ğŸ“Š Suas PosiÃ§Ãµes Ativas (Gerenciadas pelo Bot)</b>", ""]
        keyboard_rows = []
        
        if not active_trades:
             lines.append("Nenhuma posiÃ§Ã£o encontrada na Bybit.")
        else:
            # COMENTÃRIO: A lÃ³gica agora itera por trade individual, sem agregaÃ§Ã£o.
            for trade in active_trades:
                arrow = "â¬†ï¸" if trade.side == "LONG" else "â¬‡ï¸"
                entry = float(trade.entry_price or 0.0)
                qty = float(trade.remaining_qty if trade.remaining_qty is not None else trade.qty)
                
                pnl_info = "  P/L: <i>buscando...</i>\n"
                pos_data = live_pnl_data.get(trade.symbol)
                if pos_data:
                    pnl_val = float(pos_data.get("unrealized_pnl", 0.0))
                    pnl_frac = float(pos_data.get("unrealized_pnl_frac", 0.0)) * 100.0
                    pnl_info = f"  P/L: <b>{pnl_val:+.2f} USDT ({pnl_frac:+.2f}%)</b>\n"
                
                # COMENTÃRIO: Nova lÃ³gica para exibir o progresso dos TPs.
                total_tps = int(trade.total_initial_targets or 0)
                remaining_tps = len(trade.initial_targets or [])
                hit_tps = total_tps - remaining_tps
                
                targets_info = ""
                if total_tps > 0:
                    targets_info = f"  ğŸ¯ TPs: <b>{hit_tps}/{total_tps} atingidos</b>\n"

                lines.append(
                    f"- {arrow} <b>{trade.symbol}</b> ({trade.side})\n"
                    f"  Qtd: {qty:g} | Entrada: ${entry:,.4f}\n"
                    f"{pnl_info}{targets_info}"
                )
                
                # Adiciona um botÃ£o de fechar para cada trade individual
                keyboard_rows.append([
                    InlineKeyboardButton(
                        f"Fechar {trade.symbol} #{trade.id} âŒ",
                        callback_data=f"confirm_close_{trade.id}" # Aponta para o ID Ãºnico do trade
                    )
                ])

        lines.append("<i>P/L Ã© atualizado em tempo real pela corretora.</i>")
        keyboard_rows.append([InlineKeyboardButton("â¬…ï¸ Voltar ao Menu", callback_data='back_to_main_menu')])
        
        await query.edit_message_text(
            "\n".join(lines), 
            parse_mode='HTML', 
            reply_markup=InlineKeyboardMarkup(keyboard_rows)
        )

    finally:
        db.close()

async def user_dashboard_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o painel financeiro com um resumo visual e completo dos saldos da carteira."""
    query = update.callback_query
    try:
        await query.answer()
    except BadRequest as e:
        logger.warning(f"NÃ£o foi possÃ­vel responder ao callback_query (pode ser antigo): {e}")
        return

    await query.edit_message_text("Buscando informaÃ§Ãµes do painel...")
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = get_user_by_id(user_id)
        if not user or not user.api_key_encrypted:
            await query.edit_message_text("VocÃª precisa configurar sua API primeiro.", reply_markup=main_menu_keyboard(telegram_id=user_id))
            return

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # Busca o saldo e a cotaÃ§Ã£o em paralelo para mais eficiÃªncia
        account_info_task = get_account_info(api_key, api_secret)
        brl_rate_task = get_usd_to_brl_rate()
        account_info, brl_rate = await asyncio.gather(account_info_task, brl_rate_task)

        message = "<b>Meu Painel Financeiro</b> ğŸ“Š\n\n"
        
        if account_info.get("success"):
            balance_data = account_info.get("data", {})
            total_equity = balance_data.get("total_equity", 0.0)

            brl_text = ""
            if brl_rate:
                total_brl = total_equity * brl_rate
                brl_text = f" (aprox. R$ {total_brl:,.2f})"

            message += f"ğŸ’° <b>PatrimÃ´nio Total:</b> ${total_equity:,.2f} USDT{brl_text}\n"
            message += "<i>(Valor total da conta, incluindo P/L de posiÃ§Ãµes abertas e o valor de todas as moedas)</i>\n\n"
            message += "<b>Saldos em Carteira:</b>\n"

            coin_list = balance_data.get("coin_list", [])
            wallet_lines = []
            
            if coin_list:
                for c in coin_list:
                    coin = (c.get("coin") or "").upper()
                    wallet_balance_str = c.get("walletBalance")
                    wallet_balance = float(wallet_balance_str) if wallet_balance_str else 0.0

                    if wallet_balance > 0.00001:
                        if coin == "USDT":
                            wallet_lines.insert(0, f"  - <b>{coin}: {wallet_balance:,.2f}</b>") # Garante que USDT apareÃ§a primeiro
                        else:
                            wallet_lines.append(f"  - {coin}: {wallet_balance:g}")
            
            if wallet_lines:
                message += "\n".join(wallet_lines)
            else:
                message += "Nenhum saldo encontrado.\n"
        else:
            message += f"âŒ Erro ao buscar saldo: {account_info.get('error')}\n"

        message += "\n\nâš ï¸ <i>Este bot opera exclusivamente com pares USDT.</i>"

        await query.edit_message_text(message, parse_mode="HTML", reply_markup=dashboard_menu_keyboard(user))

    except Exception as e:
        logger.error(f"Erro ao montar o painel do usuÃ¡rio: {e}", exc_info=True)
        await query.edit_message_text("Ocorreu um erro ao buscar os dados do seu painel.")
    finally:
        db.close()

# --- CANCELAMENTO ---
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancela a operaÃ§Ã£o atual."""
    await update.message.reply_text("OperaÃ§Ã£o cancelada.")
    return ConversationHandler.END

# --- FLUXO DE ADMINISTRAÃ‡ÃƒO ---
async def admin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra o menu de administrador, se o usuÃ¡rio for o admin."""
    user_id = update.effective_user.id
    if user_id != ADMIN_ID:
        await update.message.reply_text("VocÃª nÃ£o tem permissÃ£o para usar este comando.")
        return

    await update.message.reply_text(
        "Bem-vindo ao painel de administraÃ§Ã£o.",
        reply_markup=admin_menu_keyboard()
    )


async def admin_view_targets_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Busca e exibe a lista de todos os canais e tÃ³picos sendo monitorados."""
    query = update.callback_query
    await query.answer()
    
    db = SessionLocal()
    try:
        targets = db.query(MonitoredTarget).all()
        
        message = "<b>ğŸ‘ï¸ Alvos Atualmente Monitorados</b>\n\n"
        
        if targets:
            for target in targets:
                if target.topic_name:
                    message += f"- <b>Grupo:</b> {target.channel_name}\n  - <b>TÃ³pico:</b> {target.topic_name}\n"
                else:
                    message += f"- <b>Canal:</b> {target.channel_name}\n"
        else:
            message += "Nenhum alvo sendo monitorado no momento."
            
        await query.edit_message_text(
            text=message,
            parse_mode='HTML',
            reply_markup=view_targets_keyboard()
        )
    finally:
        db.close()

async def back_to_admin_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usuÃ¡rio para o menu de administraÃ§Ã£o principal."""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        "Bem-vindo ao painel de administraÃ§Ã£o.",
        reply_markup=admin_menu_keyboard()
    )

async def list_channels_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Coloca um pedido na fila para listar os grupos e canais do usuÃ¡rio."""
    query = update.callback_query
    await query.answer()
    
    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue:
        await query.edit_message_text("Erro: Fila de comunicaÃ§Ã£o nÃ£o encontrada.")
        return
    
    request_data = {
        "action": "list_channels",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
    }
    
    await comm_queue.put(request_data)
    
    await query.edit_message_text("Buscando sua lista de canais... Se vocÃª tiver muitos grupos, isso pode levar atÃ© um minuto. Por favor, aguarde.")
    
async def select_channel_to_monitor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Coloca um pedido na fila para listar tÃ³picos (ou gerenciar um canal plano)."""
    query = update.callback_query
    await query.answer()
    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue: return

    user_id = update.effective_user.id
    if user_id != ADMIN_ID: return

    channel_id = int(query.data.split('_')[-1])
    
    channel_name = ""
    for row in query.message.reply_markup.inline_keyboard:
        for button in row:
            if button.callback_data == query.data:
                channel_name = button.text.replace(" âœ…", "")
                break

    request_data = {
        "action": "list_topics",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
        "channel_id": channel_id,
        "channel_name": channel_name
    }
    
    await comm_queue.put(request_data)
    await query.edit_message_text("Processando...")

async def select_topic_to_monitor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Salva/remove o tÃ³pico e pede para a fila recarregar o menu de tÃ³picos."""
    query = update.callback_query
    await query.answer() 

    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue:
        logger.error("Fila de comunicaÃ§Ã£o nÃ£o encontrada no contexto do bot.")
        return

    user_id = update.effective_user.id
    if user_id != ADMIN_ID: return

    _, _, channel_id_str, topic_id_str = query.data.split('_')
    channel_id = int(channel_id_str)
    topic_id = int(topic_id_str)
    
    db = SessionLocal()
    try:
        existing_target = db.query(MonitoredTarget).filter_by(channel_id=channel_id, topic_id=topic_id).first()
        
        if existing_target:
            db.delete(existing_target)
        else:
            topic_name = ""
            for row in query.message.reply_markup.inline_keyboard:
                for button in row:
                    if button.callback_data == query.data:
                        topic_name = button.text.replace(" âœ…", "")
                        break
            new_target = MonitoredTarget(channel_id=channel_id, topic_id=topic_id, topic_name=topic_name)
            db.add(new_target)
        
        db.commit()
    finally:
        db.close()

    request_data = {
        "action": "list_topics",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
        "channel_id": channel_id,
        "channel_name": ""
    }
    await comm_queue.put(request_data)

async def back_to_channels_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usuÃ¡rio para a lista de canais/grupos."""
    await list_channels_handler(update, context)

# --- FUNÃ‡Ã•ES DUPLICADAS REMOVIDAS PARA LIMPEZA ---
# my_dashboard_handler, my_positions_handler, back_to_main_menu_handler
# jÃ¡ estavam definidas acima.

async def user_settings_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Abre o menu raiz de ConfiguraÃ§Ãµes (texto padronizado + teclado novo)."""
    query = update.callback_query
    await query.answer()
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("NÃ£o encontrei seu usuÃ¡rio. Use /start para registrar.")
            return

        header = (
            "âš™ï¸ <b>ConfiguraÃ§Ãµes de Trade</b>\n"
            "<i>Escolha uma categoria para ajustar seus parÃ¢metros.</i>"
        )
        await query.edit_message_text(
            text=header,
            reply_markup=settings_menu_keyboard(user),
            parse_mode="HTML",
        )
    except Exception as e:
        logger.error(f"[settings] Erro ao abrir menu raiz de ConfiguraÃ§Ãµes: {e}", exc_info=True)
        await query.edit_message_text("NÃ£o foi possÃ­vel abrir as ConfiguraÃ§Ãµes agora.")
    finally:
        db.close()

# ---- RISCO & TAMANHO ----
async def receive_entry_percent(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip().replace("%", "").replace(",", ".")
    db = SessionLocal()
    try:
        value = float(text)
        if value <= 0 or value > 100:
            await update.message.reply_text("Valor invÃ¡lido. Envie um nÃºmero entre 0 e 100 (ex.: 3.5).")
            return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("UsuÃ¡rio nÃ£o encontrado. Use /start para registrar."); return ConversationHandler.END
        user.entry_size_percent = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"ğŸ§® <b>Risco & Tamanho</b>\nâœ… Tamanho de entrada salvo: <b>{value:.1f}%</b>",
            reply_markup=risk_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("NÃ£o entendi. Envie um nÃºmero (ex.: 3.5).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] entry_size_percent: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END


async def receive_max_leverage(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip().lower().replace("x", "")
    db = SessionLocal()
    try:
        value = int(float(text))
        if value < 1 or value > 125:
            await update.message.reply_text("Valor invÃ¡lido. Envie um inteiro entre 1 e 125 (ex.: 10).")
            return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("UsuÃ¡rio nÃ£o encontrado. Use /start para registrar."); return ConversationHandler.END
        user.max_leverage = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"ğŸ§® <b>Risco & Tamanho</b>\nâœ… Alavancagem mÃ¡xima salva: <b>{value}x</b>",
            reply_markup=risk_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("NÃ£o entendi. Envie um nÃºmero inteiro (ex.: 10).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] max_leverage: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END


async def receive_min_confidence(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip().replace("%", "").replace(",", ".")
    db = SessionLocal()
    try:
        value = float(text)
        if value < 0 or value > 100:
            await update.message.reply_text("Valor invÃ¡lido. Envie um nÃºmero entre 0 e 100 (ex.: 70).")
            return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("UsuÃ¡rio nÃ£o encontrado. Use /start para registrar."); return ConversationHandler.END
        user.min_confidence = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"ğŸ§® <b>Risco & Tamanho</b>\nâœ… ConfianÃ§a mÃ­nima salva: <b>{value:.1f}%</b>",
            reply_markup=risk_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("NÃ£o entendi. Envie um nÃºmero (ex.: 70).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] min_confidence: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END

    
def _current_strategy_value(user) -> str:
    return (str(getattr(user, "stop_strategy", None) or
                getattr(user, "stop_strategy_mode", None) or
                getattr(user, "stop_strategy_type", None) or "breakeven")).lower()

def _next_strategy_value(value: str) -> str:
    return "trailing" if value.startswith("b") else "breakeven"

def _stopgain_summary(user) -> str:
    trigger = float(getattr(user, 'stop_gain_trigger_pct', 0) or 0)
    lock    = float(getattr(user, 'stop_gain_lock_pct', 0) or 0)
    cur     = _current_strategy_value(user)
    label   = "Breakeven" if cur.startswith("b") else "Trailing"
    return f"â€¢ EstratÃ©gia: {label}  |  Gatilho: {trigger:.2f}%  |  Trava: {lock:.2f}%"

async def toggle_stop_strategy_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("NÃ£o encontrei seu usuÃ¡rio. Use /start para registrar.")
            return
        cur = _current_strategy_value(user)
        nxt = _next_strategy_value(cur)

        if hasattr(user, "stop_strategy"):
            user.stop_strategy = nxt
        elif hasattr(user, "stop_strategy_mode"):
            user.stop_strategy_mode = nxt
        elif hasattr(user, "stop_strategy_type"):
            user.stop_strategy_type = nxt
        else:
            setattr(user, "stop_strategy", nxt)

        db.commit()
        header = ("ğŸ›¡ï¸ <b>Stop-Gain</b>\n<i>Configure estratÃ©gia, gatilho e trava.</i>\n\n"
                  f"{_stopgain_summary(user)}")
        await query.edit_message_text(text=header,
                                      reply_markup=stopgain_menu_keyboard(user),
                                      parse_mode="HTML")
    except Exception as e:
        db.rollback()
        logger.error(f"[settings] toggle_stop_strategy_handler erro: {e}", exc_info=True)
        await query.edit_message_text("Erro ao alternar estratÃ©gia.")
    finally:
        db.close()
    
async def execute_manual_close_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Lida com a EXECUÃ‡ÃƒO do fechamento manual, editando a mensagem original."""
    query = update.callback_query
    await query.answer("Processando fechamento...")

    trade_id = int(query.data.split('_')[-1])
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        trade_to_close = db.query(Trade).filter_by(id=trade_id, user_telegram_id=user_id).first()

        if not trade_to_close:
            await query.edit_message_text("Erro: Trade nÃ£o encontrado ou jÃ¡ fechado.")
            return

        user = db.query(User).filter_by(telegram_id=user_id).first()
        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        price_result = await get_market_price(trade_to_close.symbol)
        current_price = price_result["price"] if price_result.get("success") else trade_to_close.entry_price

        close_result = await close_partial_position(
            api_key, api_secret, 
            trade_to_close.symbol, 
            trade_to_close.remaining_qty, 
            trade_to_close.side
        )

        if close_result.get("success"):
            pnl = (current_price - trade_to_close.entry_price) * trade_to_close.remaining_qty if trade_to_close.side == 'LONG' else (trade_to_close.entry_price - current_price) * trade_to_close.remaining_qty

            trade_to_close.status = 'CLOSED_MANUAL'
            trade_to_close.closed_at = func.now()
            trade_to_close.closed_pnl = pnl
            db.commit()

            resultado_str = "LUCRO" if pnl >= 0 else "PREJUÃZO"
            emoji = "âœ…" if pnl >= 0 else "ğŸ”»"
            message_text = (
                f"{emoji} <b>PosiÃ§Ã£o Fechada Manualmente ({resultado_str})</b>\n"
                f"<b>Moeda:</b> {trade_to_close.symbol}\n"
                f"<b>Resultado:</b> ${pnl:,.2f}"
            )

            # --- LÃ“GICA DE EDIÃ‡ÃƒO APLICADA AQUI ---
            if trade_to_close.notification_message_id:
                try:
                    await context.bot.edit_message_text(
                        chat_id=user_id,
                        message_id=trade_to_close.notification_message_id,
                        text=message_text,
                        parse_mode='HTML'
                    )
                except BadRequest as e:
                    logger.warning(f"NÃ£o foi possÃ­vel editar msg de fechamento manual para trade {trade_to_close.id}: {e}")
                    # Fallback: se nÃ£o conseguir editar, envia uma nova mensagem.
                    await context.bot.send_message(chat_id=user_id, text=message_text, parse_mode='HTML')
            else:
                # Fallback para trades antigos sem ID de mensagem.
                await query.edit_message_text(message_text, parse_mode='HTML')

            await asyncio.sleep(2)
            await my_positions_handler(update, context) # Recarrega a lista de posiÃ§Ãµes
        else:
            error_msg = close_result.get('error')
            await context.bot.send_message(
                chat_id=user_id,
                text=f"âŒ Erro ao fechar a posiÃ§Ã£o para {trade_to_close.symbol}: {error_msg}"
            )
            await my_positions_handler(update, context) # Recarrega a lista mesmo em caso de erro
    finally:
        db.close()


async def bot_config_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de configuraÃ§Ã£o do bot com o modo de aprovaÃ§Ã£o atual."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    db = SessionLocal()
    try:
        user = get_user_by_id(user_id)
        if user:
            await query.edit_message_text(
                "<b>ğŸ¤– ConfiguraÃ§Ã£o do Bot</b>\n\n"
                "Ajuste o comportamento geral do bot.",
                parse_mode='HTML',
                reply_markup=bot_config_keyboard(user)
            )
    finally:
        db.close()

async def toggle_approval_mode_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Alterna o modo de aprovaÃ§Ã£o de ordens entre Manual e AutomÃ¡tico."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == user_id).first()
        
        if user:
            if user.approval_mode == 'AUTOMATIC':
                user.approval_mode = 'MANUAL'
            else:
                user.approval_mode = 'AUTOMATIC'
            
            db.commit() 
            
            try:
                await query.edit_message_text(
                    "<b>ğŸ¤– ConfiguraÃ§Ã£o do Bot</b>\n\n"
                    "Ajuste o comportamento geral do bot.",
                    parse_mode='HTML',
                    reply_markup=bot_config_keyboard(user)
                )
            except BadRequest as e:
                if "Message is not modified" in str(e):
                    pass
                else:
                    logger.error(f"Erro ao editar mensagem em toggle_approval_mode: {e}")
    finally:
        db.close()

async def handle_signal_approval(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Lida com a aprovaÃ§Ã£o ou rejeiÃ§Ã£o de um sinal por um usuÃ¡rio especÃ­fico."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id

    action, _, signal_id_str = query.data.partition('_signal_')
    signal_id = int(signal_id_str)
    
    db = SessionLocal()
    try:
        # Busca o sinal pendente para ESTE usuÃ¡rio especÃ­fico
        signal_to_process = db.query(SignalForApproval).filter_by(id=signal_id, user_telegram_id=user_id).first()
        if not signal_to_process:
            await query.edit_message_text("Este sinal jÃ¡ foi processado ou expirou.")
            return

        user = db.query(User).filter_by(telegram_id=user_id).first()
        signal_data = signal_to_process.signal_data
        
        if action == 'approve':
            await query.edit_message_text("âœ… **Entrada Aprovada!** Posicionando sua ordem...")
            
            # Executa o trade apenas para este usuÃ¡rio
            if signal_data.get("type") == SignalType.MARKET:
                await _execute_trade(signal_data, user, context.application, db, signal_to_process.source_name)
            elif signal_data.get("type") == SignalType.LIMIT:
                await _execute_limit_order_for_user(signal_data, user, context.application, db)
            
        elif action == 'reject':
            await query.edit_message_text("âŒ **Entrada Rejeitada.** O sinal foi descartado.")
        
        db.delete(signal_to_process)
        db.commit()
    finally:
        db.close()

# --- FLUXO DE CONFIGURAÃ‡ÃƒO DE METAS DIÃRIAS ---

async def ask_profit_target(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuÃ¡rio a nova meta de lucro diÃ¡rio."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie a sua meta de **lucro diÃ¡rio** em USDT.\n"
        "O bot irÃ¡ parar de abrir novas ordens quando o lucro do dia atingir este valor.\n\n"
        "Envie apenas o nÃºmero (ex: `100` para $100) ou `0` para desativar.",
        parse_mode='Markdown'
    )
    return ASKING_PROFIT_TARGET

async def receive_profit_target(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova meta de lucro."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        target_value = float(update.message.text.replace(',', '.'))
        if target_value < 0:
            raise ValueError("Valor nÃ£o pode ser negativo")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.daily_profit_target = target_value
            db.commit()
            
            feedback_text = f"âœ… Meta de lucro diÃ¡rio atualizada para ${target_value:.2f}."
            if target_value == 0:
                feedback_text = "âœ… Meta de lucro diÃ¡rio foi desativada."

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"{feedback_text}\n\nAjuste outra configuraÃ§Ã£o ou volte.",
                reply_markup=bot_config_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="âŒ Valor invÃ¡lido. Por favor, tente novamente com um nÃºmero (ex: 100)."
        )
        return ASKING_PROFIT_TARGET

    return ConversationHandler.END

async def ask_loss_limit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuÃ¡rio o novo limite de perda diÃ¡rio."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie o seu limite de **perda diÃ¡ria** em USDT.\n"
        "O bot irÃ¡ parar de abrir novas ordens se a perda do dia atingir este valor.\n\n"
        "Envie um nÃºmero positivo (ex: `50` para um limite de $50) ou `0` para desativar.",
        parse_mode='Markdown'
    )
    return ASKING_LOSS_LIMIT

async def receive_loss_limit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva o novo limite de perda."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        limit_value = float(update.message.text.replace(',', '.'))
        if limit_value < 0:
            raise ValueError("Valor nÃ£o pode ser negativo")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.daily_loss_limit = limit_value
            db.commit()

            feedback_text = f"âœ… Limite de perda diÃ¡rio atualizado para ${limit_value:.2f}."
            if limit_value == 0:
                feedback_text = "âœ… Limite de perda diÃ¡rio foi desativado."

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"{feedback_text}\n\nAjuste outra configuraÃ§Ã£o ou volte.",
                reply_markup=bot_config_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="âŒ Valor invÃ¡lido. Por favor, tente novamente com um nÃºmero positivo (ex: 50)."
        )
        return ASKING_LOSS_LIMIT

    return ConversationHandler.END

# --- MENU DE DESEMPENHO ---

async def performance_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o painel de desempenho e lida com a seleÃ§Ã£o de perÃ­odo, usando o fuso horÃ¡rio de SP."""
    query = update.callback_query
    try:
        await query.answer()
    except BadRequest as e:
        # callback antigo/expirado: nÃ£o faz nada e evita stacktrace
        logger.warning(f"[perf] callback expirado/antigo: {e}")
        return

    user_id = query.from_user.id
    
    # --- LÃ“GICA DE FUSO HORÃRIO CORRIGIDA ---
    br_timezone = pytz.timezone("America/Sao_Paulo")
    now_br = datetime.now(br_timezone)
    
    callback_data = query.data
    start_dt, end_dt = None, None

    if callback_data == 'perf_today':
        start_dt = now_br.replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt = now_br
    elif callback_data == 'perf_yesterday':
        yesterday = now_br.date() - timedelta(days=1)
        start_dt = br_timezone.localize(datetime.combine(yesterday, time.min))
        end_dt = br_timezone.localize(datetime.combine(yesterday, time.max))
    elif callback_data == 'perf_7_days':
        start_dt = (now_br - timedelta(days=6)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt = now_br
    elif callback_data == 'perf_30_days':
        start_dt = (now_br - timedelta(days=29)).replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt = now_br

    if start_dt and end_dt:
        await query.edit_message_text(
            text="â³ Calculando desempenho para o perÃ­odo selecionado...",
            reply_markup=performance_menu_keyboard()
        )
        
        report_text = await generate_performance_report(user_id, start_dt, end_dt)
        
        await query.edit_message_text(
            text=report_text,
            parse_mode='HTML',
            reply_markup=performance_menu_keyboard()
        )

# --- FLUXO DE CONFIGURAÃ‡ÃƒO DE WHITELIST ---

async def ask_coin_whitelist(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Prompt para editar Whitelist com instruÃ§Ãµes, categorias e o valor atual."""
    from telegram import InlineKeyboardButton, InlineKeyboardMarkup
    query = update.callback_query
    await query.answer()

    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("NÃ£o encontrei seu usuÃ¡rio. Use /start para registrar.")
            return ASKING_COIN_WHITELIST # Permanece no estado, mas informa o erro
            
        # COMENTÃRIO: LÃ³gica adicionada para buscar a configuraÃ§Ã£o atual do usuÃ¡rio.
        current_whitelist = getattr(user, 'coin_whitelist', 'todas') or 'todas'

        text = (
            f"âœ… <b>Whitelist de Moedas</b>\n\n"
            f"âš™ï¸ <b>Sua ConfiguraÃ§Ã£o Atual:</b>\n<code>{current_whitelist}</code>\n\n"
            "VocÃª pode definir exatamente <i>quais moedas</i> o bot poderÃ¡ operar.\n\n"
            "ğŸ§© <b>Como usar</b>\n"
            "â€¢ Digite tickers separados por vÃ­rgula (ex.: <code>BTCUSDT,ETHUSDT,SOLUSDT</code>)\n"
            "â€¢ Pode misturar <b>tickers</b> com <b>categorias</b>\n"
            "â€¢ Use <code>todas</code> para liberar todos os pares\n\n"
            "ğŸ“¦ <b>Categorias disponÃ­veis</b>\n"
            "â€¢ <b>bluechips</b> â†’ BTC, ETH, BNB\n"
            "â€¢ <b>altcoins</b> â†’ SOL, XRP, ADA, AVAX, DOT, MATIC, LINK...\n"
            "â€¢ <b>defi</b> â†’ UNI, AAVE, MKR, SNX, COMP, CRV...\n"
            "â€¢ <b>infra</b> â†’ LINK, GRT, FIL\n"
            "â€¢ <b>memecoins</b> â†’ DOGE, SHIB, PEPE, WIF, FLOKI, BONK\n\n"
            "â„¹ï¸ Exemplos vÃ¡lidos:\n"
            "â€¢ <code>bluechips</code>\n"
            "â€¢ <code>memecoins,altcoins</code>\n"
            "â€¢ <code>BTCUSDT,ETHUSDT,defi</code>\n\n"
            "â¬…ï¸ Clique em <b>Voltar</b> para cancelar sem alteraÃ§Ãµes."
        )

        markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("â¬…ï¸ Voltar", callback_data="back_to_settings_menu")]
        ])

        await query.edit_message_text(text, parse_mode="HTML", reply_markup=markup)
    finally:
        db.close()
        
    return ASKING_COIN_WHITELIST

async def receive_coin_whitelist(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Salva whitelist enviada pelo usuÃ¡rio e retorna ao menu de ConfiguraÃ§Ãµes.
    Aceita tickers (ex.: BTCUSDT) e keywords de categorias (ex.: bluechips, defi, memecoins, infra, altcoins).
    """
    text = (update.message.text or "").strip()
    db = SessionLocal()
    try:
        if not text:
            await update.message.reply_text("Envie ao menos 1 ticker ou categoria. Ex.: BTCUSDT,ETHUSDT ou bluechips")
            return ConversationHandler.END

        # NormalizaÃ§Ã£o bÃ¡sica
        raw_items = [i.strip().upper() for i in text.split(",") if i.strip()]
        unique_items = []
        seen = set()
        for i in raw_items:
            if i not in seen:
                unique_items.append(i)
                seen.add(i)

        # Dica: nÃ£o expandimos categorias na string salva; mantemos como o usuÃ¡rio enviou.
        # A checagem em tempo de execuÃ§Ã£o usa core.whitelist_service.is_coin_in_whitelist(...)
        normalized = ",".join(unique_items)

        user = db.query(User).filter(User.telegram_id == update.effective_user.id).first()
        if not user:
            await update.message.reply_text("UsuÃ¡rio nÃ£o encontrado. Use /start para registrar.")
            return ConversationHandler.END

        # Se seu modelo for user.coin_whitelist_str ou similar, ajuste o campo aqui:
        if hasattr(user, "coin_whitelist"):
            user.coin_whitelist = normalized
        elif hasattr(user, "coin_whitelist_str"):
            user.coin_whitelist_str = normalized
        else:
            # cria atributo em runtime para evitar quebra; ideal Ã© usar o nome real do seu modelo
            setattr(user, "coin_whitelist", normalized)

        db.commit()

        # Apaga a mensagem do usuÃ¡rio para manter a timeline limpa (se possÃ­vel)
        try:
            await update.message.delete()
        except Exception:
            pass

        # Mensagem de confirmaÃ§Ã£o + retorno ao menu raiz de ConfiguraÃ§Ãµes
        header = (
            "âš™ï¸ <b>ConfiguraÃ§Ãµes de Trade</b>\n"
            "<i>Whitelist atualizada com sucesso.</i>\n\n"
            f"ğŸ“¦ <b>Lista salva</b>: <code>{normalized}</code>"
        )
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=header,
            reply_markup=settings_menu_keyboard(user),
            parse_mode="HTML",
        )
    except Exception as e:
        db.rollback()
        logger.error(f"[settings] receive_coin_whitelist erro: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar a whitelist. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END

async def list_closed_trades_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Busca no DB e lista os Ãºltimos trades fechados do usuÃ¡rio."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    await query.edit_message_text("Buscando seu histÃ³rico de trades...")

    db = SessionLocal()
    try:
        # Busca os Ãºltimos 15 trades fechados, ordenados do mais recente para o mais antigo
        closed_trades = db.query(Trade).filter(
            Trade.user_telegram_id == user_id,
            Trade.status.like('%CLOSED%')
        ).order_by(Trade.closed_at.desc()).limit(15).all()

        message = "<b>ğŸ“œ Seus Ãšltimos Trades Fechados</b>\n\n"

        if not closed_trades:
            message += "Nenhum trade fechado encontrado no seu histÃ³rico."
        else:
            for trade in closed_trades:
                # Define o emoji e o texto do resultado com base no status e no P/L
                pnl = trade.closed_pnl if trade.closed_pnl is not None else 0.0
                resultado_str = f"<b>Resultado: ${pnl:,.2f}</b>"
                
                emoji = "â”"
                if trade.status == 'CLOSED_PROFIT':
                    emoji = "ğŸ†"
                elif trade.status == 'CLOSED_LOSS':
                    emoji = "ğŸ›‘"
                elif trade.status == 'CLOSED_MANUAL':
                    emoji = "âœ…" if pnl >= 0 else "ğŸ”»"
                elif trade.status == 'CLOSED_GHOST':
                    emoji = "â„¹ï¸"
                    resultado_str = "<i>Fechado externamente</i>"

                # Formata a data de fechamento
                data_fechamento = trade.closed_at.strftime('%d/%m %H:%M') if trade.closed_at else 'N/A'

                message += (
                    f"{emoji} <b>{trade.symbol}</b> ({trade.side})\n"
                    f"  - Fechado em: {data_fechamento}\n"
                    f"  - {resultado_str}\n\n"
                )
        
        # Cria um teclado com o botÃ£o para voltar ao menu de desempenho
        keyboard = [[InlineKeyboardButton("â¬…ï¸ Voltar ao Desempenho", callback_data='perf_today')]]
        
        await query.edit_message_text(
            text=message,
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    finally:
        db.close()

async def prompt_manual_close_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe a tela de confirmaÃ§Ã£o para o fechamento manual de uma posiÃ§Ã£o."""
    query = update.callback_query
    await query.answer()
    
    # COMENTÃRIO: O callback agora Ã© `confirm_close_<trade_id>`
    trade_id_str = query.data.split('_')[-1]
    if not trade_id_str.isdigit():
        # Lida com o formato antigo `confirm_close_group|SYMBOL|SIDE` como fallback
        await query.edit_message_text("Este botÃ£o Ã© de uma versÃ£o antiga. Por favor, volte e abra o menu de posiÃ§Ãµes novamente.")
        return

    trade_id = int(trade_id_str)
    
    db = SessionLocal()
    try:
        trade = db.query(Trade).filter_by(id=trade_id).first()
        if not trade:
            await query.edit_message_text("Erro: Trade nÃ£o encontrado ou jÃ¡ fechado.")
            return

        message = (
            f"âš ï¸ <b>Confirmar Fechamento</b> âš ï¸\n\n"
            f"VocÃª tem certeza que deseja fechar manualmente sua posiÃ§Ã£o em <b>{trade.symbol}</b> (ID: {trade.id})?\n\n"
            f"Esta aÃ§Ã£o Ã© irreversÃ­vel."
        )
        await query.edit_message_text(
            text=message,
            parse_mode='HTML',
            reply_markup=confirm_manual_close_keyboard(trade_id)
        )
    finally:
        db.close()

async def toggle_bot_status_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Liga/Desliga o bot ou ativa o modo dormir, em um ciclo de 3 estados."""
    query = update.callback_query
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == user_id).first()
        if not user:
            await query.answer("UsuÃ¡rio nÃ£o encontrado.", show_alert=True)
            return

        # LÃ³gica do ciclo de 3 estados
        alert_message = ""
        if not user.is_active:
            # ESTADO ATUAL: Pausado -> PRÃ“XIMO: Ativo 24h
            user.is_active = True
            user.is_sleep_mode_enabled = False
            alert_message = "Bot ATIVADO."
            
        elif user.is_active and not user.is_sleep_mode_enabled:
            # ESTADO ATUAL: Ativo 24h -> PRÃ“XIMO: Ativo com Modo Dormir
            user.is_sleep_mode_enabled = True
            alert_message = "Modo Dormir ATIVADO. O bot pausarÃ¡ entre 00:00 e 07:00."

        else: # user.is_active and user.is_sleep_mode_enabled
            # ESTADO ATUAL: Ativo com Modo Dormir -> PRÃ“XIMO: Pausado
            user.is_active = False
            user.is_sleep_mode_enabled = False # Reseta o modo dormir ao pausar
            alert_message = "Bot PAUSADO."

            # MantÃ©m a lÃ³gica de cancelar ordens pendentes ao pausar
            api_key = decrypt_data(user.api_key_encrypted)
            api_secret = decrypt_data(user.api_secret_encrypted)
            pendentes = db.query(PendingSignal).filter_by(user_telegram_id=user_id).all()
            canceladas = 0
            for p in pendentes:
                try:
                    resp = await cancel_order(api_key, api_secret, p.order_id, p.symbol)
                    if not resp.get("success"):
                        logger.warning(f"[PAUSE] Falha ao cancelar ordem {p.order_id} ({p.symbol}): {resp.get('error')}")
                    db.delete(p)
                    canceladas += 1
                except Exception as e:
                    logger.error(f"[PAUSE] ExceÃ§Ã£o ao cancelar {p.order_id} ({p.symbol}): {e}", exc_info=True)
            
            if canceladas > 0:
                alert_message += f" {canceladas} ordem(ns) pendente(s) foi(ram) cancelada(s)."
        
        db.commit()
        await query.answer(alert_message, show_alert=True)

        # Atualiza o teclado do painel para refletir o novo estado
        await query.edit_message_reply_markup(reply_markup=dashboard_menu_keyboard(user))

    finally:
        db.close()

async def ask_entry_percent(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("ğŸ“¥ Envie o <b>tamanho de entrada</b> em % (ex.: 3.5)", parse_mode="HTML")
    return ASKING_ENTRY_PERCENT

async def ask_max_leverage(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("âš™ï¸ Envie a <b>alavancagem mÃ¡xima</b> (ex.: 5, 10, 20)", parse_mode="HTML")
    return ASKING_MAX_LEVERAGE

async def ask_min_confidence(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("ğŸ¯ Envie a <b>confianÃ§a mÃ­nima</b> em % (ex.: 70)", parse_mode="HTML")
    return ASKING_MIN_CONFIDENCE

async def ask_stop_gain_trigger(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("ğŸš€ Envie o <b>gatilho</b> do Stop-Gain em % (ex.: 3)", parse_mode="HTML")
    return ASKING_STOP_GAIN_TRIGGER

async def ask_stop_gain_lock(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("ğŸ”’ Envie a <b>trava</b> do Stop-Gain em % (ex.: 1)", parse_mode="HTML")
    return ASKING_STOP_GAIN_LOCK

async def ask_circuit_threshold(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("âš¡ Envie o <b>limite</b> do disjuntor (inteiro, ex.: 3)", parse_mode="HTML")
    return ASKING_CIRCUIT_THRESHOLD

async def ask_circuit_pause(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("â¸ï¸ Envie a <b>pausa</b> apÃ³s disparo (minutos, ex.: 120)", parse_mode="HTML")
    return ASKING_CIRCUIT_PAUSE

# ---- STOP-GAIN ----
async def receive_stop_gain_trigger(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip().replace("%", "").replace(",", ".")
    db = SessionLocal()
    try:
        value = float(text)
        if value < 0 or value > 100:
            await update.message.reply_text("Valor invÃ¡lido. Envie entre 0 e 100 (ex.: 3)."); return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("UsuÃ¡rio nÃ£o encontrado. Use /start para registrar."); return ConversationHandler.END
        user.stop_gain_trigger_pct = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"ğŸ›¡ï¸ <b>Stop-Gain</b>\nâœ… Gatilho salvo: <b>{value:.2f}%</b>",
            reply_markup=stopgain_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("NÃ£o entendi. Envie um nÃºmero (ex.: 3).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] stop_gain_trigger_pct: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END


async def receive_stop_gain_lock(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip().replace("%", "").replace(",", ".")
    db = SessionLocal()
    try:
        value = float(text)
        if value < 0 or value > 100:
            await update.message.reply_text("Valor invÃ¡lido. Envie entre 0 e 100 (ex.: 1)."); return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("UsuÃ¡rio nÃ£o encontrado. Use /start para registrar."); return ConversationHandler.END
        user.stop_gain_lock_pct = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"ğŸ›¡ï¸ <b>Stop-Gain</b>\nâœ… Trava salva: <b>{value:.2f}%</b>",
            reply_markup=stopgain_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("NÃ£o entendi. Envie um nÃºmero (ex.: 1).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] stop_gain_lock_pct: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END

# ---- DISJUNTOR ----
async def receive_circuit_threshold(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip()
    db = SessionLocal()
    try:
        value = int(float(text))
        if value < 0 or value > 1000:
            await update.message.reply_text("Valor invÃ¡lido. Envie um inteiro entre 0 e 1000 (ex.: 3).")
            return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("UsuÃ¡rio nÃ£o encontrado. Use /start para registrar."); return ConversationHandler.END
        user.circuit_breaker_threshold = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"ğŸš« <b>Disjuntor</b>\nâœ… Limite salvo: <b>{value}</b>",
            reply_markup=circuit_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("NÃ£o entendi. Envie um nÃºmero inteiro (ex.: 3).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] circuit_breaker_threshold: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END

async def receive_circuit_pause(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip().lower().replace("min", "").replace("m", "")
    db = SessionLocal()
    try:
        value = int(float(text))
        if value < 0 or value > 1440:
            await update.message.reply_text("Valor invÃ¡lido. Envie um inteiro entre 0 e 1440 (ex.: 120).")
            return ConversationHandler.END
        user = db.query(User).filter_by(telegram_id=update.effective_user.id).first()
        if not user:
            await update.message.reply_text("UsuÃ¡rio nÃ£o encontrado. Use /start para registrar."); return ConversationHandler.END
        user.circuit_breaker_pause_minutes = value; db.commit()
        try: await update.message.delete()
        except Exception: pass
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"ğŸš« <b>Disjuntor</b>\nâœ… Pausa salva: <b>{value} min</b>",
            reply_markup=circuit_menu_keyboard(user), parse_mode="HTML",
        )
    except ValueError:
        await update.message.reply_text("NÃ£o entendi. Envie um nÃºmero inteiro (ex.: 120).")
    except Exception as e:
        db.rollback(); logger.error(f"[settings] circuit_breaker_pause_minutes: {e}", exc_info=True)
        await update.message.reply_text("Erro ao salvar. Tente novamente.")
    finally:
        db.close()
    return ConversationHandler.END

async def signal_filters_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de configuraÃ§Ã£o de filtros de sinais."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            await query.edit_message_text(
                "<b>ğŸ”¬ Filtros de AnÃ¡lise TÃ©cnica</b>\n\n"
                "Ative e configure filtros para melhorar a qualidade dos sinais executados.",
                parse_mode='HTML',
                reply_markup=signal_filters_keyboard(user)
            )
    finally:
        db.close()

async def toggle_ma_filter_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ativa ou desativa o filtro de MÃ©dia MÃ³vel."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            user.is_ma_filter_enabled = not user.is_ma_filter_enabled
            db.commit()
            await query.edit_message_reply_markup(reply_markup=signal_filters_keyboard(user))
    finally:
        db.close()

async def toggle_rsi_filter_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ativa ou desativa o filtro de RSI."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            user.is_rsi_filter_enabled = not user.is_rsi_filter_enabled
            db.commit()
            await query.edit_message_reply_markup(reply_markup=signal_filters_keyboard(user))
    finally:
        db.close()

# --- Handlers para configurar os valores (exemplo para PerÃ­odo da MA) ---

async def ask_ma_period(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta o novo perÃ­odo da MÃ©dia MÃ³vel."""
    query = update.callback_query
    await query.answer()
    context.user_data['settings_message_id'] = query.message.message_id
    await query.edit_message_text("Envie o perÃ­odo para a MÃ©dia MÃ³vel (ex: 50).")
    return ASKING_MA_PERIOD

async def receive_ma_period(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe e salva o novo perÃ­odo da MA."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)
    try:
        value = int(update.message.text)
        if not (5 <= value <= 200): raise ValueError("Valor fora do range")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.ma_period = value
            db.commit()
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id, message_id=message_id_to_edit,
                text=f"âœ… PerÃ­odo da MA atualizado para {value}.",
                reply_markup=signal_filters_keyboard(user)
            )
        finally:
            db.close()
    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id, message_id=message_id_to_edit,
            text="âŒ Valor invÃ¡lido. Envie um nÃºmero inteiro entre 5 e 200."
        )
        return ASKING_MA_PERIOD
    return ConversationHandler.END

# --- Handlers para o Timeframe da MÃ©dia MÃ³vel ---
async def ask_ma_timeframe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe as opÃ§Ãµes de timeframe para o usuÃ¡rio escolher."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            await query.edit_message_text(
                "Selecione o tempo grÃ¡fico para o cÃ¡lculo da MÃ©dia MÃ³vel:",
                reply_markup=ma_timeframe_keyboard(user)
            )
    finally:
        db.close()

async def set_ma_timeframe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Define o timeframe escolhido pelo usuÃ¡rio."""
    query = update.callback_query
    await query.answer()
    timeframe = query.data.split('_')[-1]
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            user.ma_timeframe = timeframe
            user.rsi_timeframe = timeframe # Sincroniza o timeframe do RSI por simplicidade
            db.commit()
            await query.edit_message_text(
                f"âœ… Timeframe atualizado para {timeframe} minutos.",
                reply_markup=signal_filters_keyboard(user)
            )
    finally:
        db.close()


# --- Handlers para o Limite de Sobrevenda do RSI ---
async def ask_rsi_oversold(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    context.user_data['settings_message_id'] = query.message.message_id
    await query.edit_message_text("Envie o limite de **Sobrevenda** para o RSI (ex: 30).\nSinais de SHORT serÃ£o rejeitados se o RSI estiver abaixo deste valor.")
    return ASKING_RSI_OVERSOLD

async def receive_rsi_oversold(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)
    try:
        value = int(update.message.text)
        if not (10 <= value <= 40): raise ValueError("Valor fora do range")
        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.rsi_oversold_threshold = value
            db.commit()
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id, message_id=message_id_to_edit,
                text=f"âœ… Limite de Sobrevenda do RSI atualizado para {value}.",
                reply_markup=signal_filters_keyboard(user)
            )
        finally:
            db.close()
    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id, message_id=message_id_to_edit,
            text="âŒ Valor invÃ¡lido. Envie um nÃºmero inteiro entre 10 e 40."
        )
        return ASKING_RSI_OVERSOLD
    return ConversationHandler.END

# --- Handlers para o Limite de Sobrecompra do RSI ---
async def ask_rsi_overbought(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    context.user_data['settings_message_id'] = query.message.message_id
    await query.edit_message_text("Envie o limite de **Sobrecompra** para o RSI (ex: 70).\nSinais de LONG serÃ£o rejeitados se o RSI estiver acima deste valor.")
    return ASKING_RSI_OVERBOUGHT

async def receive_rsi_overbought(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)
    try:
        value = int(update.message.text)
        if not (60 <= value <= 90): raise ValueError("Valor fora do range")
        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.rsi_overbought_threshold = value
            db.commit()
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id, message_id=message_id_to_edit,
                text=f"âœ… Limite de Sobrecompra do RSI atualizado para {value}.",
                reply_markup=signal_filters_keyboard(user)
            )
        finally:
            db.close()
    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id, message_id=message_id_to_edit,
            text="âŒ Valor invÃ¡lido. Envie um nÃºmero inteiro entre 60 e 90."
        )
        return ASKING_RSI_OVERBOUGHT
    return ConversationHandler.END

async def show_risk_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("NÃ£o encontrei seu usuÃ¡rio. Use /start para registrar.")
            return
        header = ("ğŸ§® <b>Risco & Tamanho</b>\n<i>Ajuste parÃ¢metros de risco e tamanho de posiÃ§Ã£o.</i>\n\n"
                  f"{_risk_summary(user)}")
        await query.edit_message_text(text=header, reply_markup=risk_menu_keyboard(user), parse_mode="HTML")
    except Exception as e:
        logger.error(f"[settings] submenu Risco: {e}", exc_info=True)
        await query.edit_message_text("NÃ£o foi possÃ­vel abrir o submenu de Risco agora.")
    finally:
        db.close()

async def show_stopgain_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("NÃ£o encontrei seu usuÃ¡rio. Use /start para registrar.")
            return
        header = ("ğŸ›¡ï¸ <b>Stop-Gain</b>\n<i>Configure gatilho e trava do stop-gain.</i>\n\n"
                  f"{_stopgain_summary(user)}")
        await query.edit_message_text(text=header, reply_markup=stopgain_menu_keyboard(user), parse_mode="HTML")
    except Exception as e:
        logger.error(f"[settings] submenu Stop-Gain: {e}", exc_info=True)
        await query.edit_message_text("NÃ£o foi possÃ­vel abrir o submenu de Stop-Gain agora.")
    finally:
        db.close()

async def show_circuit_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("NÃ£o encontrei seu usuÃ¡rio. Use /start para registrar.")
            return
        header = ("ğŸš« <b>Disjuntor</b>\n<i>Defina limite e pausa apÃ³s disparo.</i>\n\n"
                  f"{_circuit_summary(user)}")
        await query.edit_message_text(text=header, reply_markup=circuit_menu_keyboard(user), parse_mode="HTML")
    except Exception as e:
        logger.error(f"[settings] submenu Disjuntor: {e}", exc_info=True)
        await query.edit_message_text("NÃ£o foi possÃ­vel abrir o submenu de Disjuntor agora.")
    finally:
        db.close()

async def back_to_settings_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == query.from_user.id).first()
        if not user:
            await query.edit_message_text("NÃ£o encontrei seu usuÃ¡rio. Use /start para registrar.")
            return
        header = "âš™ï¸ <b>ConfiguraÃ§Ãµes de Trade</b>\n<i>Escolha uma categoria para ajustar seus parÃ¢metros.</i>"
        await query.edit_message_text(text=header, reply_markup=settings_menu_keyboard(user), parse_mode="HTML")
    except Exception as e:
        logger.error(f"[settings] voltar menu raiz: {e}", exc_info=True)
        await query.edit_message_text("NÃ£o foi possÃ­vel voltar ao menu de configuraÃ§Ãµes agora.")
    finally:
        db.close()

async def back_from_whitelist_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Sai do estado de ediÃ§Ã£o da Whitelist e volta ao menu de ConfiguraÃ§Ãµes."""
    # reaproveita o handler existente para renderizar o menu
    await back_to_settings_menu_handler(update, context)
    return ConversationHandler.END

========================================
# Arquivo: bot/keyboards.py
========================================

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from database.crud import get_user_by_id

def main_menu_keyboard(telegram_id: int):
    """
    Retorna o teclado do menu principal de forma inteligente,
    verificando o status do usuÃ¡rio diretamente no banco de dados.
    """
    user = get_user_by_id(telegram_id)
    has_api_keys = user and user.api_key_encrypted is not None

    keyboard = []
    if has_api_keys:
        keyboard.append([InlineKeyboardButton("â„¹ï¸ Meu Painel", callback_data='user_dashboard')])
        keyboard.append([InlineKeyboardButton("ğŸ“Š Minhas PosiÃ§Ãµes", callback_data='user_positions')])
        
        # --- BOTÃƒO ADICIONADO AQUI ---
        keyboard.append([InlineKeyboardButton("ğŸ“ˆ Desempenho", callback_data='perf_today')])
        
        keyboard.append([InlineKeyboardButton("âš™ï¸ ConfiguraÃ§Ãµes de Trade", callback_data='user_settings')])
        keyboard.append([InlineKeyboardButton("ğŸ¤– ConfiguraÃ§Ã£o do Bot", callback_data='bot_config')])
    else:
        keyboard.append([InlineKeyboardButton("âš™ï¸ Configurar API Bybit", callback_data='config_api')])

    return InlineKeyboardMarkup(keyboard)

def dashboard_menu_keyboard(user):
    """Retorna o teclado para o painel do usuÃ¡rio, com a opÃ§Ã£o de remover a API e ligar/desligar o bot."""
    
    # LÃ³gica do botÃ£o Ãºnico de 3 estados
    if not user.is_active:
        # Estado 1: Pausado
        toggle_button_text = "Bot: Pausado â¸ï¸"
    elif user.is_active and not user.is_sleep_mode_enabled:
        # Estado 2: Ativo 24h
        toggle_button_text = "Bot: Ativo â˜€ï¸"
    else: # user.is_active and user.is_sleep_mode_enabled
        # Estado 3: Ativo com Modo Dormir
        toggle_button_text = "Bot: Ativo com Modo Dormir ğŸ˜´"
    
    keyboard = [
        [InlineKeyboardButton(toggle_button_text, callback_data='toggle_bot_status')],
        [InlineKeyboardButton("ğŸ—‘ï¸ Remover API", callback_data='remove_api_prompt')],
        [InlineKeyboardButton("â¬…ï¸ Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def admin_menu_keyboard():
    """Retorna o teclado do menu de administrador."""
    keyboard = [
        [InlineKeyboardButton("ğŸ“¡ Listar Grupos/Canais", callback_data='admin_list_channels')],
        # --- NOVO BOTÃƒO ---
        [InlineKeyboardButton("ğŸ‘ï¸ Ver Alvos Ativos", callback_data='admin_view_targets')]
    ]
    return InlineKeyboardMarkup(keyboard)

def view_targets_keyboard():
    """Retorna o teclado para a tela de visualizaÃ§Ã£o de alvos, com um botÃ£o de voltar."""
    keyboard = [
        [InlineKeyboardButton("â¬…ï¸ Voltar ao Menu Admin", callback_data='back_to_admin_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def confirm_remove_keyboard():
    """Retorna o teclado de confirmaÃ§Ã£o para remover a API."""
    keyboard = [
        [InlineKeyboardButton("âœ… Sim, remover", callback_data='remove_api_confirm')],
        [InlineKeyboardButton("âŒ NÃ£o, cancelar", callback_data='remove_api_cancel')],
    ]
    return InlineKeyboardMarkup(keyboard)

def settings_menu_keyboard(user) -> InlineKeyboardMarkup:
    kb = [
        [
            InlineKeyboardButton("ğŸ§® Risco & Tamanho", callback_data="settings_risk"),
            InlineKeyboardButton("ğŸ›¡ï¸ Stop-Gain", callback_data="settings_stopgain"),
        ],
        [
            InlineKeyboardButton("ğŸš« Disjuntor", callback_data="settings_circuit"),
            InlineKeyboardButton("âœ… Whitelist", callback_data="set_coin_whitelist"),
        ],
        [InlineKeyboardButton("ğŸ”¬ Filtros de Sinais", callback_data="signal_filters_menu")],
        [InlineKeyboardButton("â¬…ï¸ Voltar ao Menu", callback_data="back_to_main_menu")],
    ]
    return InlineKeyboardMarkup(kb)


def risk_menu_keyboard(user) -> InlineKeyboardMarkup:
    entry_pct = f"{float(getattr(user, 'entry_size_percent', 0) or 0):.1f}%"
    leverage  = f"{int(getattr(user, 'max_leverage', 0) or 0)}x"
    min_conf  = f"{float(getattr(user, 'min_confidence', 0) or 0):.1f}%"
    kb = [
        [InlineKeyboardButton(f"ğŸ“¥ Tamanho de Entrada ({entry_pct})", callback_data="set_entry_percent")],
        [InlineKeyboardButton(f"âš™ï¸ Alavancagem MÃ¡x. ({leverage})", callback_data="set_max_leverage")],
        [InlineKeyboardButton(f"ğŸ¯ ConfianÃ§a MÃ­n. ({min_conf})", callback_data="set_min_confidence")],
        [InlineKeyboardButton("â¬…ï¸ Voltar", callback_data="back_to_settings_menu")],
    ]
    return InlineKeyboardMarkup(kb)

def _read_stop_strategy_label(user) -> str:
    raw = (getattr(user, "stop_strategy", None)
           or getattr(user, "stop_strategy_mode", None)
           or getattr(user, "stop_strategy_type", None)
           or "breakeven")
    raw = str(raw).lower()
    return "Breakeven" if raw.startswith("b") else "Trailing"

def stopgain_menu_keyboard(user) -> InlineKeyboardMarkup:
    trigger = f"{float(getattr(user, 'stop_gain_trigger_pct', 0) or 0):.2f}%"
    lock    = f"{float(getattr(user, 'stop_gain_lock_pct', 0) or 0):.2f}%"
    strategy_label = _read_stop_strategy_label(user)

    kb = [
        [InlineKeyboardButton(f"ğŸ§­ EstratÃ©gia: {strategy_label}", callback_data="set_stop_strategy")],
        [InlineKeyboardButton(f"ğŸš€ Gatilho Stop-Gain ({trigger})", callback_data="set_stop_gain_trigger")],
        [InlineKeyboardButton(f"ğŸ”’ Trava Stop-Gain ({lock})", callback_data="set_stop_gain_lock")],
        [InlineKeyboardButton("â¬…ï¸ Voltar", callback_data="back_to_settings_menu")],
    ]
    return InlineKeyboardMarkup(kb)

def circuit_menu_keyboard(user) -> InlineKeyboardMarkup:
    threshold = f"{int(getattr(user, 'circuit_breaker_threshold', 0) or 0)}"
    pause     = f"{int(getattr(user, 'circuit_breaker_pause_minutes', 0) or 0)} min"
    kb = [
        [InlineKeyboardButton(f"âš¡ Limite do Disjuntor ({threshold})", callback_data="set_circuit_threshold")],
        [InlineKeyboardButton(f"â¸ï¸ Pausa apÃ³s Disparo ({pause})", callback_data="set_circuit_pause")],
        [InlineKeyboardButton("â¬…ï¸ Voltar", callback_data="back_to_settings_menu")],
    ]
    return InlineKeyboardMarkup(kb)

def bot_config_keyboard(user_settings):
    """
    Retorna o teclado para o menu de configuraÃ§Ã£o do bot, mostrando o modo de aprovaÃ§Ã£o e as metas.
    """
    # BotÃ£o de Modo de AprovaÃ§Ã£o (lÃ³gica existente)
    mode = user_settings.approval_mode
    if mode == 'AUTOMATIC':
        approval_button_text = "Entrada de Sinais: AutomÃ¡tico âš¡"
    else:
        approval_button_text = "Entrada de Sinais: Manual ğŸ‘‹"

    # --- NOVOS BOTÃ•ES DE METAS ---
    # Formata a meta de lucro para exibiÃ§Ã£o
    profit_target = user_settings.daily_profit_target
    profit_text = f"Meta de Lucro DiÃ¡ria: ${profit_target:.2f}" if profit_target > 0 else "Meta de Lucro DiÃ¡ria: Desativada"

    # Formata o limite de perda para exibiÃ§Ã£o
    loss_limit = user_settings.daily_loss_limit
    loss_text = f"Limite de Perda DiÃ¡rio: ${loss_limit:.2f}" if loss_limit > 0 else "Limite de Perda DiÃ¡rio: Desativado"

    keyboard = [
        [InlineKeyboardButton(approval_button_text, callback_data='toggle_approval_mode')],
        # --- NOVAS LINHAS ADICIONADAS AO TECLADO ---
        [InlineKeyboardButton(profit_text, callback_data='set_profit_target')],
        [InlineKeyboardButton(loss_text, callback_data='set_loss_limit')],
        [InlineKeyboardButton("â¬…ï¸ Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def signal_approval_keyboard(signal_for_approval_id: int):
    """
    Retorna o teclado com os botÃµes de Aprovar/Rejeitar para um sinal manual.
    """
    keyboard = [
        [
            InlineKeyboardButton("âœ… Aprovar Entrada", callback_data=f'approve_signal_{signal_for_approval_id}'),
            InlineKeyboardButton("âŒ Rejeitar", callback_data=f'reject_signal_{signal_for_approval_id}')
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

def performance_menu_keyboard():
    """
    Retorna o teclado para o menu de anÃ¡lise de desempenho com filtros de perÃ­odo.
    """
    keyboard = [
        [
            InlineKeyboardButton("Hoje", callback_data='perf_today'),
            InlineKeyboardButton("Ontem", callback_data='perf_yesterday')
        ],
        [
            InlineKeyboardButton("Ãšltimos 7 Dias", callback_data='perf_7_days'),
            InlineKeyboardButton("Ãšltimos 30 Dias", callback_data='perf_30_days')
        ],
        [InlineKeyboardButton("ğŸ“œ HistÃ³rico de Trades", callback_data='list_closed_trades')],
        [InlineKeyboardButton("â¬…ï¸ Voltar ao Menu Principal", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def confirm_manual_close_keyboard(trade_id: int):
    """Retorna o teclado de confirmaÃ§Ã£o para o fechamento manual de um trade."""
    keyboard = [
        [
            InlineKeyboardButton("âœ… Sim, fechar", callback_data=f'execute_close_{trade_id}'),
            InlineKeyboardButton("âŒ Cancelar", callback_data='user_positions') # Volta para a lista de posiÃ§Ãµes
        ],
    ]
    return InlineKeyboardMarkup(keyboard)

def signal_filters_keyboard(user_settings):
    """
    Retorna o teclado para o menu de configuraÃ§Ã£o dos filtros de anÃ¡lise tÃ©cnica.
    """
    # BotÃ£o para o filtro de MÃ©dia MÃ³vel (MA)
    ma_status_icon = "âœ…" if user_settings.is_ma_filter_enabled else "âŒ"
    ma_text = f"{ma_status_icon} Filtro de MÃ©dia MÃ³vel"

    # BotÃ£o para o filtro de RSI
    rsi_status_icon = "âœ…" if user_settings.is_rsi_filter_enabled else "âŒ"
    rsi_text = f"{rsi_status_icon} Filtro de RSI"
    
    keyboard = [
        [InlineKeyboardButton("Voltar para ConfiguraÃ§Ãµes â¬…ï¸", callback_data='user_settings')],
        [
            InlineKeyboardButton(ma_text, callback_data='toggle_ma_filter'),
            InlineKeyboardButton(f"PerÃ­odo MA: {user_settings.ma_period}", callback_data='set_ma_period')
        ],
        [
            InlineKeyboardButton(rsi_text, callback_data='toggle_rsi_filter'),
            InlineKeyboardButton(f"Sobrecompra: {user_settings.rsi_overbought_threshold}", callback_data='set_rsi_overbought')
        ],
        [
            InlineKeyboardButton(f"Timeframe: {user_settings.ma_timeframe} min", callback_data='ask_ma_timeframe'),
            InlineKeyboardButton(f"Sobrevenda: {user_settings.rsi_oversold_threshold}", callback_data='set_rsi_oversold')
        ],
    ]
    return InlineKeyboardMarkup(keyboard)

def ma_timeframe_keyboard(user_settings):
    """
    Retorna o teclado com as opÃ§Ãµes de timeframe para a MÃ©dia MÃ³vel.
    """
    # Marca o timeframe atual com um emoji
    timeframes = {'15': '15 min', '60': '1 hora', '240': '4 horas', 'D': 'DiÃ¡rio'}
    keyboard_buttons = []
    
    for tf_value, tf_text in timeframes.items():
        prefix = "âœ… " if user_settings.ma_timeframe == tf_value else ""
        keyboard_buttons.append(
            InlineKeyboardButton(f"{prefix}{tf_text}", callback_data=f"set_ma_timeframe_{tf_value}")
        )
    
    # Organiza os botÃµes em duas colunas
    keyboard = [keyboard_buttons[i:i + 2] for i in range(0, len(keyboard_buttons), 2)]
    keyboard.append([InlineKeyboardButton("â¬…ï¸ Voltar para Filtros", callback_data='signal_filters_menu')])
    return InlineKeyboardMarkup(keyboard)

========================================
# Arquivo: alembic/env.py
========================================

import os
import sys
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# Adiciona a raiz do projeto ao path para que possamos importar 'database.models'
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from database.models import Base

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # --- INÃCIO DA MODIFICAÃ‡ÃƒO ---
    # Pega a configuraÃ§Ã£o do alembic.ini
    configuration = config.get_section(config.config_ini_section, {})
    # Tenta pegar a URL de uma variÃ¡vel de ambiente, se nÃ£o existir, usa a do .ini
    url = os.getenv('DATABASE_URL', configuration['sqlalchemy.url'])
    configuration['sqlalchemy.url'] = url
    
    connectable = engine_from_config(
        configuration, # Usa a configuraÃ§Ã£o modificada
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


========================================
# Arquivo: alembic/versions/657fc8fb3f24_adiciona_filtros_de_analise_tecnica.py
========================================

"""adiciona_filtros_de_analise_tecnica

Revision ID: 657fc8fb3f24
Revises: c19acb6f35e0
Create Date: 2025-08-26 18:19:40.264746

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '657fc8fb3f24'
down_revision: Union[str, Sequence[str], None] = 'c19acb6f35e0'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('is_ma_filter_enabled', sa.Boolean(), nullable=False))
    op.add_column('users', sa.Column('ma_period', sa.Integer(), nullable=False))
    op.add_column('users', sa.Column('ma_timeframe', sa.String(length=10), nullable=False))
    op.add_column('users', sa.Column('is_rsi_filter_enabled', sa.Boolean(), nullable=False))
    op.add_column('users', sa.Column('rsi_timeframe', sa.String(length=10), nullable=False))
    op.add_column('users', sa.Column('rsi_oversold_threshold', sa.Integer(), nullable=False))
    op.add_column('users', sa.Column('rsi_overbought_threshold', sa.Integer(), nullable=False))
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('users', 'rsi_overbought_threshold')
    op.drop_column('users', 'rsi_oversold_threshold')
    op.drop_column('users', 'rsi_timeframe')
    op.drop_column('users', 'is_rsi_filter_enabled')
    op.drop_column('users', 'ma_timeframe')
    op.drop_column('users', 'ma_period')
    op.drop_column('users', 'is_ma_filter_enabled')
    # ### end Alembic commands ###


========================================
# Arquivo: alembic/versions/b2a5a70c97b3_add_missing_cycles_and_last_seen_at_to_.py
========================================

"""add missing_cycles and last_seen_at to trades

Revision ID: b2a5a70c97b3
Revises: 657fc8fb3f24
Create Date: 2025-08-29 10:39:42.185181

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'b2a5a70c97b3'
down_revision: Union[str, Sequence[str], None] = '657fc8fb3f24'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None



def upgrade() -> None:
    bind = op.get_bind()
    insp = sa.inspect(bind)
    cols = {c["name"] for c in insp.get_columns("trades")}
    dialect = bind.dialect.name  # "sqlite", "postgresql", etc.

    # missing_cycles
    if "missing_cycles" not in cols:
        op.add_column(
            "trades",
            sa.Column("missing_cycles", sa.Integer(), nullable=False, server_default="0"),
        )
        # Remover default apenas em Postgres; SQLite nÃ£o suporta DROP DEFAULT
        if dialect == "postgresql":
            op.execute("ALTER TABLE trades ALTER COLUMN missing_cycles DROP DEFAULT")

    # last_seen_at
    if "last_seen_at" not in cols:
        op.add_column(
            "trades",
            sa.Column("last_seen_at", sa.DateTime(timezone=True), nullable=True),
        )

def downgrade() -> None:
    bind = op.get_bind()
    insp = sa.inspect(bind)
    cols = {c["name"] for c in insp.get_columns("trades")}

    if "last_seen_at" in cols:
        op.drop_column("trades", "last_seen_at")
    if "missing_cycles" in cols:
        op.drop_column("trades", "missing_cycles")

========================================
# Arquivo: alembic/versions/c19acb6f35e0_versao_inicial_do_projeto.py
========================================

"""versao_inicial_do_projeto

Revision ID: c19acb6f35e0
Revises: 
Create Date: 2025-08-26 17:47:42.959909

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'c19acb6f35e0'
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('invite_codes',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('code', sa.String(), nullable=False),
    sa.Column('is_used', sa.Boolean(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('code')
    )
    op.create_table('monitored_targets',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('channel_id', sa.BigInteger(), nullable=False),
    sa.Column('channel_name', sa.String(), nullable=True),
    sa.Column('topic_id', sa.BigInteger(), nullable=True),
    sa.Column('topic_name', sa.String(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('topic_id')
    )
    op.create_table('pending_signals',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('symbol', sa.String(), nullable=False),
    sa.Column('order_id', sa.String(), nullable=False),
    sa.Column('signal_data', sa.JSON(), nullable=False),
    sa.Column('notification_message_id', sa.BigInteger(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('order_id'),
    sa.UniqueConstraint('user_telegram_id', 'symbol', name='_user_symbol_uc')
    )
    op.create_index(op.f('ix_pending_signals_symbol'), 'pending_signals', ['symbol'], unique=False)
    op.create_index(op.f('ix_pending_signals_user_telegram_id'), 'pending_signals', ['user_telegram_id'], unique=False)
    op.create_table('signals_for_approval',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('symbol', sa.String(), nullable=False),
    sa.Column('source_name', sa.String(), nullable=True),
    sa.Column('signal_data', sa.JSON(), nullable=False),
    sa.Column('approval_message_id', sa.BigInteger(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_signals_for_approval_user_telegram_id'), 'signals_for_approval', ['user_telegram_id'], unique=False)
    op.create_table('trades',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('order_id', sa.String(), nullable=False),
    sa.Column('notification_message_id', sa.BigInteger(), nullable=True),
    sa.Column('symbol', sa.String(), nullable=False),
    sa.Column('side', sa.String(), nullable=False),
    sa.Column('qty', sa.Float(), nullable=False),
    sa.Column('entry_price', sa.Float(), nullable=True),
    sa.Column('stop_loss', sa.Float(), nullable=True),
    sa.Column('current_stop_loss', sa.Float(), nullable=True),
    sa.Column('initial_targets', sa.JSON(), nullable=True),
    sa.Column('total_initial_targets', sa.Integer(), nullable=True),
    sa.Column('status', sa.String(), nullable=True),
    sa.Column('remaining_qty', sa.Float(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=True),
    sa.Column('closed_at', sa.DateTime(timezone=True), nullable=True),
    sa.Column('closed_pnl', sa.Float(), nullable=True),
    sa.Column('is_breakeven', sa.Boolean(), nullable=False),
    sa.Column('trail_high_water_mark', sa.Float(), nullable=True),
    sa.Column('is_stop_gain_active', sa.Boolean(), nullable=False),
    sa.Column('unrealized_pnl_pct', sa.Float(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('order_id')
    )
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('first_name', sa.String(), nullable=True),
    sa.Column('api_key_encrypted', sa.String(), nullable=True),
    sa.Column('api_secret_encrypted', sa.String(), nullable=True),
    sa.Column('entry_size_percent', sa.Float(), nullable=True),
    sa.Column('max_leverage', sa.Integer(), nullable=True),
    sa.Column('min_confidence', sa.Float(), nullable=True),
    sa.Column('approval_mode', sa.String(), nullable=False),
    sa.Column('daily_profit_target', sa.Float(), nullable=False),
    sa.Column('daily_loss_limit', sa.Float(), nullable=False),
    sa.Column('coin_whitelist', sa.String(), nullable=False),
    sa.Column('stop_strategy', sa.String(length=20), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('stop_gain_trigger_pct', sa.Float(), nullable=False),
    sa.Column('stop_gain_lock_pct', sa.Float(), nullable=False),
    sa.Column('circuit_breaker_threshold', sa.Integer(), nullable=False),
    sa.Column('circuit_breaker_pause_minutes', sa.Integer(), nullable=False),
    sa.Column('long_trades_paused_until', sa.DateTime(timezone=True), nullable=True),
    sa.Column('short_trades_paused_until', sa.DateTime(timezone=True), nullable=True),
    sa.Column('is_sleep_mode_enabled', sa.Boolean(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_telegram_id'), 'users', ['telegram_id'], unique=True)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_users_telegram_id'), table_name='users')
    op.drop_table('users')
    op.drop_table('trades')
    op.drop_index(op.f('ix_signals_for_approval_user_telegram_id'), table_name='signals_for_approval')
    op.drop_table('signals_for_approval')
    op.drop_index(op.f('ix_pending_signals_user_telegram_id'), table_name='pending_signals')
    op.drop_index(op.f('ix_pending_signals_symbol'), table_name='pending_signals')
    op.drop_table('pending_signals')
    op.drop_table('monitored_targets')
    op.drop_table('invite_codes')
    # ### end Alembic commands ###


========================================
# Arquivo: alembic/versions/ea992c8d7b70_add_trades_missing_cycles_and_last_seen_.py
========================================

"""add trades.missing_cycles and last_seen_at

Revision ID: ea992c8d7b70
Revises: b2a5a70c97b3
Create Date: 2025-08-29 12:39:12.562656

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'ea992c8d7b70'
down_revision: Union[str, Sequence[str], None] = 'b2a5a70c97b3'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


========================================
# Arquivo: services/__init__.py
========================================



========================================
# Arquivo: services/bybit_service.py
========================================

import logging
import asyncio
import os
import random
from typing import Dict, Any, Optional
from datetime import datetime, time, timedelta
from pybit.unified_trading import HTTP
from pybit.exceptions import InvalidRequestError
from database.models import User
from decimal import Decimal, ROUND_DOWN, ROUND_CEILING
from telegram import InlineKeyboardButton, InlineKeyboardMarkup

logger = logging.getLogger(__name__)
INSTRUMENT_INFO_CACHE: Dict[str, Any] = {}

def _round_down_to_step(value: Decimal, step: Decimal) -> Decimal:
    """Arredonda para BAIXO no mÃºltiplo de 'step' (quantidade)."""
    if step <= 0:
        return value
    return (value // step) * step

def _round_down_to_tick(price: Decimal, tick: Decimal) -> Decimal:
    """Arredonda para BAIXO no mÃºltiplo de 'tick' (preÃ§o)."""
    if tick <= 0:
        return price
    return (price // tick) * tick

def _round_up_to_tick(price: Decimal, tick: Decimal) -> Decimal:
    """Arredonda para CIMA no mÃºltiplo de 'tick' (preÃ§o), sem alterar se jÃ¡ estiver alinhado."""
    if tick <= 0:
        return price
    q, r = divmod(price, tick)
    if r == 0:
        return price
    return (q + 1) * tick

def _apply_safety_ticks(
    side: str,
    desired_sl: Decimal,
    last_price: Decimal,
    tick: Decimal,
    safety_ticks: int
) -> Decimal:
    """
    Garante distÃ¢ncia mÃ­nima de N ticks do last_price, respeitando o lado:
      - LONG  (posiÃ§Ã£o Buy):  SL < last_price - N*tick  (usa floor)
      - SHORT (posiÃ§Ã£o Sell): SL > last_price + N*tick  (usa ceil)
    Retorna preÃ§o jÃ¡ alinhado ao tick.
    """
    if tick <= 0 or safety_ticks <= 0:
        return desired_sl

    n = Decimal(safety_ticks)
    if side.upper() in ("LONG", "BUY"):
        limite_max = last_price - (n * tick)   # deve ser estritamente abaixo do last
        # alinhar o limite para baixo no tick
        if limite_max > 0:
            limite_max = (limite_max // tick) * tick
        # nunca acima do limite
        return desired_sl if desired_sl <= limite_max else limite_max

    else:  # SHORT / SELL
        limite_min = last_price + (n * tick)   # deve ser estritamente acima do last
        # alinhar o limite para cima no tick
        if tick > 0:
            q, r = divmod(limite_min, tick)
            if r != 0:
                limite_min = (q + 1) * tick
        # nunca abaixo do limite
        return desired_sl if desired_sl >= limite_min else limite_min

async def get_instrument_info(symbol: str) -> Dict[str, Any]:
    """
    Busca as regras de um instrumento (sÃ­mbolo) da Bybit, usando um cache em memÃ³ria.
    """
    if symbol in INSTRUMENT_INFO_CACHE:
        return INSTRUMENT_INFO_CACHE[symbol]

    def _sync_call():
        try:
            # SessÃ£o nÃ£o autenticada com timeout (sem 'retries')
            session = HTTP(testnet=False, timeout=30)
            response = session.get_instruments_info(category="linear", symbol=symbol)
            
            if response.get("retCode") != 0:
                return {"success": False, "error": response.get("retMsg")}
            
            instrument_list = response.get("result", {}).get("list", [])
            if not instrument_list:
                return {"success": False, "error": f"SÃ­mbolo {symbol} nÃ£o encontrado na Bybit."}

            info = instrument_list[0]
            lot_size_filter = info.get("lotSizeFilter", {})
            price_filter = info.get("priceFilter", {})

            rules = {
                "success": True,
                "status": info.get("status"),
                "qtyStep": Decimal(lot_size_filter.get("qtyStep", "0")),
                "minOrderQty": Decimal(lot_size_filter.get("minOrderQty", "0")),
                "minNotionalValue": Decimal(lot_size_filter.get("minOrderIv", "0")),
                "tickSize": Decimal(price_filter.get("tickSize", "0")),
            }
            INSTRUMENT_INFO_CACHE[symbol] = rules
            return rules
    
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_instrument_info para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


# FunÃ§Ã£o auxiliar sÃ­ncrona, nÃ£o precisa de 'async'
def get_session(api_key: str, api_secret: str) -> HTTP:
    """Cria e retorna uma sessÃ£o HTTP para ser usada em threads."""
    return HTTP(
        testnet=False,
        api_key=api_key,
        api_secret=api_secret,
        timeout=30,
        recv_window=30000  # â†‘ aumentamos para mitigar 10002 por drift/latÃªncia
    )

def _resolve_position_index(session, symbol: str, close_side: str) -> Dict[str, Any]:
    """
    Descobre o mode (One-Way vs Hedge) e qual positionIdx usar (ou omitir) ao reduzir posiÃ§Ã£o.
    - One-Way: nÃ£o enviar positionIdx (ou usar 0).
    - Hedge: usar 1 (Long/Buy) para reduzir LONG; usar 2 (Short/Sell) para reduzir SHORT.

    close_side: "Buy" ou "Sell" (lado da ORDEM de fechamento, nÃ£o o 'trade.side').
    Retorna:
      {
        "mode": "one_way" | "hedge" | "unknown",
        "positionIdx": int | None,  # None => omitir no payload
        "position_found": bool,     # se hÃ¡ posiÃ§Ã£o aberta detectada
        "details": {...}            # dados brutos mÃ­nimos para log/inspeÃ§Ã£o
      }
    """
    try:
        resp = session.get_positions(category="linear", symbol=symbol)
        if resp.get("retCode") != 0:
            logger.warning(f"[bybit_service] _resolve_position_index: falha em get_positions para {symbol}: {resp.get('retMsg')}")
            # fallback seguro: omitir positionIdx
            return {"mode": "unknown", "positionIdx": None, "position_found": False, "details": {"reason": "api_error"}}

        items = (resp.get("result", {}) or {}).get("list", []) or []
        # NormalizaÃ§Ãµes Ãºteis
        positions_nonzero = [p for p in items if float(p.get("size") or 0) > 0]
        idxs = {int(p.get("positionIdx") or 0) for p in items}

        # HeurÃ­stica de detecÃ§Ã£o:
        # - One-Way geralmente retorna positionIdx 0 (ou Ãºnico item), e sÃ³ existe um lado efetivo.
        # - Hedge usa 1 (Long/Buy) e 2 (Short/Sell). Pode retornar dois itens para o sÃ­mbolo.
        mode = "one_way"
        if 1 in idxs or 2 in idxs:
            mode = "hedge"
        elif len(items) > 1:
            # VÃ¡rios itens mas sem 1/2 explÃ­citos â€” trate como hedge por seguranÃ§a
            mode = "hedge"

        # Mapeia qual idx usar conforme o lado que serÃ¡ reduzido
        # close_side = "Sell" se trade era LONG; "Buy" se trade era SHORT.
        position_idx = None
        position_found = False

        if mode == "hedge":
            # Encontre a posiÃ§Ã£o correspondente ao lado que serÃ¡ reduzido
            # Em Hedge, Buy = LONG (idx 1), Sell = SHORT (idx 2)
            desired_idx = 1 if close_side == "Sell" else 2
            for p in items:
                if int(p.get("positionIdx") or 0) == desired_idx and float(p.get("size") or 0) > 0:
                    position_found = True
                    break
            # Mesmo que size=0, ainda usamos o idx â€œcorretoâ€ para o lado.
            position_idx = desired_idx

        elif mode == "one_way":
            # Em One-Way, omita o campo (ou use 0). Preferimos omitir para evitar 10001.
            # Verifica se existe alguma posiÃ§Ã£o aberta > 0
            position_found = any(positions_nonzero)
            position_idx = None  # omitir

        details = {
            "raw_count": len(items),
            "idxs": sorted(list(idxs)),
            "close_side": close_side,
            "positions_nonzero": len(positions_nonzero),
        }

        logger.info(f"[bybit_service] _resolve_position_index {symbol}: mode={mode}, close_side={close_side}, use_idx={position_idx}, found={position_found}, details={details}")
        return {"mode": mode, "positionIdx": position_idx, "position_found": position_found, "details": details}

    except Exception as e:
        logger.error(f"ExceÃ§Ã£o em _resolve_position_index para {symbol}: {e}", exc_info=True)
        # fallback seguro: omitir positionIdx
        return {"mode": "unknown", "positionIdx": None, "position_found": False, "details": {"reason": "exception", "error": str(e)}}


async def get_account_info(api_key: str, api_secret: str) -> dict:
    """Busca o saldo da conta, calculando o saldo disponÃ­vel para Contas Unificadas."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.get_wallet_balance(accountType="UNIFIED")
            
            if response.get('retCode') == 0:
                account_data_list = response['result'].get('list', [])
                if not account_data_list:
                    return {"success": False, "data": {}, "error": "Lista de contas vazia na resposta da API."}
                
                account_data = account_data_list[0]
                equity_str = account_data.get('totalEquity')
                total_equity = float(equity_str) if equity_str else 0.0
                coin_list = account_data.get('coin', [])
                
                available_balance_usdt = 0.0
                for coin in coin_list:
                    if coin.get('coin') == 'USDT':
                        wallet_balance_str = coin.get('walletBalance', '0')
                        order_margin_str = coin.get('totalOrderIM', '0')
                        position_margin_str = coin.get('totalPositionIM', '0')

                        wallet_balance = float(wallet_balance_str) if wallet_balance_str else 0.0
                        order_margin = float(order_margin_str) if order_margin_str else 0.0
                        position_margin = float(position_margin_str) if position_margin_str else 0.0
                        
                        # CÃ¡lculo correto para Conta de Trading Unificada
                        available_balance_usdt = wallet_balance - order_margin - position_margin
                        break
                
                result_data = {
                    "total_equity": total_equity,
                    "available_balance_usdt": available_balance_usdt,
                    "coin_list": coin_list
                }
                return {"success": True, "data": result_data}
                
            return {"success": False, "data": {}, "error": response.get('retMsg', 'Erro desconhecido')}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_account_info: {e}", exc_info=True)
            return {"success": False, "data": {}, "error": str(e)}

    return await asyncio.to_thread(_sync_call)

async def place_order(api_key: str, api_secret: str, signal_data: dict, user_settings: User, balance: float) -> dict:
    """Abre uma nova posiÃ§Ã£o a mercado (Market) com validaÃ§Ã£o completa, incluindo verificaÃ§Ã£o de SL contra o preÃ§o atual."""
    symbol = signal_data['coin']
    
    # --- NOVA VERIFICAÃ‡ÃƒO DE PRÃ‰-VOO ---
    # Buscamos o preÃ§o de mercado ANTES de qualquer outra coisa
    price_check = await get_market_price(symbol)
    if not price_check.get("success"):
        return {"success": False, "error": f"NÃ£o foi possÃ­vel obter o preÃ§o de mercado atual para {symbol}."}
    current_market_price = Decimal(str(price_check["price"]))
    
    # Validamos o Stop Loss do sinal contra o preÃ§o atual
    side = "Buy" if (signal_data.get('order_type') or '').upper() == 'LONG' else "Sell"
    stop_loss_price = Decimal(str(signal_data.get('stop_loss')))

    if side == 'Buy' and stop_loss_price >= current_market_price:
        return {"success": False, "error": f"Stop Loss ({stop_loss_price}) invÃ¡lido para LONG. Deve ser menor que o preÃ§o atual ({current_market_price})."}
    if side == 'Sell' and stop_loss_price <= current_market_price:
        return {"success": False, "error": f"Stop Loss ({stop_loss_price}) invÃ¡lido para SHORT. Deve ser maior que o preÃ§o atual ({current_market_price})."}
    
    # Se a validaÃ§Ã£o passou, continuamos para a lÃ³gica de execuÃ§Ã£o sÃ­ncrona
    async def pre_flight_checks():
        if symbol not in INSTRUMENT_INFO_CACHE: await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            if not instrument_rules or not instrument_rules.get("success"): return instrument_rules or {"success": False, "error": f"Regras para {symbol} nÃ£o encontradas."}
            if instrument_rules["status"] != "Trading": return {"success": False, "error": f"O sÃ­mbolo {symbol} nÃ£o estÃ¡ ativo para negociaÃ§Ã£o ({instrument_rules['status']})."}

            session = get_session(api_key, api_secret)
            leverage = Decimal(str(user_settings.max_leverage))
            
            # Usamos o preÃ§o de mercado que acabamos de buscar para o cÃ¡lculo
            entry_price = current_market_price
            
            margin_in_dollars = Decimal(str(balance)) * (Decimal(str(user_settings.entry_size_percent)) / Decimal("100"))
            notional_value = margin_in_dollars * leverage
            
            if entry_price <= 0: return {"success": False, "error": f"PreÃ§o de entrada invÃ¡lido: {entry_price}"}
            qty_raw = notional_value / entry_price
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])

            if qty_adj < instrument_rules["minOrderQty"]:
                return {"success": False, "error": f"Qtd. ajustada ({qty_adj:f}) Ã© menor que a mÃ­nima permitida ({instrument_rules['minOrderQty']:f}) para {symbol}."}
            final_notional_value = qty_adj * entry_price
            if final_notional_value < instrument_rules["minNotionalValue"]:
                return {"success": False, "error": f"Valor total da ordem (${final_notional_value:.2f}) Ã© menor que o mÃ­nimo permitido de ${instrument_rules['minNotionalValue']:.2f}."}
            
            payload = {
                "category": "linear", "symbol": symbol, "side": side, "orderType": "Market", "qty": str(qty_adj),
                "takeProfit": str((signal_data.get('targets') or [None])[0]), "stopLoss": str(stop_loss_price),
            }
            try:
                session.set_leverage(category="linear", symbol=symbol, buyLeverage=str(leverage), sellLeverage=str(leverage))
            except InvalidRequestError as e:
                if "leverage not modified" in str(e).lower(): logger.warning(f"Alavancagem para {symbol} jÃ¡ estÃ¡ correta. Continuando...")
                else: return {"success": False, "error": str(e)}
            
            _safe_log_order_payload("place_order:market_entry", payload)
            response = session.place_order(**{k: v for k, v in payload.items() if v is not None})
            if response.get('retCode') == 0: return {"success": True, "data": response['result']}
            return {"success": False, "error": response.get('retMsg')}
      
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao abrir ordem (Market): {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"ExceÃ§Ã£o em place_order (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}


async def get_market_price(symbol: str) -> dict:
    """Busca o preÃ§o de mercado atual de forma assÃ­ncrona."""
    def _sync_call():
        try:
            session = HTTP(testnet=False, timeout=30)
            response = session.get_tickers(category="linear", symbol=symbol)
            if response.get('retCode') == 0 and response['result']['list']:
                price = float(response['result']['list'][0]['lastPrice'])
                return {"success": True, "price": price}
            else:
                return {"success": False, "error": response.get('retMsg', 'PreÃ§o nÃ£o encontrado')}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao buscar preÃ§o de mercado para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def close_partial_position(api_key: str, api_secret: str, symbol: str, qty_to_close: float, side: str, position_idx: int) -> dict:
    """Fecha parte de uma posiÃ§Ã£o com Market/ReduceOnly.
    - Detecta o lado REAL da posiÃ§Ã£o no exchange (nÃ£o confia no `side` recebido).
    - Aplica One-Way vs Hedge automaticamente (usa/omite positionIdx conforme o modo).
    - Em 110017 (reduceOnly mesmo lado) e 10001 (idx/mode), faz retry defensivo.
    """
    async def pre_flight_checks():
        if symbol not in INSTRUMENT_INFO_CACHE:
            await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            if not instrument_rules or not instrument_rules.get("success"):
                return instrument_rules or {"success": False, "error": f"Regras para {symbol} nÃ£o encontradas."}

            session = get_session(api_key, api_secret)

            # 0) Descobre a(s) posiÃ§Ã£o(Ãµes) atual(is) na corretora
            pos_resp = session.get_positions(category="linear", symbol=symbol)
            if pos_resp.get("retCode") != 0:
                return {"success": False, "error": pos_resp.get("retMsg", "Falha ao obter posiÃ§Ãµes atuais")}
            pos_items = (pos_resp.get("result", {}) or {}).get("list", []) or []
            pos_open = [p for p in pos_items if float(p.get("size") or 0) > 0]

            if not pos_open:
                logger.warning(f"[bybit_service] close_partial: nenhuma posiÃ§Ã£o aberta em {symbol}. Nada a fechar.")
                return {"success": True, "skipped": True, "reason": "no_open_position"}

            # Se houver mais de uma (hedge com ambos os lados), priorizamos a primeira com size>0.
            p0 = pos_open[0]
            pos_side_api = (p0.get("side") or "").strip()  # "Buy" (LONG) ou "Sell" (SHORT)
            pos_idx_api = int(p0.get("positionIdx") or 0)

            # 1) Lado correto de fechamento Ã© o CONTRÃRIO do lado da posiÃ§Ã£o
            close_side = "Sell" if pos_side_api == "Buy" else "Buy"

            # 2) Ajuste de quantidade ao step e checagens mÃ­nimas
            qty_raw = Decimal(str(qty_to_close))
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])
            logger.info(
                f"[bybit_service] close_partial {symbol}: raw={qty_raw}, "
                f"step={instrument_rules['qtyStep']}, minQty={instrument_rules['minOrderQty']} => adj={qty_adj}"
            )
            if qty_adj < instrument_rules["minOrderQty"]:
                logger.warning(f"Quantidade a fechar para {symbol} ({qty_adj:f}) < mÃ­nimo permitido. Ignorando.")
                return {"success": True, "skipped": True, "reason": "qty_less_than_min_order_qty"}

            # 3) Resolve modo e Ã­ndice de posiÃ§Ã£o
            #    - One-Way: omitir positionIdx
            #    - Hedge: usar idx do lado da POSIÃ‡ÃƒO (nÃ£o do lado da ordem)
            resolve = _resolve_position_index(session, symbol, close_side)
            mode = resolve.get("mode", "unknown")
            auto_idx = resolve.get("positionIdx", None)

            # Se hedge e o resolver nÃ£o retornou idx, usar o Ã­ndice da posiÃ§Ã£o real
            if mode == "hedge":
                if auto_idx is None:
                    if pos_idx_api in (1, 2):
                        auto_idx = pos_idx_api
                    else:
                        # fallback por mapeamento do lado da POSIÃ‡ÃƒO
                        auto_idx = 1 if pos_side_api == "Buy" else 2
            else:
                # one-way: nÃ£o enviar positionIdx
                auto_idx = None

            logger.info(
                f"[bybit_service] resolver: symbol={symbol}, mode={mode}, "
                f"pos_side_api={pos_side_api}, close_side={close_side}, "
                f"auto_idx={auto_idx}, pos_idx_api={pos_idx_api}, details={resolve.get('details')}"
            )

            # 4) Monta payload base
            payload = {
                "category": "linear",
                "symbol": symbol,
                "side": close_side,
                "orderType": "Market",
                "qty": str(qty_adj),
                "reduceOnly": True,
            }
            if auto_idx is not None:
                payload["positionIdx"] = auto_idx  # em hedge, vincula ao lado da posiÃ§Ã£o aberta

            def _try_place(p):
                _safe_log_order_payload("close_partial:first_try", p)
                return session.place_order(**p)

            # 5) Primeira tentativa
            try:
                response = _try_place(payload)
                if response.get('retCode') == 0:
                    return {"success": True, "data": response['result']}
                msg = response.get('retMsg', '') or ''
                # 110017: reduce-only com mesmo lado da posiÃ§Ã£o (corrida entre leitura e envio)
                if "reduce-only order has same side" in msg.lower() or "110017" in msg:
                    raise InvalidRequestError(msg)
                # 10001: idx/mode mismatch
                if "position idx not match" in msg.lower() or "10001" in msg:
                    raise InvalidRequestError(msg)
                return {"success": False, "error": msg}

            except InvalidRequestError as e:
                text = str(e).lower()
                alt_payload = dict(payload)
                alt_strategy = None

                if "reduce-only order has same side" in text or "110017" in text:
                    # Defensive: posiÃ§Ã£o pode ter virado entre leitura e envio â†’ inverter lado e ajustar idx
                    alt_payload["side"] = "Buy" if payload["side"] == "Sell" else "Sell"
                    if "positionIdx" in alt_payload:
                        # idx deve permanecer atrelado ao lado da POSIÃ‡ÃƒO alvo (flip de ordem nÃ£o muda qual posiÃ§Ã£o queremos reduzir)
                        # portanto, se flipou a ordem, manter o idx original (da posiÃ§Ã£o aberta)
                        alt_payload["positionIdx"] = payload.get("positionIdx", pos_idx_api or (1 if pos_side_api == "Buy" else 2))
                    alt_strategy = f"flip_side_{payload['side']}_to_{alt_payload['side']}"
                    logger.warning(f"[bybit_service] 110017 detectado para {symbol}. Retry: {alt_strategy}")

                elif "position idx not match" in text or "10001" in text:
                    # Alternar presenÃ§a do idx
                    if "positionIdx" in alt_payload:
                        alt_payload.pop("positionIdx", None)
                        alt_strategy = "remove_positionIdx"
                    else:
                        # em hedge, forÃ§ar idx coerente com a POSIÃ‡ÃƒO
                        alt_payload["positionIdx"] = pos_idx_api if pos_idx_api in (1, 2) else (1 if pos_side_api == "Buy" else 2)
                        alt_strategy = f"force_positionIdx_{alt_payload['positionIdx']}"
                    logger.warning(f"[bybit_service] 10001 detectado para {symbol}. Retry com '{alt_strategy}'.")

                else:
                    return {"success": False, "error": str(e)}

                try:
                    _safe_log_order_payload("close_partial:retry", alt_payload)
                    resp2 = session.place_order(**alt_payload)
                    if resp2.get('retCode') == 0:
                        logger.info(f"[bybit_service] retry sucesso para {symbol} com estratÃ©gia '{alt_strategy}'.")
                        return {
                            "success": True,
                            "data": resp2['result'],
                            "retry": True,
                            "retry_strategy": alt_strategy
                        }
                    return {
                        "success": False,
                        "error": resp2.get('retMsg', 'Falha no retry'),
                        "retry": True,
                        "retry_strategy": alt_strategy
                    }
                except InvalidRequestError as e2:
                    return {"success": False, "error": str(e2), "retry": True, "retry_strategy": alt_strategy}

        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao fechar posiÃ§Ã£o parcial: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"ExceÃ§Ã£o em close_partial_position (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}

async def modify_position_stop_loss(
    api_key: str,
    api_secret: str,
    symbol: str,
    new_stop_loss: float,
    reason: Optional[str] = None  # "be" | "ts" | "lock" | None
) -> dict:
    """
    Modifica o Stop Loss com:
      - Arredondamento no tick (down p/ LONG, up p/ SHORT)
      - Folga mÃ­nima de N ticks vs lastPrice (TF_SAFETY_TICKS, default 2)
      - Retry inteligente para retCode 10001: atÃ© 3 tentativas (0.2s, 0.4s, 0.8s + jitter)
    Trata "not modified" como sucesso.
    """
    try:
        # --- 1) Regras do instrumento (tickSize) ---
        instrument_rules = await get_instrument_info(symbol)
        if not instrument_rules.get("success"):
            error_msg = instrument_rules.get("error", f"Regras do instrumento {symbol} nÃ£o encontradas.")
            logger.error(f"Falha ao obter regras para {symbol} antes de modificar SL: {error_msg}")
            return {"success": False, "error": error_msg}

        tick_size = instrument_rules.get("tickSize", Decimal("0"))
        if tick_size <= 0:
            return {"success": False, "error": f"tickSize invÃ¡lido para {symbol}."}

        # --- 2) Safety ticks do ambiente (default 2) ---
        try:
            safety_ticks = int(os.getenv("TF_SAFETY_TICKS", "2"))
        except Exception:
            safety_ticks = 2
        if safety_ticks < 0:
            safety_ticks = 0

        desired_sl = Decimal(str(new_stop_loss))

        # --- 3) Tentativas com backoff ---
        backoffs = [0.0, 0.2, 0.4, 0.8]  # primeira sem espera
        last_error = None
        last_telemetry = {}

        for attempt, delay in enumerate(backoffs, start=1):
            if delay > 0:
                await asyncio.sleep(delay + random.uniform(0.0, 0.05))

            def _sync_attempt():
                try:
                    session = get_session(api_key, api_secret)

                    # 3.1 Descobre lado da posiÃ§Ã£o (Buy/Sell) p/ este sÃ­mbolo
                    pos_resp = session.get_positions(category="linear", symbol=symbol)
                    pos_list = (pos_resp.get("result", {}) or {}).get("list", []) or []
                    pos = next((p for p in pos_list if float(p.get("size") or 0) > 0), pos_list[0] if pos_list else None)
                    side_api = (pos.get("side") if pos else None) or "Buy"
                    side_norm = "LONG" if side_api == "Buy" else "SHORT"

                    # 3.2 Busca lastPrice mais recente
                    t = session.get_tickers(category="linear", symbol=symbol)
                    lst = (t.get("result", {}) or {}).get("list", [])
                    if not lst:
                        return {"ok": False, "error": "Ticker vazio.", "attempt": attempt}
                    last_price = Decimal(str(lst[0].get("lastPrice")))

                    # 3.3 Arredonda ao tick conforme lado
                    if side_norm == "LONG":
                        rounded = _round_down_to_tick(desired_sl, tick_size)
                    else:
                        rounded = _round_up_to_tick(desired_sl, tick_size)

                    # 3.4 Aplica folga mÃ­nima de N ticks vs lastPrice
                    adjusted = _apply_safety_ticks(side_norm, rounded, last_price, tick_size, safety_ticks)

                    logger.info(
                        "[sl:set] symbol=%s attempt=%d reason=%s side=%s original=%s rounded=%s last=%s ticks=%d adjusted=%s",
                        symbol, attempt, (reason or "n/a"), side_api, str(desired_sl), str(rounded), str(last_price), safety_ticks, str(adjusted)
                    )

                    # 3.5 Envia para a Bybit
                    payload = {"category": "linear", "symbol": symbol, "stopLoss": str(adjusted)}
                    resp = session.set_trading_stop(**payload)

                    if resp.get("retCode") == 0:
                        return {"ok": True, "data": resp.get("result"), "attempt": attempt}

                    # Falha: empacota info p/ decisÃ£o de retry fora da thread
                    return {
                        "ok": False,
                        "error": resp.get("retMsg"),
                        "retCode": resp.get("retCode"),
                        "attempt": attempt,
                        "telemetry": {
                            "last": str(last_price),
                            "desired": str(desired_sl),
                            "rounded": str(rounded),
                            "adjusted": str(adjusted),
                            "ticks": safety_ticks,
                            "side": side_api
                        }
                    }

                except InvalidRequestError as e:
                    msg = str(e)
                    # Bybit usa 10001 e mensagens â€œshould lower/higher than base_priceâ€
                    rc = 10001 if "10001" in msg else None
                    return {
                        "ok": False,
                        "error": msg,
                        "retCode": rc,
                        "attempt": attempt,
                    }
                except Exception as e:
                    logger.error("ExceÃ§Ã£o em modify_position_stop_loss (attempt=%d): %s", attempt, e, exc_info=True)
                    return {"ok": False, "error": str(e), "attempt": attempt}

            result = await asyncio.to_thread(_sync_attempt)

            # Sucesso?
            if result.get("ok"):
                return {"success": True, "data": result.get("data"), "attempt": result.get("attempt")}

            # Falha: decide se reintenta
            last_error = result.get("error")
            last_telemetry = result.get("telemetry", {})

            # Tratar "not modified" como sucesso silencioso
            if last_error and "not modified" in last_error.lower():
                logger.info("[sl:set] symbol=%s attempt=%d reason=%s already-in-place -> success",
                            symbol, result.get("attempt"), (reason or "n/a"))
                return {"success": True, "data": {"note": "not modified"}, "attempt": result.get("attempt")}

            # SÃ³ reintenta em 10001 / mensagens de base price
            retryable = False
            rc = result.get("retCode")
            if rc == 10001:
                retryable = True
            elif last_error:
                le = last_error.lower()
                if ("base price" in le) or ("should lower than base_price" in le) or ("should higher than base_price" in le):
                    retryable = True

            if retryable and attempt < len(backoffs):
                logger.warning("[sl:retry] symbol=%s attempt=%d reason=%s err=%s", symbol, result.get("attempt"), (reason or "n/a"), last_error)
                continue
            else:
                break  # nÃ£o-retryable ou esgotou tentativas

        # Esgotou tentativas / falha nÃ£o-retryable
        logger.error("[sl:failed] symbol=%s reason=%s err=%s telemetry=%s",
                     symbol, (reason or "n/a"), last_error, last_telemetry)
        return {"success": False, "error": last_error or "unknown error", "telemetry": last_telemetry}

    except Exception as e:
        logger.error(f"ExceÃ§Ã£o na lÃ³gica de modificar Stop Loss para {symbol}: {e}", exc_info=True)
        return {"success": False, "error": str(e)}

async def get_open_positions(api_key: str, api_secret: str) -> dict:
    return await get_open_positions_with_pnl(api_key, api_secret)

async def get_pnl_for_period(api_key: str, api_secret: str, start_time: datetime, end_time: datetime) -> dict:
    """Busca o P/L (Lucro/PrejuÃ­zo) realizado para um perÃ­odo de tempo especÃ­fico."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            
            start_timestamp_ms = int(start_time.timestamp() * 1000)
            end_timestamp_ms = int(end_time.timestamp() * 1000)

            response = session.get_closed_pnl(
                category="linear",
                startTime=start_timestamp_ms,
                endTime=end_timestamp_ms,
                limit=200 # Aumentar o limite para buscar mais trades em perÃ­odos longos
            )

            if response.get('retCode') == 0:
                pnl_list = response.get('result', {}).get('list', [])
                total_pnl = sum(float(item.get('closedPnl', 0)) for item in pnl_list)
                return {"success": True, "pnl": total_pnl}
            else:
                error_msg = response.get('retMsg', 'Erro desconhecido ao buscar P/L.')
                logger.error(f"Erro da API Bybit ao buscar P/L: {error_msg}")
                return {"success": False, "error": error_msg}

        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_pnl_for_period: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


async def get_daily_pnl(api_key: str, api_secret: str) -> dict:
    """Busca o P/L realizado para o dia atual (agora usa a funÃ§Ã£o genÃ©rica)."""
    today_start = datetime.combine(datetime.today(), time.min)
    now = datetime.now()
    return await get_pnl_for_period(api_key, api_secret, today_start, now)


# --- FUNÃ‡ÃƒO PARA ENVIAR ORDEM LIMITE ---
async def place_limit_order(api_key: str, api_secret: str, signal_data: dict, user_settings: User, balance: float) -> dict:
    """Envia uma nova ordem limite para a Bybit com validaÃ§Ã£o completa."""
    async def pre_flight_checks():
        symbol = signal_data['coin']
        if symbol not in INSTRUMENT_INFO_CACHE:
            await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            symbol = signal_data['coin']
            
            if not instrument_rules or not instrument_rules.get("success"):
                return instrument_rules or {"success": False, "error": f"Regras para {symbol} nÃ£o encontradas."}
            if instrument_rules["status"] != "Trading":
                return {"success": False, "error": f"O sÃ­mbolo {symbol} nÃ£o estÃ¡ ativo para negociaÃ§Ã£o ({instrument_rules['status']})."}

            session = get_session(api_key, api_secret)
            side = "Buy" if (signal_data.get('order_type') or '').upper() == 'LONG' else "Sell"
            leverage = Decimal(str(user_settings.max_leverage))
            tick = instrument_rules["tickSize"]

            price = Decimal(str(signal_data.get('limit_price')))
            price_adj = _round_down_to_tick(price, tick)

            margin_in_dollars = Decimal(str(balance)) * (Decimal(str(user_settings.entry_size_percent)) / Decimal("100"))
            notional_value = margin_in_dollars * leverage

            if price_adj <= 0:
                return {"success": False, "error": f"PreÃ§o de entrada invÃ¡lido apÃ³s ajuste: {price_adj}"}
            
            qty_raw = notional_value / price_adj
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])
            
            if qty_adj < instrument_rules["minOrderQty"]:
                return {"success": False, "error": f"Qtd. ajustada ({qty_adj:f}) Ã© menor que a mÃ­nima permitida ({instrument_rules['minOrderQty']:f}) para {symbol}."}
            final_notional_value = qty_adj * price_adj
            if final_notional_value < instrument_rules["minNotionalValue"]:
                return {"success": False, "error": f"Valor total da ordem (${final_notional_value:.2f}) Ã© menor que o mÃ­nimo permitido de ${instrument_rules['minNotionalValue']:.2f}."}

            # --- Ajuste de TP/SL ao tick do instrumento ---
            tp_raw = (signal_data.get('targets') or [None])[0]
            sl_raw = signal_data.get('stop_loss')

            take_profit_adj = None
            if tp_raw is not None:
                take_profit_adj = _round_down_to_tick(Decimal(str(tp_raw)), tick)

            stop_loss_adj = None
            if sl_raw is not None:
                stop_loss_adj = _round_down_to_tick(Decimal(str(sl_raw)), tick)

            payload = {
                "category": "linear", "symbol": symbol, "side": side,
                "orderType": "Limit", "qty": str(qty_adj), "price": str(price_adj),
                "takeProfit": str(take_profit_adj) if take_profit_adj is not None else None,
                "stopLoss": str(stop_loss_adj) if stop_loss_adj is not None else None,
            }

            try:
                session.set_leverage(category="linear", symbol=symbol, buyLeverage=str(leverage), sellLeverage=str(leverage))
            except InvalidRequestError as e:
                if "leverage not modified" in str(e).lower():
                    logger.warning(f"Alavancagem para {symbol} jÃ¡ estÃ¡ correta. Continuando...")
                else:
                    return {"success": False, "error": str(e)}

            _safe_log_order_payload("place_limit_order:first_try", payload)
            response = session.place_order(**{k: v for k, v in payload.items() if v is not None})
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            return {"success": False, "error": response.get('retMsg')}

        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao abrir ordem (Limit): {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"ExceÃ§Ã£o em place_limit_order (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}

# --- FUNÃ‡ÃƒO PARA VERIFICAR STATUS DE UMA ORDEM ---
async def get_order_status(api_key: str, api_secret: str, order_id: str, symbol: str) -> dict:
    """Verifica o status de uma ordem especÃ­fica na Bybit, procurando em ordens abertas."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            # --- CORREÃ‡ÃƒO: MUDAMOS PARA get_open_orders ---
            response = session.get_open_orders(
                category="linear",
                symbol=symbol,
                orderId=order_id,
            )
            if response.get('retCode') == 0:
                order_list = response.get('result', {}).get('list', [])
                if order_list:
                    # A ordem foi encontrada na lista de ordens abertas
                    return {"success": True, "data": order_list[0]}
                else:
                    # Se nÃ£o estÃ¡ nas ordens abertas, pode jÃ¡ ter sido executada ou cancelada.
                    # Por seguranÃ§a, vamos verificar o histÃ³rico tambÃ©m.
                    hist_response = session.get_order_history(category="linear", orderId=order_id)
                    if hist_response.get('retCode') == 0:
                        hist_list = hist_response.get('result', {}).get('list', [])
                        if hist_list:
                            return {"success": True, "data": hist_list[0]}
                    
                    return {"success": False, "error": "Ordem nÃ£o encontrada nem nas abertas nem no histÃ³rico."}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao verificar status da ordem: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)


# --- FUNÃ‡ÃƒO PARA CANCELAR UMA ORDEM ---
async def cancel_order(api_key: str, api_secret: str, order_id: str, symbol: str) -> dict:
    """Cancela uma ordem limite pendente na Bybit."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.cancel_order(
                category="linear",
                symbol=symbol,
                orderId=order_id
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o ao cancelar ordem: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

# --- PNL FECHADO (PERFORMANCE) ---
async def get_closed_pnl_breakdown(api_key: str, api_secret: str, start_time: datetime, end_time: datetime) -> dict:
    """
    Retorna o P/L total e contagem de ganhos/perdas no perÃ­odo informado.
    Usa o endpoint oficial de closed PnL e pagina os resultados se o perÃ­odo for > 7 dias.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)

            total_pnl = 0.0
            total_wins = 0
            total_losses = 0
            all_items = []

            current_start = start_time

            while current_start < end_time:
                # Calcula o fim da janela atual, limitado a 7 dias ou ao fim do perÃ­odo total
                current_end = min(current_start + timedelta(days=7), end_time)

                logger.info(f"[bybit_service] Buscando PnL de {current_start.strftime('%Y-%m-%d')} a {current_end.strftime('%Y-%m-%d')}")

                resp = session.get_closed_pnl(
                    category="linear",
                    startTime=int(current_start.timestamp() * 1000),
                    endTime=int(current_end.timestamp() * 1000),
                    limit=200,
                )

                if resp.get("retCode") != 0:
                    error_msg = resp.get("retMsg", f"Erro desconhecido na paginaÃ§Ã£o de PnL (start={current_start})")
                    logger.error(f"Erro da API Bybit em get_closed_pnl_breakdown: {error_msg}")
                    # Retorna o erro da primeira falha
                    return {"success": False, "error": error_msg}

                items = resp.get("result", {}).get("list", []) or []
                all_items.extend(items)

                # AvanÃ§a o inÃ­cio da prÃ³xima janela
                current_start += timedelta(days=7)

            # Processa a lista completa de itens coletados
            for it in all_items:
                pnl = float(it.get("closedPnl", 0) or 0)
                total_pnl += pnl
                if pnl > 0:
                    total_wins += 1
                elif pnl < 0:
                    total_losses += 1

            return {
                "success": True,
                "total_pnl": total_pnl,
                "wins": total_wins,
                "losses": total_losses,
                "trades": len(all_items),
            }
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_closed_pnl_breakdown: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


# --- POSIÃ‡Ã•ES ABERTAS COM PNL ATUAL ---
async def get_open_positions_with_pnl(api_key: str, api_secret: str) -> dict:
    """
    Lista posiÃ§Ãµes abertas com avgPrice, markPrice e P/L atual (valor e fraÃ§Ã£o),
    deduplicando por (symbol, side, positionIdx). Se houver duplicatas, mantÃ©m a de maior size.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            resp = session.get_positions(category="linear", settleCoin="USDT")
            if resp.get("retCode") != 0:
                return {"success": False, "error": resp.get("retMsg", "erro")}

            seen = {}  # key: (symbol, side, positionIdx) -> item
            positions = (resp.get("result", {}).get("list", []) or [])
            for pos in positions:
                size = float(pos.get("size", 0) or 0)
                if size <= 0:
                    continue

                symbol = pos.get("symbol")
                pos_side_api = (pos.get("side") or "").strip()  # "Buy" | "Sell"
                side = "LONG" if pos_side_api == "Buy" else "SHORT"
                entry = float(pos.get("avgPrice", 0) or 0)
                mark = float((pos.get("markPrice") or 0) or 0)
                pos_idx = int(pos.get("positionIdx", 0))
                key = (symbol, side, pos_idx)

                # Fallback de preÃ§o se mark vier 0
                if not mark and symbol:
                    try:
                        t = session.get_tickers(category="linear", symbol=symbol)
                        mark = float(t["result"]["list"][0]["lastPrice"])
                    except Exception:
                        pass

                if entry > 0 and mark > 0:
                    diff = (mark - entry) if side == "LONG" else (entry - mark)
                    pnl = diff * size
                    pnl_frac = (diff / entry) if entry else 0.0  # fraÃ§Ã£o (ex.: 0.015 = 1.5%)
                else:
                    pnl = 0.0
                    pnl_frac = 0.0

                item = {
                    "symbol": symbol,
                    "side": side,
                    "size": size,
                    "entry": entry,
                    "mark": mark,
                    "unrealized_pnl": pnl,
                    "unrealized_pnl_frac": pnl_frac,  # padronizado em FRAÃ‡ÃƒO
                    "position_idx": pos_idx,
                }

                if key in seen:
                    # mantÃ©m a maior posiÃ§Ã£o e loga para auditoria
                    if size > float(seen[key]["size"]):
                        logger.info(
                            "[positions:dedupe:replace] key=%s old_size=%.8f new_size=%.8f",
                            key, float(seen[key]["size"]), size
                        )
                        seen[key] = item
                    else:
                        logger.info(
                            "[positions:dedupe:skip] key=%s keep_size=%.8f skip_size=%.8f",
                            key, float(seen[key]["size"]), size
                        )
                else:
                    seen[key] = item

            out = list(seen.values())
            return {"success": True, "data": out}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_open_positions_with_pnl: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)

async def get_specific_position_size(api_key: str, api_secret: str, symbol: str) -> float:
    """
    Busca o tamanho (size) de uma posiÃ§Ã£o especÃ­fica aberta na Bybit.
    Retorna sempre um float (0.0 em caso de inexistÃªncia ou erro).
    """
    def _sync_call() -> float:
        try:
            session = get_session(api_key, api_secret)
            response = session.get_positions(category="linear", symbol=symbol)

            if response.get('retCode') == 0:
                position_list = (response.get('result', {}) or {}).get('list', []) or []
                if position_list and position_list[0]:
                    # Retorna o tamanho da primeira posiÃ§Ã£o na lista (mantÃ©m comportamento atual)
                    size_val = float(position_list[0].get('size', 0.0) or 0.0)
                    return size_val
                # Lista vazia: posiÃ§Ã£o nÃ£o existe
                return 0.0

            # retCode != 0: loga e retorna 0.0
            logger.warning(f"get_specific_position_size: Bybit retornou retCode={response.get('retCode')} para {symbol} - {response.get('retMsg')}")
            return 0.0

        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_specific_position_size para {symbol}: {e}", exc_info=True)
            # Nunca retorne None: padroniza para 0.0
            return 0.0

    return await asyncio.to_thread(_sync_call)

    
async def get_order_history(api_key: str, api_secret: str, order_id: str) -> dict:
    """Busca os detalhes de uma ordem especÃ­fica no histÃ³rico."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.get_order_history(category="linear", orderId=order_id, limit=1)
            
            if response.get('retCode') == 0:
                order_list = response.get('result', {}).get('list', [])
                if order_list:
                    return {"success": True, "data": order_list[0]}
                return {"success": False, "error": "Ordem nÃ£o encontrada no histÃ³rico."}
            return {"success": False, "error": response.get('retMsg')}
        
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_order_history: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)

async def modify_position_take_profit(api_key: str, api_secret: str, symbol: str, new_take_profit: float) -> dict:
    """Modifica o Take Profit de uma posiÃ§Ã£o aberta, garantindo a precisÃ£o do preÃ§o (tick size)."""
    try:
        # Busca regras/tick do instrumento (com cache)
        instrument_rules = await get_instrument_info(symbol)
        if not instrument_rules.get("success"):
            error_msg = instrument_rules.get("error", f"Regras do instrumento {symbol} nÃ£o encontradas.")
            logger.error(f"Falha ao obter regras para {symbol} antes de modificar TP: {error_msg}")
            return {"success": False, "error": error_msg}

        tick_size = instrument_rules.get("tickSize", Decimal("0"))
        tp_price_decimal = Decimal(str(new_take_profit))
        rounded_tp_price = _round_down_to_tick(tp_price_decimal, tick_size)

        logger.info(f"Modificando TP para {symbol}: Original: {tp_price_decimal}, Arredondado ({tick_size}): {rounded_tp_price}")

        def _sync_call():
            try:
                session = get_session(api_key, api_secret)
                payload = {"category": "linear", "symbol": symbol, "takeProfit": str(rounded_tp_price)}
                _safe_log_order_payload("modify_tp", payload)
                response = session.set_trading_stop(**payload)
                if response.get('retCode') == 0:
                    return {"success": True, "data": response['result']}
                return {"success": False, "error": response.get('retMsg')}
            except InvalidRequestError as e:
                if "not modified" in str(e).lower():
                    logger.info(f"TP para {symbol} jÃ¡ estÃ¡ em {rounded_tp_price}. Tratando como sucesso.")
                    return {"success": True, "data": {"note": "not modified"}}
                raise e

        return await asyncio.to_thread(_sync_call)

    except Exception as e:
        logger.error(f"ExceÃ§Ã£o na lÃ³gica de modificar Take Profit para {symbol}: {e}", exc_info=True)
        return {"success": False, "error": str(e)}

async def get_last_closed_trade_info(api_key: str, api_secret: str, symbol: str) -> dict:
    """
    FunÃ§Ã£o "Detetive" aprimorada: cruza dados de PnL e histÃ³rico de ordens
    para determinar com mais precisÃ£o o resultado de um trade que jÃ¡ fechou.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            end_time = datetime.now()
            start_time = end_time - timedelta(hours=2) # Aumenta a janela para 2h por seguranÃ§a
            
            # 1. Busca o PnL fechado mais recente para obter o PnL e o ID da ordem de fechamento
            pnl_response = session.get_closed_pnl(
                category="linear",
                symbol=symbol,
                startTime=int(start_time.timestamp() * 1000),
                endTime=int(end_time.timestamp() * 1000),
                limit=1
            )

            if pnl_response.get('retCode') != 0 or not pnl_response.get('result', {}).get('list'):
                return {"success": False, "error": "Nenhum PnL fechado encontrado para o sÃ­mbolo recentemente."}
            
            pnl_data = pnl_response['result']['list'][0]
            closing_order_id = pnl_data.get('orderId')
            
            # Prepara o resultado final com os dados do PnL
            final_data = {
                "closedPnl": pnl_data.get('closedPnl', 0.0),
                "exitType": "Unknown" # ComeÃ§a com 'Unknown' como fallback
            }

            if not closing_order_id:
                logger.warning(f"Detetive: PnL encontrado para {symbol}, mas sem orderId. Retornando 'Unknown'.")
                return {"success": True, "data": final_data}

            # 2. Busca os detalhes da ordem de fechamento para obter o motivo real
            order_hist_response = session.get_order_history(
                category="linear",
                orderId=closing_order_id
            )

            if order_hist_response.get('retCode') == 0 and order_hist_response.get('result', {}).get('list'):
                order_data = order_hist_response['result']['list'][0]
                stop_order_type = order_data.get('stopOrderType', '').strip()

                if stop_order_type == 'TakeProfit':
                    final_data['exitType'] = 'TakeProfit'
                elif stop_order_type == 'StopLoss':
                    final_data['exitType'] = 'StopLoss'
                # Outros tipos de ordens (como fechamento manual via ordem a mercado) nÃ£o terÃ£o stopOrderType.
                # Nesses casos, o fallback 'Unknown' serÃ¡ mantido, o que Ã© o comportamento esperado.
            
            return {"success": True, "data": final_data}

        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_last_closed_trade_info: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)

async def get_historical_klines(symbol: str, interval: str, limit: int = 200) -> dict:
    """
    Busca os dados histÃ³ricos de k-lines (candles) para um sÃ­mbolo.
    
    Args:
        symbol: O par de moedas (ex: 'BTCUSDT').
        interval: O tempo grÃ¡fico do candle ('60' para 1h, '240' para 4h, 'D' para diÃ¡rio).
        limit: O nÃºmero de candles a serem buscados (mÃ¡x 1000, padrÃ£o 200).

    Returns:
        Um dicionÃ¡rio com a lista de k-lines ou um erro.
        O formato dos dados Ã© uma lista de listas:
        [startTime, openPrice, highPrice, lowPrice, closePrice, volume, turnover]
    """
    def _sync_call():
        try:
            # Para dados pÃºblicos de mercado, nÃ£o Ã© necessÃ¡rio autenticar com chaves de API
            session = HTTP(testnet=False, timeout=15)
            response = session.get_kline(
                category="linear",
                symbol=symbol,
                interval=interval,
                limit=limit
            )
            
            if response.get('retCode') == 0 and response.get('result', {}).get('list'):
                kline_data = response['result']['list']
                # Os dados vÃªm com o candle mais recente no final, vamos inverter
                # para que o mais recente fique na primeira posiÃ§Ã£o.
                kline_data.reverse()
                return {"success": True, "data": kline_data}
            else:
                error_msg = response.get('retMsg', f"NÃ£o foi possÃ­vel obter os k-lines para {symbol}.")
                logger.warning(f"[bybit_service] Falha ao buscar k-lines para {symbol} (intervalo {interval}): {error_msg}")
                return {"success": False, "error": error_msg}
        except Exception as e:
            logger.error(f"ExceÃ§Ã£o em get_historical_klines para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)

def _safe_log_order_payload(context: str, payload: Dict[str, Any]) -> None:
    """
    Loga, de forma segura, os campos relevantes de um payload de ordem.
    NÃ£o loga credenciais nem headers. Apenas dados nÃ£o sensÃ­veis.
    """
    try:
        preview = {
            "category": payload.get("category"),
            "symbol": payload.get("symbol"),
            "side": payload.get("side"),
            "orderType": payload.get("orderType"),
            "qty": payload.get("qty"),
            "price": payload.get("price", "omitted"),
            "takeProfit": payload.get("takeProfit", "omitted"),
            "stopLoss": payload.get("stopLoss", "omitted"),
            "reduceOnly": payload.get("reduceOnly", False),
            "positionIdx": payload.get("positionIdx", "omitted"),
        }
        logger.info(f"[order_payload:{context}] {preview}")
    except Exception as e:
        logger.warning(f"[order_payload:{context}] falha ao logar preview: {e}")


========================================
# Arquivo: services/currency_service.py
========================================

import logging
import aiohttp
from typing import Optional

logger = logging.getLogger(__name__)

async def get_usd_to_brl_rate() -> Optional[float]:
    """
    Busca a taxa de conversÃ£o de USD para BRL de uma API pÃºblica.
    Retorna a taxa como float ou None em caso de falha.
    """
    # Usamos uma API simples e gratuita que nÃ£o requer chave.
    url = "https://api.exchangerate-api.com/v4/latest/USD"
    
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=5) as response:
                if response.status == 200:
                    data = await response.json()
                    rate = data.get("rates", {}).get("BRL")
                    if rate:
                        logger.info(f"Taxa de conversÃ£o USD-BRL obtida: {rate}")
                        return float(rate)
                    else:
                        logger.warning("Campo 'BRL' nÃ£o encontrado na resposta da API de cotaÃ§Ã£o.")
                        return None
                else:
                    logger.error(f"Falha ao buscar cotaÃ§Ã£o BRL. Status: {response.status}")
                    return None
    except Exception as e:
        logger.error(f"ExceÃ§Ã£o ao buscar cotaÃ§Ã£o BRL: {e}", exc_info=True)
        return None

========================================
# Arquivo: services/notification_service.py
========================================

import logging
from telegram.ext import Application
from utils.config import ADMIN_ID

logger = logging.getLogger(__name__)

async def send_notification(application: Application, message: str):
    """
    Envia uma mensagem de notificaÃ§Ã£o para o administrador do bot.
    """
    if not application:
        logger.warning("Tentativa de enviar notificaÃ§Ã£o sem a instÃ¢ncia da aplicaÃ§Ã£o.")
        return
    try:
        await application.bot.send_message(
            chat_id=ADMIN_ID,
            text=message,
            parse_mode='HTML'
        )
        logger.info(f"NotificaÃ§Ã£o enviada para o admin: {message[:50]}...")
    except Exception as e:
        logger.error(f"Falha ao enviar notificaÃ§Ã£o para o admin: {e}")

========================================
# Arquivo: services/signal_parser.py
========================================

import re
import logging
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)

# --- DEFINIÃ‡ÃƒO CENTRALIZADA DOS TIPOS DE SINAL ---
class SignalType:
    MARKET = 'MARKET'
    LIMIT = 'LIMIT'
    CANCELAR = 'CANCELAR'


# -----------------------
# Helpers de normalizaÃ§Ã£o
# -----------------------
_FLOAT = r'[-+]?\d+(?:[.,]\d+)?'

def _to_float(x: str) -> float:
    """Converte string com vÃ­rgula ou ponto para float."""
    if x is None:
        return 0.0
    x = x.strip().replace(' ', '').replace(',', '.')
    # remove percentuais e sÃ­mbolos residuais
    x = re.sub(r'[^0-9.+-]', '', x)
    try:
        return float(x)
    except Exception:
        return 0.0

def _normalize_symbol(coin_raw: str) -> str:
    coin = (coin_raw or '').strip().upper()
    # remove emojis e lixo
    coin = re.sub(r'[^A-Z0-9]', '', coin)
    # alguns sinais usam par completo (ex.: AVAXUSDT)
    if coin.endswith('USDT') or coin.endswith('USD'):
        return coin if coin.endswith('USDT') else f'{coin}T'  # USD -> USDT (fail-safe)
    return f'{coin}USDT' if coin else coin

def _pick_first_number(text: str) -> Optional[float]:
    m = re.search(_FLOAT, text)
    return _to_float(m.group(0)) if m else None

def _findall_numbers(text: str) -> List[float]:
    return [_to_float(g) for g in re.findall(_FLOAT, text or '')]


# ----------------------------------------------------
# PadrÃµes de alto nÃ­vel (ordem importa: especÃ­ficos 1Âº)
# ----------------------------------------------------
CANCEL_PATTERN = re.compile(r'âš ï¸\s*([A-Za-z0-9]+)[^\n]*sinal\s*cancelad[oa]', re.IGNORECASE)

# â€œOrdem Limiteâ€ / â€œOrdem a/Ã  Mercadoâ€ podem aparecer em qualquer lugar
IS_MARKET_PATTERN = re.compile(r'Ordem\s*(?:Ã |a)?\s*Mercado', re.IGNORECASE)
IS_LIMIT_PATTERN  = re.compile(r'Ordem\s*Limite', re.IGNORECASE)

# Verificador de â€œsinal completoâ€
FULL_SIGNAL_GUARD = re.compile(r'(?=.*(?:Moeda|Coin|Pair)\s*:)(?=.*Tipo\s*:)(?=.*Stop\s*Loss\s*:)', re.IGNORECASE | re.DOTALL)


# ---------------------------
# Extrator de sinal â€œcompletoâ€
# ---------------------------
def _full_signal_extractor(message_text: str) -> Optional[Dict[str, Any]]:

    def find_single_value(pattern: str, text: str) -> Optional[str]:
        # Usa .*? para pular emojis e rÃ³tulos adicionais na linha
        m = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
        return m.group(1).strip() if m else None

    # --- Campos bÃ¡sicos ---
    coin_raw = find_single_value(r'(?:Moeda|Coin|Pair)\s*:\s*([A-Za-z0-9 ._-]+)', message_text)
    order_type_raw = find_single_value(r'Tipo\s*:\s*([A-Za-z ]+)', message_text)
    entry_raw = find_single_value(r'Zona\s*de\s*Entrada\s*:\s*([^\n\r]+)', message_text)
    sl_raw = find_single_value(r'Stop\s*Loss\s*:\s*([^\n\r]+)', message_text)

    # targets: T1:, T2:, ...
    targets = []
    for tlabel, val in re.findall(r'(?:^|\n)\s*T(\d+)\s*:\s*([^\n\r]+)', message_text, flags=re.IGNORECASE):
        n = _pick_first_number(val)
        if n is not None:
            targets.append(n)

    # confianÃ§a (se existir)
    conf_raw = find_single_value(r'Confian[Ã§c]a\s*:\s*([0-9.,]+)\s*%', message_text)
    confidence = _to_float(conf_raw) if conf_raw else None

    # normalizaÃ§Ãµes
    coin = _normalize_symbol(coin_raw or '')
    order_type = 'LONG'
    if order_type_raw:
        if 'SHORT' in order_type_raw.upper():
            order_type = 'SHORT'
        elif 'LONG' in order_type_raw.upper():
            order_type = 'LONG'

    # entradas
    entries: List[float] = []
    if entry_raw:
        nums = _findall_numbers(entry_raw)
        # muitos sinais colocam "x - y"; se sÃ³ tem um nÃºmero, trata como lista Ãºnica
        if len(nums) == 1:
            entries = [nums[0]]
        elif len(nums) >= 2:
            entries = [nums[0], nums[1]]
        else:
            entries = []

    # stop
    stop_loss = _pick_first_number(sl_raw or '') or 0.0

    # --- DeterminaÃ§Ã£o do tipo (MARKET x LIMIT) ---
    # 1) texto explÃ­cito
    is_market_text = bool(IS_MARKET_PATTERN.search(message_text))
    is_limit_text  = bool(IS_LIMIT_PATTERN.search(message_text))

    # 2) heurÃ­stica: â€œentrada Ãºnicaâ€ OU faixa idÃªntica => MARKET
    entries_imply_market = False
    if entries:
        if len(entries) == 1:
            entries_imply_market = True
        elif len(entries) >= 2 and abs(entries[0] - entries[1]) < 1e-10:
            entries_imply_market = True

    # decisÃ£o final
    if is_market_text or (not is_limit_text and entries_imply_market):
        signal_kind = SignalType.MARKET
        # para MARKET garantimos entries[0] preenchida (usa o primeiro nÃºmero visto no bloco de entrada)
        if not entries and entry_raw:
            n = _pick_first_number(entry_raw)
            entries = [n] if n is not None else []
    else:
        signal_kind = SignalType.LIMIT

    if not coin or not entries or stop_loss == 0.0:
        logger.debug("Parser: campos essenciais ausentes: coin=%s entries=%s stop=%s", coin, entries, stop_loss)
        return None

    return {
        "type": signal_kind,
        "coin": coin,
        "order_type": order_type,          # LONG | SHORT
        "entries": entries,                # [preÃ§o] ou [min, max]
        "stop_loss": stop_loss,
        "targets": targets,                # [t1, t2, ...]
        "confidence": confidence,          # opcional (float ou None)
    }


# -----------------
# FunÃ§Ã£o de entrada
# -----------------
def parse_signal(message_text: str) -> Optional[Dict[str, Any]]:
    """
    Identifica e extrai sinais:
      - CANCELAMENTO: 'âš ï¸ <COIN> ... sinal cancelad(o/a)'
      - ENTRADA COMPLETA: campos Moeda/Coin/Pair, Tipo, Stop Loss (com 'Ordem Limite' ou 'Ordem Ã  Mercado')
    Retorna um dicionÃ¡rio com os campos normalizados ou None se nÃ£o reconhecer.
    """
    if not message_text or not isinstance(message_text, str):
        return None

    text = message_text.strip()

    # 1) Cancelamento
    m_cancel = CANCEL_PATTERN.search(text)
    if m_cancel:
        coin = _normalize_symbol(m_cancel.group(1))
        return {"type": SignalType.CANCELAR, "coin": coin}

    # 2) Sinal de entrada (guarda)
    if not FULL_SIGNAL_GUARD.search(text):
        return None

    data = _full_signal_extractor(text)
    return data

========================================
# Arquivo: services/telethon_service.py
========================================

import logging
import asyncio
import os
import re
from telegram.ext import Application
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telethon.sync import TelegramClient
from telethon import events
from telethon.errors.rpcerrorlist import ChannelForumMissingError, ChannelInvalidError
from telethon.tl.functions.channels import GetForumTopicsRequest
from utils.config import API_ID, API_HASH
from database.session import SessionLocal
from database.models import MonitoredTarget
from .signal_parser import parse_signal

logger = logging.getLogger(__name__)

# --- LÃ“GICA DE CAMINHO DINÃ‚MICO ---
if os.path.isdir('/data'):
    SESSION_PATH = '/data/tradeflow_user'
else:
    SESSION_PATH = 'tradeflow_user'

# --- DEFINIÃ‡ÃƒO ÃšNICA E CORRETA DO CLIENTE ---
client = TelegramClient(SESSION_PATH, API_ID, API_HASH)
comm_queue = None
# Cache em memÃ³ria para armazenar os IDs das mensagens jÃ¡ processadas e evitar duplicidade.
PROCESSED_MESSAGE_IDS = set()


# --- FunÃ§Ãµes de Busca (Helpers) ---

def get_monitored_targets():
    """Busca no DB a lista de todos os alvos (canal/tÃ³pico) monitorados."""
    db = SessionLocal()
    try:
        return db.query(MonitoredTarget).all()
    finally:
        db.close()

async def list_channels():
    """Lista todos os canais e supergrupos com logging detalhado."""
    logger.info("[list_channels] Iniciando busca de diÃ¡logos...")
    channels = []
    count = 0
    try:
        async for dialog in client.iter_dialogs():
            count += 1
            if count % 50 == 0:
                logger.info(f"[list_channels] ... processou {count} diÃ¡logos...")
            
            if dialog.is_channel:
                channels.append((dialog.name, dialog.id))
        
        logger.info(f"[list_channels] Busca de diÃ¡logos finalizada. Total de {count} diÃ¡logos processados.")
    except Exception as e:
        logger.error(f"[list_channels] Erro durante iter_dialogs: {e}", exc_info=True)
        
    return channels

async def list_channel_topics(channel_id: int):
    """Busca os tÃ³picos de um canal especÃ­fico."""
    topics = []
    try:
        entity = await client.get_entity(channel_id)
        result = await client(GetForumTopicsRequest(
            channel=entity, offset_date=0, offset_id=0, offset_topic=0, limit=100
        ))
        for topic in result.topics:
            topics.append((topic.title, topic.id))
            
    except (ChannelForumMissingError, ChannelInvalidError):
        logger.warning(f"Canal {channel_id} nÃ£o possui tÃ³picos (nÃ£o Ã© um fÃ³rum).")
        
    except Exception as e:
        logger.error(f"ExceÃ§Ã£o em list_channel_topics para o canal {channel_id}: {e}", exc_info=True)
        
    return topics

# --- Listener de Sinais ---
# Em vez de filtrar por regex no decorator, ouvimos TUDO e deixamos o parser decidir.
from telethon import events

@client.on(events.NewMessage)
@client.on(events.MessageEdited)
async def signal_listener(event):
    """
    Ouve TODAS as mensagens e processa APENAS as dos alvos monitorados.
    """
    global comm_queue
    if not comm_queue: return

    chat_id = getattr(event, "chat_id", None)
    message_id = getattr(getattr(event, "message", None), "id", None)
    topic_id = event.reply_to.reply_to_msg_id if getattr(event, "reply_to", None) else None
    text = (getattr(event, "raw_text", None) or getattr(getattr(event, "message", None), "message", None) or "")

    # 1. Primeiro, verifica se a mensagem Ã© de um alvo monitorado
    monitored_targets = get_monitored_targets()
    is_target = any(
        (t.channel_id == chat_id and ((t.topic_id is None and topic_id is None) or t.topic_id == topic_id))
        for t in monitored_targets
    )

    # 2. Se nÃ£o for um alvo, a funÃ§Ã£o termina silenciosamente.
    if not is_target:
        return

    # --- LÃ“GICA DE LOG MOVIDA PARA CÃ ---
    # 3. Agora que sabemos que a mensagem Ã© importante, nÃ³s a registramos.
    preview = text.replace("\n", " ")[:120]
    logger.info(f"ğŸ“¨ [Telethon] Mensagem RELEVANTE recebida | chat_id={chat_id} | msg_id={message_id} | preview={preview!r}")

    # O resto da lÃ³gica para evitar duplicidade e processar o sinal continua a mesma...
    if message_id in PROCESSED_MESSAGE_IDS:
        logger.info(f"â­ï¸ [Telethon] Mensagem {message_id} jÃ¡ processada. Ignorando.")
        return

    from services.signal_parser import parse_signal
    parsed = parse_signal(text)

    if parsed:
        logger.info(
            "âœ… [Telethon] Ã‰ sinal! "
            f"type={parsed.get('type')} coin={parsed.get('coin')} "
            f"order={parsed.get('order_type')} entries={parsed.get('entries')} sl={parsed.get('stop_loss')}"
        )
        if message_id is not None:
            PROCESSED_MESSAGE_IDS.add(message_id)

        await comm_queue.put({
            "action": "process_signal",
            "signal_text": text,
            "source_name": f"telegram:{chat_id}"
        })

# --- Processador da Fila ---

async def queue_processor(queue: asyncio.Queue, ptb_app: Application):
    """Processa pedidos da fila, agora passando o 'source_name' adiante."""
    global comm_queue
    comm_queue = queue
    from core.trade_manager import process_new_signal

    while True:
        request = await queue.get()
        action = request.get("action")
        logger.info(f"[Queue Processor] ==> Pedido recebido! AÃ§Ã£o: '{action}'")
        
        try:
            if action == "list_channels":
                logger.info("[Queue Processor] ... Entrou no bloco de 'list_channels'.")
                chat_id = request.get("chat_id")
                message_id = request.get("message_id")
                channels = await list_channels()
                db = SessionLocal()
                monitored_channels_ids = {target.channel_id for target in db.query(MonitoredTarget).all()}
                db.close()
                keyboard = []
                
                if channels:
                    for channel_name, channel_id in channels:
                        suffix = " âœ…" if channel_id in monitored_channels_ids else ""
                        keyboard.append([InlineKeyboardButton(f"{channel_name}{suffix}", callback_data=f"monitor_channel_{channel_id}")])
                
                if keyboard:
                    await ptb_app.bot.edit_message_text(
                        chat_id=chat_id, message_id=message_id,
                        text="Selecione um grupo/canal (âœ… = algum monitoramento ativo):",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    await ptb_app.bot.edit_message_text(chat_id=chat_id, message_id=message_id, text="Nenhum canal ou supergrupo encontrado.")

            elif action == "list_topics":
                logger.info("[Queue Processor] ... Entrou no bloco de 'list_topics'.")
                channel_id = request.get("channel_id")
                chat_id = request.get("chat_id")
                message_id = request.get("message_id")
                channel_name = request.get("channel_name")
                
                topics = await list_channel_topics(channel_id)
                db = SessionLocal()
                
                try:
                    if topics:
                        monitored_topic_ids = {t.topic_id for t in db.query(MonitoredTarget).filter_by(channel_id=channel_id).all() if t.topic_id}
                        keyboard = [[InlineKeyboardButton("â¬…ï¸ Voltar para Grupos", callback_data="admin_list_channels")]]
                        for name, topic_id in topics:
                            suffix = " âœ…" if topic_id in monitored_topic_ids else ""
                            keyboard.append([InlineKeyboardButton(f"{name}{suffix}", callback_data=f"monitor_topic_{channel_id}_{topic_id}")])
                        
                        await ptb_app.bot.edit_message_text(
                            chat_id=chat_id, message_id=message_id,
                            text="Selecione o tÃ³pico para monitorar (âœ… = jÃ¡ monitorado):",
                            reply_markup=InlineKeyboardMarkup(keyboard)
                        )
                    else:
                        existing = db.query(MonitoredTarget).filter_by(channel_id=channel_id, topic_id=None).first()
                        if existing:
                            db.delete(existing)
                            feedback_msg = f"âŒ Canal '{channel_name}' removido da lista de monitoramento."
                        else:
                            new_target = MonitoredTarget(channel_id=channel_id, channel_name=channel_name)
                            db.add(new_target)
                            feedback_msg = f"âœ… Canal '{channel_name}' adicionado Ã  lista de monitoramento."
                        
                        db.commit()
                        await ptb_app.bot.edit_message_text(chat_id=chat_id, message_id=message_id, text=feedback_msg)
                finally:
                    db.close()

            elif action == "process_signal":
                logger.info("[Queue Processor] ... Entrou no bloco de 'process_signal'.")
                signal_text = request.get("signal_text")
                source_name = request.get("source_name", "Fonte Desconhecida")
                
                signal_data = parse_signal(signal_text)
                if signal_data:
                    await process_new_signal(signal_data, ptb_app, source_name)
                else:
                    logger.info("Mensagem da fila nÃ£o Ã© um sinal vÃ¡lido.")
            
            else:
                logger.warning(f"[Queue Processor] AÃ§Ã£o desconhecida ou nula recebida: '{action}'")

        except Exception as e:
            logger.error(f"Erro CRÃTICO no processador da fila ao manusear a aÃ§Ã£o '{action}': {e}", exc_info=True)
        finally:
            queue.task_done()
            logger.info(f"[Queue Processor] <== Pedido '{action}' finalizado.")

# --- FunÃ§Ã£o Principal do ServiÃ§o ---

async def start_signal_monitor(queue: asyncio.Queue):
    """Inicia o cliente Telethon, o ouvinte de sinais e o processador da fila."""
    logger.info("Iniciando monitor de sinais com Telethon...")
    
    await client.start()
    
    ptb_app = await queue.get()

    logger.info("âœ… Monitor de sinais e processador de fila ativos.")
    
    asyncio.create_task(queue_processor(queue, ptb_app))
    
    await client.run_until_disconnected()

