========================================
# Arquivo: Dockerfile
========================================

# Usa uma imagem oficial do Python como base
FROM python:3.11-slim

# Define o diret√≥rio de trabalho dentro do container
WORKDIR /app

# Copia o arquivo de depend√™ncias primeiro
COPY requirements.txt .

# Instala as depend√™ncias do Python
RUN pip install --no-cache-dir -r requirements.txt

# Copia todo o resto do c√≥digo do projeto
COPY . .

# Comando que ser√° executado quando o container iniciar, usando o script simplificado
CMD ["./start.sh"]

========================================
# Arquivo: main.py
========================================

import logging
import asyncio
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, 
    ConversationHandler, CallbackQueryHandler
)
from utils.config import TELEGRAM_TOKEN
from bot.handlers import (
    start, receive_invite_code, cancel, WAITING_CODE,
    config_api, receive_api_key, receive_api_secret, WAITING_API_KEY, WAITING_API_SECRET,
    remove_api_prompt, remove_api_action, CONFIRM_REMOVE_API,
    my_positions_handler, user_dashboard_handler, user_settings_handler,
    back_to_main_menu_handler,
    ask_entry_percent, receive_entry_percent, ASKING_ENTRY_PERCENT,
    ask_max_leverage, receive_max_leverage, ASKING_MAX_LEVERAGE,
    ask_min_confidence, receive_min_confidence, ASKING_MIN_CONFIDENCE,
    admin_menu, list_channels_handler, select_channel_to_monitor, select_topic_to_monitor,
    manual_close_handler, admin_view_targets_handler, back_to_admin_menu_handler,
    bot_config_handler, toggle_approval_mode_handler, handle_signal_approval, 
    ask_profit_target, receive_profit_target, ASKING_PROFIT_TARGET,
    ask_loss_limit, receive_loss_limit, ASKING_LOSS_LIMIT, 
    ask_coin_whitelist, receive_coin_whitelist, ASKING_COIN_WHITELIST,
    performance_menu_handler
)
from database.session import init_db
from services.telethon_service import start_signal_monitor
from core.position_tracker import run_tracker

# --- Configura√ß√£o do Logging ---
logging.basicConfig(
    format="%(asctime)s - [%(levelname)s] - %(name)s - %(message)s",
    level=logging.INFO
)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("telegram").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)

async def run_ptb(application: Application, queue: asyncio.Queue):
    """Inicializa e roda a aplica√ß√£o python-telegram-bot."""
    application.bot_data['comm_queue'] = queue
    logger.info("Inicializando o bot do Telegram (PTB)...")
    await application.initialize()
    await application.start()
    await application.updater.start_polling()
    logger.info("‚úÖ Bot do Telegram (PTB) ativo.")

async def main():
    """Configura os handlers e inicia o PTB e o Telethon em paralelo."""
    init_db()
    comm_queue = asyncio.Queue()
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    await comm_queue.put(application)

    # --- Handlers de Conversa ---
    register_conv = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={ WAITING_CODE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_invite_code)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    api_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(config_api, pattern='^config_api$')],
        states={
            WAITING_API_KEY: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_api_key)],
            WAITING_API_SECRET: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_api_secret)],
        },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    remove_api_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(remove_api_prompt, pattern='^remove_api_prompt$')],
        states={ CONFIRM_REMOVE_API: [CallbackQueryHandler(remove_api_action, pattern='^remove_api_confirm|remove_api_cancel$')] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    settings_entry_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_entry_percent, pattern='^set_entry_percent$')],
        states={ ASKING_ENTRY_PERCENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_entry_percent)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    settings_leverage_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_max_leverage, pattern='^set_max_leverage$')],
        states={ ASKING_MAX_LEVERAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_max_leverage)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    settings_confidence_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_min_confidence, pattern='^set_min_confidence$')],
        states={ ASKING_MIN_CONFIDENCE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_min_confidence)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    profit_target_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_profit_target, pattern='^set_profit_target$')],
        states={ ASKING_PROFIT_TARGET: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_profit_target)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    loss_limit_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_loss_limit, pattern='^set_loss_limit$')],
        states={ ASKING_LOSS_LIMIT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_loss_limit)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    whitelist_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_coin_whitelist, pattern='^set_coin_whitelist$')],
        states={ ASKING_COIN_WHITELIST: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_coin_whitelist)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )

    # Adicionando todos os handlers
    application.add_handler(register_conv)
    application.add_handler(api_conv)
    application.add_handler(remove_api_conv)
    application.add_handler(settings_entry_conv)
    application.add_handler(settings_leverage_conv)
    application.add_handler(settings_confidence_conv)
    application.add_handler(profit_target_conv)
    application.add_handler(loss_limit_conv)
    application.add_handler(whitelist_conv)
    
    application.add_handler(CommandHandler("admin", admin_menu))
    application.add_handler(CallbackQueryHandler(list_channels_handler, pattern='^admin_list_channels$'))
    application.add_handler(CallbackQueryHandler(select_channel_to_monitor, pattern='^monitor_channel_'))
    application.add_handler(CallbackQueryHandler(select_topic_to_monitor, pattern='^monitor_topic_'))
    application.add_handler(CallbackQueryHandler(admin_view_targets_handler, pattern='^admin_view_targets$'))
    application.add_handler(CallbackQueryHandler(back_to_admin_menu_handler, pattern='^back_to_admin_menu$'))

    application.add_handler(CommandHandler("start", start))
    
    application.add_handler(CallbackQueryHandler(my_positions_handler, pattern='^user_positions$'))
    application.add_handler(CallbackQueryHandler(user_settings_handler, pattern='^user_settings$'))
    application.add_handler(CallbackQueryHandler(user_dashboard_handler, pattern='^user_dashboard$'))
    application.add_handler(CallbackQueryHandler(back_to_main_menu_handler, pattern='^back_to_main_menu$'))
    application.add_handler(CallbackQueryHandler(manual_close_handler, pattern='^manual_close_'))

    application.add_handler(CallbackQueryHandler(performance_menu_handler, pattern='^perf_'))

    application.add_handler(CallbackQueryHandler(bot_config_handler, pattern='^bot_config$'))
    application.add_handler(CallbackQueryHandler(toggle_approval_mode_handler, pattern='^toggle_approval_mode$'))

    application.add_handler(CallbackQueryHandler(handle_signal_approval, pattern=r'^(approve_signal_|reject_signal_)'))


    logger.info("Bot configurado. Iniciando todos os servi√ßos...")

    await asyncio.gather(
        run_ptb(application, comm_queue),
        start_signal_monitor(comm_queue),
        run_tracker(application)
    )

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Bot desligado pelo usu√°rio.")
    except Exception as e:
        logger.critical(f"Erro cr√≠tico n√£o tratado: {e}", exc_info=True)

========================================
# Arquivo: start.sh
========================================

#!/bin/sh

echo "Aplicando migra√ß√µes do banco de dados..."
# Este comando garante que o DB esteja sempre na vers√£o mais recente
alembic upgrade head

echo "Iniciando o bot TradeFlow..."
python main.py

========================================
# Arquivo: database/__init__.py
========================================



========================================
# Arquivo: database/crud.py
========================================

from .session import SessionLocal
from .models import User

def get_user_by_id(telegram_id: int):
    """Busca um usu√°rio no banco de dados pelo seu ID do Telegram."""
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == telegram_id).first()
        return user
    finally:
        db.close()

========================================
# Arquivo: database/models.py
========================================

from sqlalchemy import (Column, Integer, String, BigInteger, Boolean, Float, JSON, DateTime, UniqueConstraint)
from sqlalchemy.orm import declarative_base
from sqlalchemy.sql import func

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)
    first_name = Column(String)
    api_key_encrypted = Column(String)
    api_secret_encrypted = Column(String)
    entry_size_percent = Column(Float, default=5.0)
    max_leverage = Column(Integer, default=10)
    min_confidence = Column(Float, default=0.0)
    approval_mode = Column(String, default='AUTOMATIC', nullable=False)
    daily_profit_target = Column(Float, default=0.0, nullable=False)
    daily_loss_limit = Column(Float, default=0.0, nullable=False)
    # ADICIONE A LINHA ABAIXO
    coin_whitelist = Column(String, default='todas', nullable=False)

class InviteCode(Base):
    __tablename__ = 'invite_codes'
    id = Column(Integer, primary_key=True)
    code = Column(String, unique=True, nullable=False)
    is_used = Column(Boolean, default=False)

class MonitoredTarget(Base):
    __tablename__ = 'monitored_targets'
    id = Column(Integer, primary_key=True)
    channel_id = Column(BigInteger, nullable=False)
    channel_name = Column(String)
    topic_id = Column(BigInteger, unique=True, nullable=True)
    topic_name = Column(String)

class Trade(Base):
    __tablename__ = 'trades'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False)
    order_id = Column(String, unique=True, nullable=False)
    symbol = Column(String, nullable=False)
    side = Column(String, nullable=False)
    qty = Column(Float, nullable=False)
    entry_price = Column(Float)
    stop_loss = Column(Float)
    current_stop_loss = Column(Float)
    initial_targets = Column(JSON)
    status = Column(String, default='ACTIVE')
    remaining_qty = Column(Float)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class PendingSignal(Base):
    __tablename__ = 'pending_signals'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False, index=True)
    
    # --- MUDAN√áA APLICADA AQUI ---
    # Removemos o unique=True do symbol
    symbol = Column(String, nullable=False, index=True) 
    
    order_id = Column(String, unique=True, nullable=False)
    signal_data = Column(JSON, nullable=False)

    # Adicionamos uma restri√ß√£o de unicidade composta
    __table_args__ = (UniqueConstraint('user_telegram_id', 'symbol', name='_user_symbol_uc'),)

class SignalForApproval(Base):
    __tablename__ = 'signals_for_approval'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False, index=True)
    symbol = Column(String, nullable=False)
    source_name = Column(String)
    signal_data = Column(JSON, nullable=False)
    approval_message_id = Column(BigInteger)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

========================================
# Arquivo: database/session.py
========================================

import os # Importa a biblioteca 'os'
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from .models import Base

# --- L√ìGICA DE CAMINHO DIN√ÇMICO ---
if os.path.isdir('/data'):
    # Caminho para o banco de dados no servidor Fly.io
    DATABASE_URL = "sqlite:////data/tradeflow.db"
else:
    # Caminho para o banco de dados local (no seu Mac)
    DATABASE_URL = "sqlite:///./tradeflow.db"

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def init_db():
    Base.metadata.create_all(bind=engine)

========================================
# Arquivo: core/__init__.py
========================================



========================================
# Arquivo: core/performance_service.py
========================================

# imports no topo
from services.bybit_service import get_closed_pnl_breakdown
from utils.security import decrypt_data
from database.session import SessionLocal
from database.models import Trade, User
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

async def generate_performance_report(user_id: int, start_dt: datetime, end_dt: datetime) -> str:
    """
    Gera relat√≥rio do per√≠odo usando o closed PnL da Bybit (fonte de verdade)
    e mostra contagem de ganhos/perdas e hit rate. Usa DB apenas como apoio.
    """
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if not user or not user.api_key_encrypted:
            return "Voc√™ precisa ter uma chave de API configurada para ver o desempenho financeiro."

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # dados oficiais da corretora
        br = await get_closed_pnl_breakdown(api_key, api_secret, start_dt, end_dt)
        if not br.get("success"):
            logger.error(f"get_closed_pnl_breakdown falhou: {br.get('error')}")
            return "N√£o foi poss√≠vel calcular seu desempenho agora."

        total = br["total_pnl"]
        wins = br["wins"]
        losses = br["losses"]
        trades = br["trades"]
        hit_rate = (wins / trades * 100.0) if trades else 0.0

        # (opcional) tamb√©m buscamos no DB s√≥ para exibir um ‚ÄúTotal de Trades‚Äù local, se quiser
        closed_trades_db = db.query(Trade).filter(
            Trade.user_telegram_id == user_id,
            Trade.status.like('%CLOSED%'),
            Trade.created_at >= start_dt,
            Trade.created_at <= end_dt
        ).count()

        lucro_str = f"üìà <b>Lucro:</b> ${total:.2f}" if total >= 0 else f"üìâ <b>Preju√≠zo:</b> ${abs(total):.2f}"

        msg = (
            f"<b>üìä Desempenho do Per√≠odo</b>\n"
            f"<i>De {start_dt:%d/%m/%Y} a {end_dt:%d/%m/%Y}</i>\n\n"
            f"{lucro_str}\n\n"
            f"üìä <b>Taxa de Acerto:</b> {hit_rate:.2f}%\n"
            f"üì¶ <b>Total de Trades:</b> {trades} "
            f"(local: {closed_trades_db})\n"
            f"  - Ganhos: {wins}\n"
            f"  - Perdas: {losses}\n"
        )
        return msg

    except Exception as e:
        logger.error(f"Erro ao gerar relat√≥rio de performance para {user_id}: {e}", exc_info=True)
        return "Ocorreu um erro ao gerar seu relat√≥rio."
    finally:
        db.close()


========================================
# Arquivo: core/position_tracker.py
========================================

import asyncio
import logging
from telegram.ext import Application
from sqlalchemy.orm import Session
from database.session import SessionLocal
from database.models import Trade, User, PendingSignal
from services.bybit_service import (
    get_market_price, close_partial_position,
    modify_position_stop_loss, get_order_status,
    get_specific_position_size # <-- ADICIONE ESTA LINHA
)
# Mantemos o send_notification se voc√™ usar em outros pontos (aqui focamos em mensagem individual)
from services.notification_service import send_notification
from utils.security import decrypt_data

logger = logging.getLogger(__name__)


async def check_pending_orders_for_user(application: Application, user: User, db: Session):
    """Verifica as ordens limite pendentes de UM usu√°rio espec√≠fico."""
    pending_orders = db.query(PendingSignal).filter_by(user_telegram_id=user.telegram_id).all()
    if not pending_orders:
        return

    logger.info(f"Rastreador: Verificando {len(pending_orders)} ordem(ns) pendente(s) para o usu√°rio {user.telegram_id}.")
    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)

    for order in pending_orders:
        status_result = await get_order_status(api_key, api_secret, order.order_id, order.symbol)
        if not status_result.get("success"):
            logger.error(
                f"Falha ao obter status da ordem {order.order_id} "
                f"para o usu√°rio {user.telegram_id}: {status_result.get('error')}"
            )
            continue

        order_data = status_result["data"] or {}
        order_status = (order_data.get("orderStatus") or "").strip()

        if order_status == 'Filled':
            logger.info(f"Ordem Limite {order.order_id} EXECUTADA para o usu√°rio {user.telegram_id}.")
            signal_data = order.signal_data or {}

            # Fallbacks robustos
            avg_price = order_data.get('avgPrice')
            if avg_price:
                entry_price = float(avg_price)
            else:
                # usa limit_price salvo no signal_data (trade_manager j√° injeta) ou a 1¬™ entry
                entry_price = float(signal_data.get('limit_price') or signal_data.get('entries', [0])[0])

            cum_exec_qty = float(order_data.get('cumExecQty', 0.0))
            if cum_exec_qty <= 0:
                # Seguran√ßa: se por algum motivo a exchange marcou Filled mas qty veio 0,
                # tratamos como cancelado para n√£o criar Trade inconsistente.
                logger.warning(
                    f"[tracker] Ordem {order.order_id} marcada como Filled, "
                    f"mas cumExecQty=0. Removendo ordem pendente sem criar Trade."
                )
                db.delete(order)
                await application.bot.send_message(
                    chat_id=user.telegram_id,
                    text=(
                        f"‚ÑπÔ∏è Sua ordem limite para <b>{order.symbol}</b> foi finalizada na corretora, "
                        f"mas sem execu√ß√£o reportada. Removida do monitoramento."
                    ),
                    parse_mode='HTML'
                )
                continue

            new_trade = Trade(
                user_telegram_id=order.user_telegram_id,
                order_id=order.order_id,
                symbol=signal_data.get('coin', order.symbol),
                side=signal_data.get('order_type'),
                qty=cum_exec_qty,
                entry_price=entry_price,
                stop_loss=signal_data.get('stop_loss'),
                current_stop_loss=signal_data.get('stop_loss'),
                initial_targets=signal_data.get('targets') or [],
                status='ACTIVE',
                remaining_qty=cum_exec_qty
            )
            db.add(new_trade)
            db.delete(order)
            await application.bot.send_message(
                chat_id=user.telegram_id,
                text=(
                    f"üìà <b>Ordem Limite Executada!</b>\n"
                    f"<b>Moeda:</b> {order.symbol}\n"
                    f"<b>Pre√ßo m√©dio:</b> {entry_price}"
                ),
                parse_mode='HTML'
            )

        elif order_status in {'Cancelled', 'Deactivated', 'Rejected'}:
            logger.info(f"Ordem Limite {order.order_id} do usu√°rio {user.telegram_id} foi '{order_status}'. Removendo.")
            db.delete(order)
            await application.bot.send_message(
                chat_id=user.telegram_id,
                text=(
                    f"‚ÑπÔ∏è Sua ordem limite para <b>{order.symbol}</b> foi "
                    f"'<b>{order_status}</b>' pela corretora e removida do monitoramento."
                ),
                parse_mode='HTML'
            )
        else:
            # Estados como 'New', 'PartiallyFilled', etc.: apenas seguir monitorando.
            logger.debug(
                f"[tracker] Ordem {order.order_id} estado='{order_status}' para {user.telegram_id}. "
                f"Seguir monitorando."
            )


async def check_active_trades_for_user(application: Application, user: User, db: Session):
    """Verifica e gerencia os trades ativos de UM usu√°rio espec√≠fico."""
    active_trades = db.query(Trade).filter(
        Trade.user_telegram_id == user.telegram_id,
        ~Trade.status.like('%CLOSED%')
    ).all()
    if not active_trades:
        return

    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)

    for trade in active_trades:
        live_position_size = await get_specific_position_size(api_key, api_secret, trade.symbol)
        if live_position_size <= 0:
            logger.info(f"[tracker] Posi√ß√£o fantasma detectada para {trade.symbol}. Marcando como fechada.")
            trade.status = 'CLOSED_GHOST'
            trade.remaining_qty = 0.0
            continue

        price_result = await get_market_price(trade.symbol)
        if not price_result.get("success"):
            continue

        current_price = price_result["price"]
        reached_tp = False

        # --- TAKE PROFIT ---
        if trade.initial_targets:
            next_target_price = trade.initial_targets[0]
            if (trade.side == 'LONG' and current_price >= next_target_price) or \
               (trade.side == 'SHORT' and current_price <= next_target_price):
                
                qty_to_close = live_position_size if len(trade.initial_targets) == 1 else (live_position_size / 2.0)
                close_result = await close_partial_position(api_key, api_secret, trade.symbol, qty_to_close, trade.side)

                if close_result.get("success") and not close_result.get("skipped"):
                    # --- NOVA L√ìGICA DE NOTIFICA√á√ÉO DE LUCRO ---
                    profit = (next_target_price - trade.entry_price) * qty_to_close if trade.side == 'LONG' else (trade.entry_price - next_target_price) * qty_to_close
                    
                    # Atualiza o trade no DB
                    trade.remaining_qty = live_position_size - qty_to_close
                    remaining_targets = trade.initial_targets[1:]
                    trade.initial_targets = remaining_targets
                    
                    message_text = ""
                    if not remaining_targets or trade.remaining_qty <= 0.00001:
                        trade.status = 'CLOSED_PROFIT'
                        message_text = (
                            f"üèÜ <b>√öltimo Alvo Atingido! (LUCRO)</b> üèÜ\n"
                            f"<b>Moeda:</b> {trade.symbol}\n"
                            f"<b>Lucro Realizado:</b> ${profit:,.2f}\n\n"
                            f"A posi√ß√£o foi completamente fechada."
                        )
                    else:
                        trade.status = 'ACTIVE_TP_HIT'
                        message_text = (
                            f"üí∞ <b>Take Profit Atingido! (LUCRO)</b>\n"
                            f"<b>Moeda:</b> {trade.symbol}\n"
                            f"<b>Lucro Parcial:</b> ${profit:,.2f}\n"
                            f"<b>Alvos Restantes:</b> {len(remaining_targets)}"
                        )
                    
                    await application.bot.send_message(chat_id=user.telegram_id, text=message_text, parse_mode='HTML')
                    reached_tp = True

        # --- STOP LOSS ---
        if not reached_tp:
            stop_hit = (
                (trade.side == 'LONG' and current_price <= trade.current_stop_loss) or
                (trade.side == 'SHORT' and current_price >= trade.current_stop_loss)
            )
            if stop_hit:
                # --- NOVA L√ìGICA DE NOTIFICA√á√ÉO DE PREJU√çZO ---
                loss = (trade.current_stop_loss - trade.entry_price) * live_position_size if trade.side == 'LONG' else (trade.entry_price - trade.current_stop_loss) * live_position_size
                
                trade.status = 'CLOSED_LOSS'
                trade.remaining_qty = 0.0

                message_text = (
                    f"üõë <b>Stop Loss Atingido (PREJU√çZO)</b>\n"
                    f"<b>Moeda:</b> {trade.symbol}\n"
                    f"<b>Preju√≠zo Realizado:</b> ${loss:,.2f}\n\n"
                    f"A posi√ß√£o foi completamente fechada."
                )
                await application.bot.send_message(chat_id=user.telegram_id, text=message_text, parse_mode='HTML')



async def run_tracker(application: Application):
    """Fun√ß√£o principal que roda o verificador em loop para TODOS os usu√°rios."""
    logger.info("Iniciando Rastreador de Posi√ß√µes e Ordens (Modo Multiusu√°rio)...")
    while True:
        db = SessionLocal()
        try:
            all_users = db.query(User).filter(User.api_key_encrypted.isnot(None)).all()
            if not all_users:
                logger.info("Rastreador: Nenhum usu√°rio com API para verificar.")
            else:
                logger.info(f"Rastreador: Verificando assets para {len(all_users)} usu√°rio(s).")
                for user in all_users:
                    await check_pending_orders_for_user(application, user, db)
                    await check_active_trades_for_user(application, user, db)

                # commit das modifica√ß√µes (Trades atualizados, remo√ß√£o de Pending, etc.)
                db.commit()

        except Exception as e:
            logger.critical(f"Erro cr√≠tico no loop do rastreador: {e}", exc_info=True)
            db.rollback()
        finally:
            db.close()

        await asyncio.sleep(60)


========================================
# Arquivo: core/trade_manager.py
========================================

import os
import logging
from typing import Tuple
from telegram.ext import Application
from sqlalchemy.orm import Session
from database.session import SessionLocal
from database.models import User, Trade, PendingSignal, SignalForApproval
from services.bybit_service import (
    place_order, get_account_info,
    place_limit_order, cancel_order
)
from services.notification_service import send_notification
from utils.security import decrypt_data
from utils.config import ADMIN_ID
from bot.keyboards import signal_approval_keyboard
from services.signal_parser import SignalType
from core.whitelist_service import is_coin_in_whitelist

logger = logging.getLogger(__name__)


def _avaliar_sinal(signal_data: dict, user_settings: User) -> Tuple[bool, str]:
    min_confidence = user_settings.min_confidence
    signal_confidence = signal_data.get('confidence', 0.0)
    if signal_confidence is not None and signal_confidence < min_confidence:
        motivo = f"Confian√ßa ({signal_confidence:.2f}%) √© menor que o seu m√≠nimo ({min_confidence:.2f}%)"
        return False, motivo
    return True, "Sinal aprovado pelos seus crit√©rios."

async def _execute_trade(signal_data: dict, user: User, application: Application, db: Session, source_name: str):
    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)
    
    account_info = await get_account_info(api_key, api_secret)
    if not account_info.get("success"):
        await application.bot.send_message(chat_id=user.telegram_id, text=f"‚ùå Falha ao buscar seu saldo Bybit para operar {signal_data['coin']}.")
        return

    balance_data = account_info.get("data", {})
    balance = float(balance_data.get('available_balance', 0))
    result = await place_order(api_key, api_secret, signal_data, user, balance)
    
    if result.get("success"):
        order_data = result['data']
        order_id = order_data['orderId']
        new_trade = Trade(
            user_telegram_id=user.telegram_id, order_id=order_id,
            symbol=signal_data['coin'], side=signal_data['order_type'],
            qty=float(order_data.get('qty', 0)), entry_price=signal_data['entries'][0],
            stop_loss=signal_data['stop_loss'], current_stop_loss=signal_data['stop_loss'],
            initial_targets=signal_data['targets'], status='ACTIVE',
            remaining_qty=float(order_data.get('qty', 0))
        )
        db.add(new_trade)
        logger.info(f"Trade {order_id} para o usu√°rio {user.telegram_id} salvo no DB.")
        await application.bot.send_message(chat_id=user.telegram_id, text=f"üìà <b>Ordem Aberta com Sucesso!</b>\n<b>Moeda:</b> {signal_data['coin']}", parse_mode='HTML')
    else:
        error_msg = result.get('error')
        await application.bot.send_message(chat_id=user.telegram_id, text=f"‚ùå <b>Falha ao Abrir Ordem</b>\n<b>Moeda:</b> {signal_data['coin']}\n<b>Motivo:</b> {error_msg}", parse_mode='HTML')


async def execute_signal_for_all_users(signal_data: dict, application: Application, db: Session, source_name: str):
    signal_type = signal_data.get("type")
    symbol = signal_data.get("coin")

    all_users_to_trade = db.query(User).filter(User.api_key_encrypted.isnot(None)).all()
    if not all_users_to_trade:
        logger.info("Nenhum usu√°rio com API configurada para replicar o trade.")
        return

    logger.info(f"Sinal ({signal_type}) aprovado. Replicando para {len(all_users_to_trade)} usu√°rio(s)...")

    for user in all_users_to_trade:
        if not is_coin_in_whitelist(symbol, user.coin_whitelist):
            logger.info(f"Sinal para {symbol} ignorado para o usu√°rio {user.telegram_id} devido √† sua whitelist ('{user.coin_whitelist}').")
            # Opcional: notificar o usu√°rio que o sinal foi ignorado
            # await application.bot.send_message(chat_id=user.telegram_id, text=f"‚ÑπÔ∏è Sinal para {symbol} ignorado devido √† sua whitelist.")
            continue # Pula para o pr√≥ximo usu√°rio
        if signal_type == SignalType.MARKET:
            await _execute_trade(signal_data, user, application, db, source_name)
        elif signal_type == SignalType.LIMIT:
            existing_pending = db.query(PendingSignal).filter_by(user_telegram_id=user.telegram_id, symbol=symbol).first()
            if existing_pending:
                await application.bot.send_message(
                    chat_id=user.telegram_id,
                    text=f"‚ÑπÔ∏è Voc√™ j√° tem uma ordem limite pendente para <b>{symbol}</b>. O novo sinal foi ignorado.",
                    parse_mode='HTML'
                )
                continue

            # ---- NOVO: escolher um √∫nico pre√ßo para a ordem limite ----
            entries = (signal_data.get('entries') or [])[:2]
            if not entries:
                await application.bot.send_message(
                    chat_id=user.telegram_id,
                    text=f"‚ùå Sinal LIMIT para <b>{symbol}</b> sem pre√ßos de entrada v√°lidos.",
                    parse_mode='HTML'
                )
                continue

            if len(entries) == 1:
                limit_price = float(entries[0])
            else:
                lo = float(min(entries[0], entries[1]))
                hi = float(max(entries[0], entries[1]))
                if (signal_data.get('order_type') or '').upper() == 'LONG':
                    limit_price = lo   # LONG -> comprar no mais baixo da faixa
                else:
                    limit_price = hi   # SHORT -> vender no mais alto da faixa

            # injeta no payload para a bybit_service
            signal_data_with_price = dict(signal_data)
            signal_data_with_price['limit_price'] = limit_price
            # -----------------------------------------------------------

            user_api_key = decrypt_data(user.api_key_encrypted)
            user_api_secret = decrypt_data(user.api_secret_encrypted)

            account_info = await get_account_info(user_api_key, user_api_secret)
            if not account_info.get("success"):
                await application.bot.send_message(
                    chat_id=user.telegram_id,
                    text=f"‚ùå Falha ao buscar seu saldo Bybit para posicionar LIMIT em <b>{symbol}</b>.",
                    parse_mode='HTML'
                )
                continue

            balance_data = account_info.get("data", {})
            balance = float(balance_data.get('available_balance', 0))

            # >>> IMPORTANTE: agora enviamos signal_data_with_price <<<
            limit_order_result = await place_limit_order(user_api_key, user_api_secret, signal_data_with_price, user, balance)

            if limit_order_result.get("success"):
                order_id = limit_order_result["data"]["orderId"]
                db.add(PendingSignal(
                    user_telegram_id=user.telegram_id,
                    symbol=symbol,
                    order_id=order_id,
                    signal_data=signal_data_with_price
                ))
                await application.bot.send_message(
                    chat_id=user.telegram_id,
                    text=(
                        f"‚úÖ Ordem <b>Limite</b> posicionada para <b>{symbol}</b> ({signal_data.get('order_type')}).\n"
                        f"üéØ Pre√ßo: <b>{limit_price}</b>\n"
                        f"üõë Stop: <b>{signal_data.get('stop_loss')}</b>\n"
                        f"üëÄ Monitorando a execu√ß√£o‚Ä¶"
                    ),
                    parse_mode='HTML'
                )
            else:
                error = limit_order_result.get('error') or limit_order_result
                await application.bot.send_message(
                    chat_id=user.telegram_id,
                    text=f"‚ùå Falha ao posicionar sua ordem limite para <b>{symbol}</b>.\n<b>Motivo:</b> {error}",
                    parse_mode='HTML'
                )
    db.commit()

async def process_new_signal(signal_data: dict, application: Application, source_name: str):
    """
    Processa apenas sinais de ENTRADA e CANCELAMENTO, ignorando todos os outros.
    """
    signal_type = signal_data.get("type")
    symbol = signal_data.get("coin")
    db = SessionLocal()
    try:
        # --- L√ìGICA DE CANCELAMENTO ---
        if signal_type == SignalType.CANCELAR:
            logger.info(f"Recebido sinal de cancelamento para {symbol}.")
            pending_orders = db.query(PendingSignal).filter_by(symbol=symbol).all()
            if not pending_orders:
                await send_notification(application, f"‚ÑπÔ∏è Recebido sinal de cancelamento para <b>{symbol}</b>, mas nenhuma ordem pendente foi encontrada.")
                return
            
            for order in pending_orders:
                user_keys = db.query(User).filter_by(telegram_id=order.user_telegram_id).first()
                if not user_keys: continue
                api_key = decrypt_data(user_keys.api_key_encrypted)
                api_secret = decrypt_data(user_keys.api_secret_encrypted)
                cancel_result = await cancel_order(api_key, api_secret, order.order_id, symbol)
                if cancel_result.get("success"):
                    await application.bot.send_message(chat_id=order.user_telegram_id, text=f"‚úÖ Sua ordem limite para <b>{symbol}</b> foi cancelada com sucesso.", parse_mode='HTML')
                    db.delete(order)
                else:
                    await application.bot.send_message(chat_id=order.user_telegram_id, text=f"‚ö†Ô∏è Falha ao cancelar sua ordem limite para <b>{symbol}</b>.", parse_mode='HTML')
            db.commit()
            return

        # --- L√ìGICA DE SINAIS DE ENTRADA ---
        elif signal_type in [SignalType.MARKET, SignalType.LIMIT]:
            admin_user = db.query(User).filter_by(telegram_id=ADMIN_ID).first()
            if not admin_user or not admin_user.api_key_encrypted:
                logger.error("Admin n√£o configurado, n√£o √© poss√≠vel processar sinais de entrada.")
                return

            aprovado, motivo = _avaliar_sinal(signal_data, admin_user)
            if not aprovado:
                await send_notification(application, f"‚ÑπÔ∏è Sinal para {symbol} ignorado pelo admin: {motivo}")
                return
            
            if admin_user.approval_mode == 'AUTOMATIC':
                await execute_signal_for_all_users(signal_data, application, db, source_name)
            
            elif admin_user.approval_mode == 'MANUAL':
                logger.info(f"Modo MANUAL. Enviando sinal ({signal_type}) de entrada para aprova√ß√£o do Admin.")
                
                new_signal_for_approval = SignalForApproval(
                    user_telegram_id=ADMIN_ID, symbol=symbol,
                    source_name=source_name, signal_data=signal_data
                )
                db.add(new_signal_for_approval)
                db.commit()

                signal_details = (
                    f"<b>Sinal ({signal_type}) de: {source_name}</b>\n\n<b>Moeda:</b> {signal_data['coin']}\n"
                    f"<b>Tipo:</b> {signal_data['order_type']}\n<b>Entrada:</b> {signal_data['entries'][0]}\n"
                    f"<b>Stop:</b> {signal_data['stop_loss']}\n<b>Alvo 1:</b> {signal_data['targets'][0]}\n\n"
                    f"O sinal passou nos seus filtros. Voc√™ aprova a entrada?"
                )
                sent_message = await application.bot.send_message(
                    chat_id=ADMIN_ID, text=signal_details, parse_mode='HTML',
                    reply_markup=signal_approval_keyboard(new_signal_for_approval.id)
                )
                new_signal_for_approval.approval_message_id = sent_message.message_id
                db.commit()
        else:
            logger.info(f"Sinal do tipo '{signal_type}' recebido e ignorado conforme a estrat√©gia de autonomia.")
            
    finally:
        db.close()

========================================
# Arquivo: core/whitelist_service.py
========================================

import logging
from typing import Set

logger = logging.getLogger(__name__)

# --- CATEGORIAS DE MOEDAS ---
# Estas listas podem ser expandidas no futuro. Usamos Sets para performance.

# Moedas de grande capitaliza√ß√£o e projetos estabelecidos (excluindo BTC e ETH)
ALTCOINS_L1_L2: Set[str] = {
    'SOLUSDT', 'XRPUSDT', 'ADAUSDT', 'AVAXUSDT', 'DOTUSDT', 'MATICUSDT',
    'LINKUSDT', 'TRXUSDT', 'ATOMUSDT', 'NEARUSDT', 'APTUSDT', 'OPUSDT',
    'ARBUSDT', 'LDOUSDT', 'SUIUSDT'
}

# Moedas relacionadas a Finan√ßas Descentralizadas
DEFI: Set[str] = {
    'UNIUSDT', 'AAVEUSDT', 'MKRUSDT', 'SNXUSDT', 'COMPUSDT', 'CRVUSDT',
    'SUSHIUSDT', 'YFIUSDT'
}

# Moedas de "memes" com alta volatilidade
MEMECOINS: Set[str] = {
    'DOGEUSDT', 'SHIBUSDT', 'PEPEUSDT', 'WIFUSDT', 'FLOKIUSDT', 'BONKUSDT'
}

# Dicion√°rio que mapeia a palavra-chave da categoria para o Set de moedas
CATEGORIES = {
    'altcoins': ALTCOINS_L1_L2,
    'defi': DEFI,
    'memecoins': MEMECOINS,
}

def is_coin_in_whitelist(symbol: str, user_whitelist_str: str) -> bool:
    """
    Verifica se um s√≠mbolo de moeda est√° na whitelist de um usu√°rio.

    A whitelist pode conter:
    - O keyword 'todas'.
    - S√≠mbolos espec√≠ficos (ex: 'btcusdt').
    - Keywords de categorias (ex: 'memecoins').
    """
    if not user_whitelist_str or 'todas' in user_whitelist_str.lower():
        return True

    # Normaliza a entrada do usu√°rio: min√∫sculas, remove espa√ßos, divide por v√≠rgula
    user_list = {item.strip() for item in user_whitelist_str.lower().split(',')}
    
    # 1. Verifica se o s√≠mbolo exato est√° na lista do usu√°rio
    if symbol.lower() in user_list:
        return True

    # 2. Verifica se alguma das categorias da lista do usu√°rio cont√©m o s√≠mbolo
    for category_keyword in user_list:
        if category_keyword in CATEGORIES and symbol in CATEGORIES[category_keyword]:
            return True
            
    # Se nenhuma das condi√ß√µes acima for atendida, a moeda n√£o est√° na whitelist
    return False

========================================
# Arquivo: tests/__init__.py
========================================



========================================
# Arquivo: tests/test_signal_cyber_e2e.py
========================================

# tests/test_signal_cyber_e2e.py
import sys
import types
import textwrap
import pytest

# ======== STUBS m√≠nimos (telegram e keyboards) ========
telegram = types.ModuleType("telegram")
telegram_ext = types.ModuleType("telegram.ext")
telegram_constants = types.ModuleType("telegram.constants")

class InlineKeyboardButton:
    def __init__(self, text, callback_data=None, url=None):
        self.text = text; self.callback_data = callback_data; self.url = url

class InlineKeyboardMarkup:
    def __init__(self, keyboard): self.keyboard = keyboard

class Application:
    def __init__(self): self.bot = None

telegram.InlineKeyboardButton = InlineKeyboardButton
telegram.InlineKeyboardMarkup = InlineKeyboardMarkup
telegram.constants = telegram_constants
telegram_ext.Application = Application

sys.modules.setdefault("telegram", telegram)
sys.modules.setdefault("telegram.ext", telegram_ext)
sys.modules.setdefault("telegram.constants", telegram_constants)

bot_pkg = types.ModuleType("bot")
bot_keyboards = types.ModuleType("bot.keyboards")
def signal_approval_keyboard(signal_id: int):
    return InlineKeyboardMarkup([[InlineKeyboardButton("Aprovar", callback_data=f"approve:{signal_id}")]])
bot_keyboards.signal_approval_keyboard = signal_approval_keyboard
sys.modules.setdefault("bot", bot_pkg)
sys.modules.setdefault("bot.keyboards", bot_keyboards)

# ======== Imports reais do projeto ========
from services.signal_parser import parse_signal, SignalType
import core.trade_manager as tm

# ======== Fakes utilit√°rios ========
class FakeUser:
    def __init__(self, telegram_id=111, api_key_encrypted="enc_k", api_secret_encrypted="enc_s"):
        self.telegram_id = telegram_id
        self.api_key_encrypted = api_key_encrypted
        self.api_secret_encrypted = api_secret_encrypted

class _QueryList:
    def __init__(self, data_list): self._data = data_list
    def filter(self, *a, **k): return self
    def filter_by(self, **k):
        def ok(obj): return all(getattr(obj, kk, None) == vv for kk, vv in k.items())
        return _QueryList([x for x in self._data if ok(x)])
    def all(self): return list(self._data)
    def first(self): return self._data[0] if self._data else None

class FakeDB:
    def __init__(self, users=None, pendings=None):
        self._users = users or []
        self._pendings = pendings or []
        self.added = []; self.deleted = []; self.commits = 0
    def query(self, Model):
        if Model is tm.User: return _QueryList(self._users)
        if Model is tm.PendingSignal: return _QueryList(self._pendings)
        return _QueryList([])
    def add(self, obj):
        self.added.append(obj)
        if isinstance(obj, tm.PendingSignal) or getattr(obj, "__class__", None).__name__ == "DummyPending":
            self._pendings.append(obj)
    def delete(self, obj):
        self.deleted.append(obj)
        if obj in self._pendings: self._pendings.remove(obj)
    def commit(self): self.commits += 1

class FakeBot:
    def __init__(self): self.sent = []
    async def send_message(self, **kwargs): self.sent.append(kwargs)

class FakeApplication(Application):
    def __init__(self): super().__init__(); self.bot = FakeBot()

# ======== Sinal CYBER (LIMIT/SHORT) ========
CYBER_SIGNAL = textwrap.dedent("""
‚è≥ #38792 - Ordem Limite

üíé Moeda: CYBER
üìä Tipo: SHORT (Futures)

üí∞ Zona de Entrada: 2.52500000 - 2.64000000
üõë Stop Loss: 2.90000000 (12.2943%)
üéØ Alvos:
T1: 2.44000000 (5.52%)
T2: 2.37000000 (8.23%)
T3: 2.29000000 (11.33%)
T4: 2.20000000 (14.81%)
""")

@pytest.mark.asyncio
async def test_cyber_limit_short_positions_limit_order(monkeypatch):
    parsed = parse_signal(CYBER_SIGNAL)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "SHORT"
    assert parsed["coin"] == "CYBERUSDT"
    assert parsed["entries"] == [2.525, 2.64]
    assert parsed["stop_loss"] == 2.9

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=777)])

    # dummy PendingSignal para n√£o depender de SQLAlchemy real
    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    # Capturas
    called = {"market": False, "limit_payload": None}

    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        # guardamos o payload passado ‚Äî deve conter limit_price = 2.64
        called["limit_payload"] = dict(signal_data)
        return {"success": True, "data": {"orderId": "CYB-LIM-001"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "123.45"}]}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    # patches
    monkeypatch.setattr(tm, "place_order", fake_place_order)  # n√£o deve ser chamado
    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # 1) N√ÉO abriu a mercado
    assert not called["market"], "LIMIT/SHORT n√£o deve abrir ordem a mercado"

    # 2) Chamou limit com limit_price = 2.64 (maior da faixa)
    assert called["limit_payload"] is not None, "place_limit_order n√£o foi chamado"
    assert called["limit_payload"].get("limit_price") == pytest.approx(2.64, rel=1e-6)

    # 3) Criou PendingSignal
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal n√£o foi criado"

    # 4) Enviou mensagem ao usu√°rio
    assert app.bot.sent, "Nenhuma mensagem foi enviada ao usu√°rio"
    texts = [m.get("text", "").lower() for m in app.bot.sent]
    assert any("limite" in t or "monitorando" in t for t in texts), texts


========================================
# Arquivo: tests/test_signal_parser.py
========================================

import textwrap

from services.signal_parser import parse_signal, SignalType


def test_parse_signal_without_diamond():
    message = textwrap.dedent(
        """
        ‚è≥ #1 - Ordem Limite
        Moeda: SOL
        Tipo: SHORT (Futures)
        Zona de Entrada: 182.66 - 182.66
        Stop Loss: 186.36
        Alvos:
        T1: 181.18
        """
    )

    data = parse_signal(message)

    assert data["coin"] == "SOLUSDT"
    assert data["type"] == SignalType.LIMIT


def test_parse_signal_with_coin_synonym():
    message = textwrap.dedent(
        """
        ‚è≥ #2 - Ordem Limite
        Coin: NMR
        Tipo: SHORT (Futures)
        Zona de Entrada: 8.04 - 8.28
        Stop Loss: 8.55
        Alvos:
        T1: 7.99
        """
    )

    data = parse_signal(message)

    assert data["coin"] == "NMRUSDT"
    assert data["type"] == SignalType.LIMIT


def test_parse_complex_signal_with_emojis_and_extra_text():
    message = textwrap.dedent(
        """
        ‚è≥ #38792 - Ordem Limite

        üì¢ Canal: GRE - 58
        üåê Plataforma: telegram

        üíé Moeda: CYBER
        üìä Tipo: SHORT (Futures)
        üìà Alavancagem: 10x

        üí∞ Zona de Entrada: 2.52500000 - 2.64000000
        üõë Stop Loss: 2.90000000 (12.2943%)
        üéØ Alvos:
        T1: 2.44000000 (5.52%)
        T2: 2.37000000 (8.23%)
        T3: 2.29000000 (11.33%)
        T4: 2.20000000 (14.81%)
        ‚òØÔ∏è R/R ratio: 0.4

        üìä Status: Sinal aberto

        üü¢ Confian√ßa: 66.67%  üß≠ Consenso: 4/6
        """
    )

    data = parse_signal(message)

    assert data is not None, "O parser n√£o deveria retornar None para este sinal"
    assert data["type"] == SignalType.LIMIT
    assert data["coin"] == "CYBERUSDT"
    assert data["order_type"] == "SHORT"
    assert data["entries"] == [2.525, 2.64]
    assert data["stop_loss"] == 2.9
    assert data["targets"] == [2.44, 2.37, 2.29, 2.2]
    assert data["confidence"] == 66.67



# --- NOVO TESTE: MARKET (Ordem √† Mercado) ---
def test_parse_market_signal_with_accent():
    message = textwrap.dedent(
        """
        üèÅ #39170 - Ordem √† Mercado

        üíé Moeda: AVAX
        üìä Tipo: SHORT (Futures)

        üí∞ Zona de Entrada: 22.85000000 - 22.85000000
        üõë Stop Loss: 24.22000000
        Alvos:
        T1: 22.69000000
        T2: 22.55000000
        """
    )

    data = parse_signal(message)

    assert data is not None
    assert data["type"] == SignalType.MARKET
    assert data["coin"] == "AVAXUSDT"
    assert data["order_type"] == "SHORT"
    assert data["entries"][0] == 22.85
    assert data["stop_loss"] == 24.22
    assert 22.69 in data["targets"]
    assert 22.55 in data["targets"]


# --- NOVO TESTE: CANCELAR ---
def test_parse_cancel_signal():
    message = textwrap.dedent(
        """
        ‚ö†Ô∏è BTC sinal cancelado
        """
    )

    data = parse_signal(message)

    assert data is not None
    assert data["type"] == SignalType.CANCELAR
    assert data["coin"] == "BTCUSDT"


========================================
# Arquivo: tests/test_trade_manager_e2e.py
========================================

# tests/test_trade_manager_e2e.py

import sys
import types
import textwrap
import pytest

# ===========================
# STUBS: telegram e bot.keyboards
# ===========================
telegram = types.ModuleType("telegram")
telegram_ext = types.ModuleType("telegram.ext")
telegram_constants = types.ModuleType("telegram.constants")

class InlineKeyboardButton:
    def __init__(self, text, callback_data=None, url=None):
        self.text = text
        self.callback_data = callback_data
        self.url = url

class InlineKeyboardMarkup:
    def __init__(self, keyboard):
        self.keyboard = keyboard

class Application:
    def __init__(self):
        self.bot = None

# exp√µe no m√≥dulo stub
telegram.InlineKeyboardButton = InlineKeyboardButton
telegram.InlineKeyboardMarkup = InlineKeyboardMarkup
telegram.constants = telegram_constants
telegram_ext.Application = Application

# registra stubs
sys.modules.setdefault("telegram", telegram)
sys.modules.setdefault("telegram.ext", telegram_ext)
sys.modules.setdefault("telegram.constants", telegram_constants)

# bot.keyboards stub (para satisfazer "from bot.keyboards import signal_approval_keyboard")
bot_pkg = types.ModuleType("bot")
bot_keyboards = types.ModuleType("bot.keyboards")
def signal_approval_keyboard(signal_id: int):
    return InlineKeyboardMarkup([[InlineKeyboardButton("Aprovar", callback_data=f"approve:{signal_id}")]])
bot_keyboards.signal_approval_keyboard = signal_approval_keyboard
sys.modules.setdefault("bot", bot_pkg)
sys.modules.setdefault("bot.keyboards", bot_keyboards)

# ===========================
# Imports reais do projeto
# ===========================
from services.signal_parser import parse_signal, SignalType
import core.trade_manager as tm


# ===========================
# Fakes utilit√°rios
# ===========================
class FakeUser:
    def __init__(self, telegram_id=111, api_key_encrypted="enc_k", api_secret_encrypted="enc_s", min_confidence=0.0, approval_mode="AUTOMATIC"):
        self.telegram_id = telegram_id
        self.api_key_encrypted = api_key_encrypted
        self.api_secret_encrypted = api_secret_encrypted
        self.min_confidence = min_confidence
        self.approval_mode = approval_mode

class _QueryList:
    def __init__(self, data_list):
        self._data = data_list
    def filter(self, *args, **kwargs):  # compat simples
        return self
    def filter_by(self, **kwargs):
        # Implementa√ß√£o leve para casos .filter_by(user_telegram_id=..., symbol=...)
        def match(obj):
            return all(getattr(obj, k, None) == v for k, v in kwargs.items())
        return _QueryList([x for x in self._data if match(x)])
    def all(self):
        return list(self._data)
    def first(self):
        return self._data[0] if self._data else None

class FakeDB:
    """DB fake que suporta .query(Model) e listas de users/pendings."""
    def __init__(self, users=None, pendings=None):
        self._users = users or []
        self._pendings = pendings or []
        self.added = []
        self.deleted = []
        self.commits = 0
        self.closed = False
    def query(self, Model):
        if Model is tm.User:
            return _QueryList(self._users)
        if Model is tm.PendingSignal:
            return _QueryList(self._pendings)
        if Model is tm.Trade:
            # raramente consultado em testes; devolve vazio
            return _QueryList([])
        if Model is tm.SignalForApproval:
            return _QueryList([])
        return _QueryList([])
    def add(self, obj):
        self.added.append(obj)
        # se for PendingSignal "persistido", tamb√©m aparece em consultas subsequentes
        if isinstance(obj, tm.PendingSignal) or getattr(obj, "__class__", None).__name__ == "DummyPending":
            self._pendings.append(obj)
    def delete(self, obj):
        self.deleted.append(obj)
        if obj in self._pendings:
            self._pendings.remove(obj)
    def commit(self):
        self.commits += 1
    def close(self):
        self.closed = True

class FakeBot:
    def __init__(self):
        self.sent = []
    async def send_message(self, **kwargs):
        self.sent.append(kwargs)

class FakeApplication(Application):
    def __init__(self):
        super().__init__()
        self.bot = FakeBot()


# ===========================
# Textos de sinais
# ===========================
MARKET_SIGNAL = textwrap.dedent("""
üèÅ #39170 - Ordem √† Mercado

üíé Moeda: AVAX
üìä Tipo: SHORT (Futures)

üí∞ Zona de Entrada: 22.85000000 - 22.85000000
üõë Stop Loss: 24.22000000
Alvos:
T1: 22.69000000
T2: 22.55000000
""")

LIMIT_SIGNAL_SHORT = textwrap.dedent("""
‚è≥ #38792 - Ordem Limite

üíé Moeda: CYBER
üìä Tipo: SHORT (Futures)

üí∞ Zona de Entrada: 2.52500000 - 2.64000000
üõë Stop Loss: 2.90000000
Alvos:
T1: 2.44000000
T2: 2.37000000
T3: 2.29000000
T4: 2.20000000
""")

LIMIT_SIGNAL_LONG = textwrap.dedent("""
‚è≥ #50001 - Ordem Limite

üíé Moeda: XRP
üìä Tipo: LONG (Futures)

üí∞ Zona de Entrada: 0.4500 - 0.4510
üõë Stop Loss: 0.4400
Alvos:
T1: 0.4600
T2: 0.4700
""")

CANCEL_SIGNAL_XRP = "‚ö†Ô∏è XRP sinal cancelado"


# ===========================
# TESTES
# ===========================
@pytest.mark.asyncio
async def test_market_flow_calls_place_order(monkeypatch):
    parsed = parse_signal(MARKET_SIGNAL)
    assert parsed and parsed["type"] == SignalType.MARKET

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=999)])

    class DummyTrade:
        def __init__(self, **kwargs):
            self.kwargs = kwargs

    called = {}
    async def fake_place_order(api_key, api_secret, signal_data, user, balance):
        called["api_key"] = api_key
        called["api_secret"] = api_secret
        called["signal_data"] = signal_data
        called["user_id"] = user.telegram_id
        called["balance"] = balance
        return {"success": True, "data": {"orderId": "fake-123", "qty": "1.0"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "100.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_order", fake_place_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "Trade", DummyTrade)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # Valida√ß√µes
    assert called, "place_order n√£o foi chamado"
    assert called["user_id"] == 999
    assert called["signal_data"]["coin"] == "AVAXUSDT"
    assert called["signal_data"]["order_type"] == "SHORT"
    assert called["signal_data"]["entries"][0] == pytest.approx(22.85, rel=1e-6)
    assert called["signal_data"]["stop_loss"] == pytest.approx(24.22, rel=1e-6)
    assert called["balance"] == 100.0

    # Mensagem ao usu√°rio
    assert app.bot.sent, "Nenhuma mensagem foi enviada"
    texts = [m.get("text", "").lower() for m in app.bot.sent]
    assert any(("ordem" in t) or ("aberta" in t) or ("sucesso" in t) for t in texts), texts


@pytest.mark.asyncio
async def test_limit_short_creates_pending_and_uses_upper_bound(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_SHORT)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "SHORT"

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=777)])

    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    called = {"market": False, "limit": None}

    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        called["limit"] = dict(signal_data)  # capturar signal_data com limit_price
        return {"success": True, "data": {"orderId": "LIM-001"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "50.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_order", fake_place_order)  # n√£o deve ser chamado
    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # N√£o deve ter chamado market
    assert not called["market"], "LIMIT (SHORT) n√£o deve abrir ordem a mercado"
    # Deve ter chamado limit com limit_price == high (2.64000000)
    assert called["limit"] and called["limit"].get("limit_price") == pytest.approx(2.64, rel=1e-6)
    # Deve ter criado PendingSignal e avisado usu√°rio
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal n√£o criado"
    assert app.bot.sent, "Sem mensagem de confirma√ß√£o ao usu√°rio"


@pytest.mark.asyncio
async def test_limit_long_uses_lower_bound(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_LONG)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "LONG"

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=888)])

    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    called = {"limit": None}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        called["limit"] = dict(signal_data)
        return {"success": True, "data": {"orderId": "LIM-002"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "80.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    assert called["limit"] is not None, "place_limit_order n√£o foi chamado"
    assert called["limit"]["limit_price"] == pytest.approx(0.4500, rel=1e-6), "LONG deve usar menor pre√ßo da faixa"
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal n√£o criado"
    assert app.bot.sent, "Sem mensagem ao usu√°rio"


@pytest.mark.asyncio
async def test_limit_skips_when_existing_pending(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_LONG)
    assert parsed and parsed["type"] == SignalType.LIMIT

    app = FakeApplication()

    class DummyPending:
        def __init__(self, user_telegram_id, symbol, order_id="old", signal_data=None):
            self.user_telegram_id = user_telegram_id
            self.symbol = symbol
            self.order_id = order_id
            self.signal_data = signal_data or {}

    # j√° existe um pendente para o mesmo s√≠mbolo e usu√°rio
    existing = DummyPending(user_telegram_id=777, symbol="XRPUSDT")
    db = FakeDB(users=[FakeUser(telegram_id=777)], pendings=[existing])

    called = {"limit": False}
    async def fake_place_limit_order(*a, **k):
        called["limit"] = True
        return {"success": True}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")
    async def fake_get_account_info(api_key, api_secret): return {"success": True, "data": [{"totalEquity": "10"}]}

    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # n√£o deve chamar place_limit_order
    assert not called["limit"], "N√£o deveria tentar posicionar nova LIMIT com pendente existente"
    # deve ter avisado usu√°rio
    assert app.bot.sent and any("j√° tem uma ordem limite pendente" in (m.get("text","")) for m in app.bot.sent)


@pytest.mark.asyncio
async def test_cancel_removes_pending_and_notifies(monkeypatch):
    # preparar db com pending XRP para user 123
    class DummyPending:
        def __init__(self, user_telegram_id, symbol, order_id="LIM-XYZ", signal_data=None):
            self.user_telegram_id = user_telegram_id
            self.symbol = symbol
            self.order_id = order_id
            self.signal_data = signal_data or {}

    pend = DummyPending(user_telegram_id=123, symbol="XRPUSDT")
    users = [FakeUser(telegram_id=123)]
    base_db = FakeDB(users=users, pendings=[pend])

    # monkeypatch SessionLocal para devolver nosso FakeDB
    def fake_SessionLocal():
        # devolve uma "nova" inst√¢ncia por chamada, clonando o estado base
        return FakeDB(users=list(base_db._users), pendings=list(base_db._pendings))

    app = FakeApplication()

    async def fake_cancel_order(api_key, api_secret, order_id, symbol):
        return {"success": True}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "SessionLocal", fake_SessionLocal)
    monkeypatch.setattr(tm, "cancel_order", fake_cancel_order)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)

    parsed_cancel = parse_signal(CANCEL_SIGNAL_XRP)
    assert parsed_cancel and parsed_cancel["type"] == SignalType.CANCELAR

    await tm.process_new_signal(parsed_cancel, app, source_name="TEST-CHANNEL")

    # Como usamos uma inst√¢ncia nova de FakeDB dentro do process, n√£o temos refer√™ncia direta
    # mas podemos validar pelo envio de mensagem de sucesso
    assert app.bot.sent and any("foi cancelada com sucesso" in (m.get("text","").lower()) for m in app.bot.sent)


@pytest.mark.asyncio
async def test_cancel_without_pending_sends_info_notification(monkeypatch):
    # DB sem pendentes
    base_db = FakeDB(users=[FakeUser(telegram_id=1)], pendings=[])
    def fake_SessionLocal():
        return FakeDB(users=list(base_db._users), pendings=list(base_db._pendings))

    app = FakeApplication()
    captured = {"msg": None}

    async def fake_send_notification(application, text):
        captured["msg"] = text

    monkeypatch.setattr(tm, "SessionLocal", fake_SessionLocal)
    monkeypatch.setattr(tm, "send_notification", fake_send_notification)

    parsed_cancel = parse_signal(CANCEL_SIGNAL_XRP)
    await tm.process_new_signal(parsed_cancel, app, source_name="TEST-CHANNEL")

    assert captured["msg"] is not None
    assert "nenhuma ordem pendente foi encontrada" in captured["msg"].lower()


@pytest.mark.asyncio
async def test_market_fails_on_balance_fetch(monkeypatch):
    parsed = parse_signal(MARKET_SIGNAL)
    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=321)])

    async def fake_get_account_info(api_key, api_secret):
        return {"success": False}  # falha

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    called = {"market": False}
    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "place_order", fake_place_order)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    assert not called["market"], "N√£o deve tentar abrir ordem sem saldo"
    assert app.bot.sent and any("falha ao buscar seu saldo bybit" in (m.get("text","").lower()) for m in app.bot.sent)


========================================
# Arquivo: utils/__init__.py
========================================



========================================
# Arquivo: utils/config.py
========================================

import os
from dotenv import load_dotenv

load_dotenv()

TELEGRAM_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
ENCRYPTION_KEY = os.getenv('ENCRYPTION_KEY')

API_ID = os.getenv('API_ID')
API_HASH = os.getenv('API_HASH')
ADMIN_ID = int(os.getenv('ADMIN_TELEGRAM_ID', 0)) # Converte para int

========================================
# Arquivo: utils/security.py
========================================

from cryptography.fernet import Fernet
from .config import ENCRYPTION_KEY

# Inicializa o 'cofre' com a sua chave
cipher_suite = Fernet(ENCRYPTION_KEY.encode())

def encrypt_data(data: str) -> str:
    """Criptografa um texto e retorna a vers√£o em string."""
    if not data:
        return None
    encrypted_bytes = cipher_suite.encrypt(data.encode())
    return encrypted_bytes.decode()

def decrypt_data(encrypted_data: str) -> str:
    """Descriptografa um texto e retorna a vers√£o original."""
    if not encrypted_data:
        return None
    decrypted_bytes = cipher_suite.decrypt(encrypted_data.encode())
    return decrypted_bytes.decode()

========================================
# Arquivo: scripts/create_invite.py
========================================

import sys
from database.session import SessionLocal, init_db
from database.models import InviteCode

def create_invite_code(code: str):
    db = SessionLocal()
    try:
        existing_code = db.query(InviteCode).filter(InviteCode.code == code).first()
        if existing_code:
            print(f"C√≥digo '{code}' j√° existe.")
            return

        new_code = InviteCode(code=code)
        db.add(new_code)
        db.commit()
        print(f"C√≥digo de convite '{code}' criado com sucesso!")
    finally:
        db.close()

if __name__ == "__main__":
    init_db()
    # Agora ele l√™ o c√≥digo a partir do seu comando no terminal
    if len(sys.argv) > 1:
        code_to_create = sys.argv[1]
        create_invite_code(code_to_create)
    else:
        print("Erro: Por favor, forne√ßa um c√≥digo para criar. Exemplo: python create_invite.py MEU-CODIGO-NOVO")

========================================
# Arquivo: bot/__init__.py
========================================



========================================
# Arquivo: bot/handlers.py
========================================

import logging
import asyncio
from database.models import PendingSignal
from services.bybit_service import place_limit_order, get_account_info
from datetime import datetime, time, timedelta 
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler
from telegram.error import BadRequest
from database.session import SessionLocal
from database.models import User, InviteCode, MonitoredTarget, Trade, SignalForApproval
from .keyboards import (
    main_menu_keyboard, confirm_remove_keyboard, admin_menu_keyboard, 
    dashboard_menu_keyboard, settings_menu_keyboard, view_targets_keyboard, 
    bot_config_keyboard, performance_menu_keyboard)
from utils.security import encrypt_data, decrypt_data
from services.bybit_service import (
    get_open_positions, 
    get_account_info, 
    close_partial_position, 
    get_open_positions_with_pnl,
    get_market_price
)
from utils.config import ADMIN_ID
from database.crud import get_user_by_id
from core.trade_manager import _execute_trade
from core.performance_service import generate_performance_report
from core.trade_manager import execute_signal_for_all_users


# Estados para as conversas
(WAITING_CODE, WAITING_API_KEY, WAITING_API_SECRET, CONFIRM_REMOVE_API) = range(4)
(ASKING_ENTRY_PERCENT, ASKING_MAX_LEVERAGE, ASKING_MIN_CONFIDENCE) = range(10, 13)
(ASKING_PROFIT_TARGET, ASKING_LOSS_LIMIT) = range(13, 15)
ASKING_COIN_WHITELIST = 15

logger = logging.getLogger(__name__)

# --- FLUXO DE USU√ÅRIO (START, CADASTRO, MENUS) ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    telegram_user = update.effective_user
    user_in_db = get_user_by_id(telegram_user.id)
    if user_in_db:
        await update.message.reply_text(
            "Menu Principal:",
            reply_markup=main_menu_keyboard(telegram_id=telegram_user.id)
        )
        return ConversationHandler.END
    else:
        await update.message.reply_text(
            f"Ol√°, {telegram_user.first_name}! Para usar o TradeFlow, insira seu c√≥digo de convite."
        )
        return WAITING_CODE

async def receive_invite_code(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    code_text = update.message.text
    telegram_user = update.effective_user
    db = SessionLocal()
    try:
        invite_code = db.query(InviteCode).filter(InviteCode.code == code_text, InviteCode.is_used == False).first()
        if invite_code:
            new_user = User(telegram_id=telegram_user.id, first_name=telegram_user.first_name)
            db.add(new_user)
            invite_code.is_used = True
            db.commit()
            await update.message.reply_text(
                "‚úÖ Cadastro realizado com sucesso! O pr√≥ximo passo √© configurar sua API.",
                reply_markup=main_menu_keyboard(telegram_id=telegram_user.id)
            )
            return ConversationHandler.END
        else:
            await update.message.reply_text("‚ùå C√≥digo de convite inv√°lido ou j√° utilizado. Tente novamente.")
            return WAITING_CODE
    finally:
        db.close()

async def back_to_main_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        "Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=update.effective_user.id)
    )

# --- FLUXO DE CONFIGURA√á√ÉO DE API ---
async def config_api(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Inicia o fluxo de configura√ß√£o de API com um tutorial melhorado."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['entry_message_id'] = query.message.message_id
    
    tutorial_text = (
        "üîë <b>Como Criar suas Chaves de API na Bybit</b> üîë\n\n"
        "Siga estes passos com aten√ß√£o para conectar sua conta:\n\n"
        "1Ô∏è‚É£  Fa√ßa login em <b>Bybit.com</b> e v√° para <i>Perfil > API</i>.\n\n"
        "2Ô∏è‚É£  Clique em <b>'Criar Nova Chave'</b> e selecione <i>'Chaves Geradas pelo Sistema'</i>.\n\n"
        "3Ô∏è‚É£  D√™ um nome para sua chave (ex: `TradeFlowBot`) e selecione as permiss√µes de <b>'Leitura e Escrita'</b>.\n\n"
        "4Ô∏è‚É£  Nas permiss√µes, marque <b>APENAS</b> as seguintes caixas:\n"
        "   - <b>Contrato</b> (`Contract`): ‚úÖ `Ordens` e ‚úÖ `Posi√ß√µes`\n"
        "   - <b>Trading Unificado</b> (`UTA`): ‚úÖ `Trade`\n\n"
        "5Ô∏è‚É£  üõ°Ô∏è <b>MUITO IMPORTANTE:</b> Por seguran√ßa, <b>N√ÉO</b> marque a permiss√£o de <i>'Saque' (Withdraw)</i>.\n\n"
        "‚ö†Ô∏è <b>Aten√ß√£o:</b> Este bot opera exclusivamente com pares de trade terminados em **USDT**.\n\n"
        "6Ô∏è‚É£  Conclua a verifica√ß√£o de seguran√ßa e copie sua <b>API Key</b> e <b>API Secret</b>.\n\n"
        "-------------------------------------\n"
        "Pronto! Agora, por favor, envie sua <b>API Key</b>."
    )
    
    await query.edit_message_text(
        text=tutorial_text,
        parse_mode='HTML'
    )
    return WAITING_API_KEY

async def receive_api_key(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe a API Key, apaga a mensagem do usu√°rio e pede a API Secret."""
    await context.bot.delete_message(
        chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    api_key = update.message.text
    context.user_data['api_key'] = api_key
    
    prompt_message = await update.message.reply_text(
        "Chave API recebida com seguran√ßa. Agora, por favor, envie sua *API Secret*.",
        parse_mode='Markdown'
    )
    context.user_data['prompt_message_id'] = prompt_message.message_id
    
    return WAITING_API_SECRET

async def receive_api_secret(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe a API Secret, apaga as mensagens, criptografa e salva no banco."""
    await context.bot.delete_message(
        chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    prompt_message_id = context.user_data.get('prompt_message_id')
    if prompt_message_id:
        await context.bot.delete_message(
            chat_id=update.effective_chat.id,
            message_id=prompt_message_id
        )

    api_secret = update.message.text
    api_key = context.user_data.get('api_key')
    telegram_id = update.effective_user.id

    encrypted_key = encrypt_data(api_key)
    encrypted_secret = encrypt_data(api_secret)

    db = SessionLocal()
    try:
        user_to_update = db.query(User).filter(User.telegram_id == telegram_id).first()
        if user_to_update:
            user_to_update.api_key_encrypted = encrypted_key
            user_to_update.api_secret_encrypted = encrypted_secret
            db.commit()
            
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=context.user_data['entry_message_id'],
                text="‚úÖ Suas chaves de API foram salvas com sucesso!",
            )
            await context.bot.send_message(
                chat_id=telegram_id,
                text="Menu Principal:",
                reply_markup=main_menu_keyboard(telegram_id=telegram_id)
            )
        else:
            await update.message.reply_text("Ocorreu um erro. Usu√°rio n√£o encontrado.")
    finally:
        db.close()
        context.user_data.clear()

    return ConversationHandler.END

# --- FLUXO DE REMO√á√ÉO DE API ---
async def remove_api_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        text="‚ö†Ô∏è Voc√™ tem certeza que deseja remover suas chaves de API?",
        reply_markup=confirm_remove_keyboard()
    )
    return CONFIRM_REMOVE_API

async def remove_api_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id

    if query.data == 'remove_api_confirm':
        db = SessionLocal()
        try:
            user_to_update = db.query(User).filter(User.telegram_id == telegram_id).first()
            if user_to_update:
                user_to_update.api_key_encrypted = None
                user_to_update.api_secret_encrypted = None
                db.commit()
            await query.edit_message_text("‚úÖ Suas chaves de API foram removidas.")
        finally:
            db.close()
    else: # Cancelou
        await query.edit_message_text("Opera√ß√£o cancelada.")

    await context.bot.send_message(
        chat_id=telegram_id,
        text="Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=telegram_id)
    )
    return ConversationHandler.END

# --- PAIN√âIS DO USU√ÅRIO ---
async def my_positions_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("Buscando suas posi√ß√µes gerenciadas...")

    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if not user or not user.api_key_encrypted:
            await query.edit_message_text(
                "Voc√™ ainda n√£o configurou suas chaves de API.",
            )
            return

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # posi√ß√µes abertas (live) com P/L atual
        live = await get_open_positions_with_pnl(api_key, api_secret)
        live_positions = live["data"] if live.get("success") else []

        # trades que o BOT est√° gerenciando (para os bot√µes/IDs)
        active_trades = db.query(Trade).filter(
            Trade.user_telegram_id == user_id,
            ~Trade.status.like('%CLOSED%')
        ).all()

        # monta um √≠ndice por s√≠mbolo -> trade.id (se existir)
        trade_id_by_symbol = {t.symbol: t.id for t in active_trades}

        lines = ["<b>üìä Suas Posi√ß√µes Ativas (Gerenciadas pelo Bot)</b>", ""]
        keyboard = []

        if not live_positions and not active_trades:
            lines.append("Nenhuma posi√ß√£o sendo gerenciada no momento.")
        else:
            for pos in live_positions:
                arrow = "‚¨ÜÔ∏è" if pos["side"] == "LONG" else "‚¨áÔ∏è"
                sym = pos["symbol"]
                size = pos["size"]
                entry = pos["entry"] or 0.0
                mark = pos["mark"] or 0.0
                pnl = pos["unrealized_pnl"]
                pnl_pct = pos["unrealized_pnl_pct"]

                lines.append(
                    f"- {arrow} <b>{sym}</b> ({size:g} unid.)\n"
                    f"  Entrada: ${entry:.4f} | Pre√ßo: ${mark:.4f}\n"
                    f"  P/L: <b>{pnl:+.2f} USDT</b> ({pnl_pct:+.2f}%)\n"
                )

                # se o bot estiver gerenciando esse s√≠mbolo, mostra o bot√£o fechar
                if sym in trade_id_by_symbol:
                    trade_id = trade_id_by_symbol[sym]
                    keyboard.append([
                        InlineKeyboardButton(
                            f"Fechar {sym} ‚ùå",
                            callback_data=f"manual_close_{trade_id}"
                        )
                    ])

            # fallback: se existir trade ‚Äúgerenciado‚Äù sem posi√ß√£o viva (ex.: zerou na corretora),
            # ainda mostramos o item para permitir fechamento/limpeza manual.
            for t in active_trades:
                if t.symbol not in {p["symbol"] for p in live_positions}:
                    side_emoji = "‚¨ÜÔ∏è" if t.side == 'LONG' else "‚¨áÔ∏è"
                    lines.append(
                        f"- {side_emoji} <b>{t.symbol}</b> ({t.qty:g} unid.)\n"
                        f"  Entrada: ${t.entry_price:.4f} | Status: {t.status}\n"
                    )
                    keyboard.append([
                        InlineKeyboardButton(
                            f"Fechar {t.symbol} ‚ùå",
                            callback_data=f"manual_close_{t.id}"
                        )
                    ])

        keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data='back_to_main_menu')])
        await query.edit_message_text(
            "\n".join(lines),
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    finally:
        db.close()

async def user_dashboard_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o painel com saldo focado em USDT, outras moedas e posi√ß√µes."""
    query = update.callback_query
    try:
        await query.answer()
    except BadRequest as e:
        logger.warning(f"N√£o foi poss√≠vel responder ao callback_query (pode ser antigo): {e}")
        return

    await query.edit_message_text("Buscando informa√ß√µes do painel...")
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = get_user_by_id(user_id)
        if not user or not user.api_key_encrypted:
            await query.edit_message_text("Voc√™ precisa configurar sua API primeiro.", reply_markup=main_menu_keyboard(telegram_id=user_id))
            return

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        account_info, positions_info = await asyncio.gather(
            get_account_info(api_key, api_secret),
            get_open_positions_with_pnl(api_key, api_secret)
        )

        message = "<b>‚ÑπÔ∏è Seu Painel de Controle</b>\n\n"
        message += "<b>Saldos na Carteira:</b>\n"

        if account_info.get("success"):
            balance_data = account_info.get("data", {})
            coin_list = balance_data.get("coin_list", [])
            
            usdt_balance_value = 0.0
            other_coins_lines = []

            for c in coin_list:
                coin = (c.get("coin") or "").upper()
                wallet_balance_str = c.get("walletBalance")
                wallet_balance = float(wallet_balance_str) if wallet_balance_str else 0.0

                if coin == "USDT":
                    usdt_balance_value = wallet_balance
                elif wallet_balance >= 0.1:
                    other_coins_lines.append(f"- {coin}: {wallet_balance:.2f}")

            message += f"<b>- USDT: {usdt_balance_value:.2f}</b>\n"
            if other_coins_lines:
                message += "\n".join(other_coins_lines)
            elif usdt_balance_value == 0.0:
                 message += "Nenhum saldo relevante encontrado.\n"
        else:
            message += f"Erro ao buscar saldo: {account_info.get('error')}\n"

        message += "\n\n<b>Posi√ß√µes Abertas:</b>\n"
        if positions_info.get("success") and positions_info.get("data"):
            for p in positions_info["data"]:
                side = (p.get("side") or "").upper()
                arrow = "üîº" if side == "LONG" else "üîΩ"
                symbol = p.get("symbol", "???")
                size = p.get("size", 0)
                entry = float(p.get("entry_price") or 0)
                mark = float(p.get("mark_price") or 0)
                pnl = float(p.get("unrealized_pnl") or 0)
                pnl_pct = float(p.get("unrealized_pnl_pct") or 0)

                message += (
                    f"- {arrow} {symbol}: {size:g}\n"
                    f"  Entrada: ${entry:,.4f} | Atual: ${mark:,.4f}\n"
                    f"  P/L: <b>${pnl:+.2f} ({pnl_pct:+.2f}%)</b>\n"
                )
        else:
            message += "- Nenhuma posi√ß√£o aberta no momento."

        message += "\n\n<i>‚ö†Ô∏è Este bot opera exclusivamente com pares USDT.</i>"

        await query.edit_message_text(message, parse_mode="HTML", reply_markup=dashboard_menu_keyboard())

    except Exception as e:
        logger.error(f"Erro ao montar o painel do usu√°rio: {e}", exc_info=True)
        await query.edit_message_text("Ocorreu um erro ao buscar os dados do seu painel.")
    finally:
        db.close()


# --- CANCELAMENTO ---
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancela a opera√ß√£o atual."""
    await update.message.reply_text("Opera√ß√£o cancelada.")
    return ConversationHandler.END

# --- FLUXO DE ADMINISTRA√á√ÉO ---
async def admin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra o menu de administrador, se o usu√°rio for o admin."""
    user_id = update.effective_user.id
    if user_id != ADMIN_ID:
        await update.message.reply_text("Voc√™ n√£o tem permiss√£o para usar este comando.")
        return

    await update.message.reply_text(
        "Bem-vindo ao painel de administra√ß√£o.",
        reply_markup=admin_menu_keyboard()
    )


async def admin_view_targets_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Busca e exibe a lista de todos os canais e t√≥picos sendo monitorados."""
    query = update.callback_query
    await query.answer()
    
    db = SessionLocal()
    try:
        targets = db.query(MonitoredTarget).all()
        
        message = "<b>üëÅÔ∏è Alvos Atualmente Monitorados</b>\n\n"
        
        if targets:
            for target in targets:
                if target.topic_name:
                    message += f"- <b>Grupo:</b> {target.channel_name}\n  - <b>T√≥pico:</b> {target.topic_name}\n"
                else:
                    message += f"- <b>Canal:</b> {target.channel_name}\n"
        else:
            message += "Nenhum alvo sendo monitorado no momento."
            
        await query.edit_message_text(
            text=message,
            parse_mode='HTML',
            reply_markup=view_targets_keyboard()
        )
    finally:
        db.close()

async def back_to_admin_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usu√°rio para o menu de administra√ß√£o principal."""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        "Bem-vindo ao painel de administra√ß√£o.",
        reply_markup=admin_menu_keyboard()
    )

async def list_channels_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Coloca um pedido na fila para listar os grupos e canais do usu√°rio."""
    query = update.callback_query
    await query.answer()
    
    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue:
        await query.edit_message_text("Erro: Fila de comunica√ß√£o n√£o encontrada.")
        return
    
    request_data = {
        "action": "list_channels",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
    }
    
    await comm_queue.put(request_data)
    
    await query.edit_message_text("Buscando sua lista de canais... Se voc√™ tiver muitos grupos, isso pode levar at√© um minuto. Por favor, aguarde.")
    
async def select_channel_to_monitor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Coloca um pedido na fila para listar t√≥picos (ou gerenciar um canal plano)."""
    query = update.callback_query
    await query.answer()
    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue: return

    user_id = update.effective_user.id
    if user_id != ADMIN_ID: return

    channel_id = int(query.data.split('_')[-1])
    
    channel_name = ""
    for row in query.message.reply_markup.inline_keyboard:
        for button in row:
            if button.callback_data == query.data:
                channel_name = button.text.replace(" ‚úÖ", "")
                break

    request_data = {
        "action": "list_topics",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
        "channel_id": channel_id,
        "channel_name": channel_name
    }
    
    await comm_queue.put(request_data)
    await query.edit_message_text("Processando...")

async def select_topic_to_monitor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Salva/remove o t√≥pico e pede para a fila recarregar o menu de t√≥picos."""
    query = update.callback_query
    await query.answer() 

    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue:
        logger.error("Fila de comunica√ß√£o n√£o encontrada no contexto do bot.")
        return

    user_id = update.effective_user.id
    if user_id != ADMIN_ID: return

    _, _, channel_id_str, topic_id_str = query.data.split('_')
    channel_id = int(channel_id_str)
    topic_id = int(topic_id_str)
    
    db = SessionLocal()
    try:
        existing_target = db.query(MonitoredTarget).filter_by(channel_id=channel_id, topic_id=topic_id).first()
        
        if existing_target:
            db.delete(existing_target)
        else:
            topic_name = ""
            for row in query.message.reply_markup.inline_keyboard:
                for button in row:
                    if button.callback_data == query.data:
                        topic_name = button.text.replace(" ‚úÖ", "")
                        break
            new_target = MonitoredTarget(channel_id=channel_id, topic_id=topic_id, topic_name=topic_name)
            db.add(new_target)
        
        db.commit()
    finally:
        db.close()

    request_data = {
        "action": "list_topics",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
        "channel_id": channel_id,
        "channel_name": ""
    }
    await comm_queue.put(request_data)

async def back_to_channels_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usu√°rio para a lista de canais/grupos."""
    await list_channels_handler(update, context)

# --- FUN√á√ïES DUPLICADAS REMOVIDAS PARA LIMPEZA ---
# my_dashboard_handler, my_positions_handler, back_to_main_menu_handler
# j√° estavam definidas acima.

async def user_settings_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de configura√ß√µes de trade com os valores atuais do usu√°rio."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            await query.edit_message_text(
                "<b>‚öôÔ∏è Configura√ß√µes de Trade</b>\n\n"
                "Aqui voc√™ pode definir seus par√¢metros de risco e automa√ß√£o.",
                parse_mode='HTML',
                reply_markup=settings_menu_keyboard(user)
            )
    finally:
        db.close()

async def ask_entry_percent(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usu√°rio qual a nova porcentagem da banca por entrada."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie a porcentagem da sua banca em USDT que voc√™ deseja usar para cada entrada.\n\n"
        "Exemplo: se voc√™ tem $100 e define `10`, cada entrada ter√° o valor de $10.\n"
        "Envie apenas o n√∫mero (ex: `10` para 10%)."
    )
    return ASKING_ENTRY_PERCENT

async def receive_entry_percent(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova porcentagem de entrada."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        percent_value = float(update.message.text.replace(',', '.'))
        if not (0.1 <= percent_value <= 100):
            raise ValueError("Valor fora do range permitido (0.1 a 100)")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.entry_size_percent = percent_value
            db.commit()
            
            api_key = decrypt_data(user.api_key_encrypted)
            api_secret = decrypt_data(user.api_secret_encrypted)
            account_info = await get_account_info(api_key, api_secret)
            
            usdt_balance = 0.0
            if account_info.get("success"):
                balances = account_info.get("data", [])
                if balances:
                    coin_list = balances[0].get('coin', [])
                    for coin in coin_list:
                        if coin.get('coin') == 'USDT':
                            usdt_balance = float(coin.get('walletBalance', 0))
                            break
            
            entry_value = usdt_balance * (percent_value / 100)
            
            feedback_text = (
                f"‚úÖ Tamanho da entrada atualizado para <b>{percent_value:.2f}%</b>.\n\n"
                f"Com seu saldo atual, cada entrada ser√° de aprox. <b>${entry_value:,.2f} USDT</b>."
            )

            if percent_value > 25:
                feedback_text += "\n\n‚ö†Ô∏è <b>Aten√ß√£o:</b> Uma porcentagem acima de 25% √© considerada de alt√≠ssimo risco!"

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=feedback_text,
                parse_mode='HTML',
                reply_markup=settings_menu_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="‚ùå Valor inv√°lido. Por favor, tente novamente com um n√∫mero entre 0.1 e 100 (ex: 10)."
        )
        return ASKING_ENTRY_PERCENT

    return ConversationHandler.END        

async def ask_max_leverage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usu√°rio qual a nova alavancagem m√°xima."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Qual a alavancagem m√°xima que o bot deve usar?\n"
        "Envie apenas o n√∫mero (ex: `10` para 10x)."
    )
    return ASKING_MAX_LEVERAGE

async def receive_max_leverage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova alavancagem m√°xima."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    try:
        leverage_value = int(update.message.text)
        if not (1 <= leverage_value <= 125):
            raise ValueError("Alavancagem fora do limite (1-125)")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.max_leverage = leverage_value
            db.commit()
            
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"‚úÖ Alavancagem m√°xima atualizada para {leverage_value}x.\n\n"
                     "Selecione outra op√ß√£o para editar ou volte.",
                reply_markup=settings_menu_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="‚ùå Valor inv√°lido. Por favor, tente novamente com um n√∫mero inteiro (ex: 10)."
        )
        return ASKING_MAX_LEVERAGE
    finally:
        await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    return ConversationHandler.END

async def ask_min_confidence(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usu√°rio qual o novo valor de confian√ßa m√≠nima."""
    query = update.callback_query
    await query.answer()
    context.user_data['settings_message_id'] = query.message.message_id
    await query.edit_message_text("Envie o valor da confian√ßa m√≠nima da IA (ex: 75 para 75%).\nSinais com confian√ßa abaixo disso ser√£o ignorados.")
    return ASKING_MIN_CONFIDENCE

async def receive_min_confidence(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva o novo valor de confian√ßa."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        confidence_value = float(update.message.text.replace(',', '.'))
        if not (0 <= confidence_value <= 100):
            raise ValueError("Valor fora do range permitido (0-100)")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.min_confidence = confidence_value
            db.commit()
            
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"‚úÖ Confian√ßa m√≠nima atualizada para {confidence_value:.2f}%.\n\n"
                     "Selecione outra op√ß√£o para editar ou volte.",
                reply_markup=settings_menu_keyboard(user)
            )
        finally:
            db.close()

        return ConversationHandler.END

    except (ValueError, TypeError):
        logger.warning(f"Usu√°rio {user_id} enviou um valor inv√°lido para confian√ßa: {update.message.text}")
        
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="‚ùå <b>Valor inv√°lido.</b>\nPor favor, envie apenas um n√∫mero entre 0 e 100 (ex: 75).",
            parse_mode='HTML'
        )
        
        return ASKING_MIN_CONFIDENCE
    
async def manual_close_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Lida com o fechamento manual de uma posi√ß√£o pelo usu√°rio."""
    query = update.callback_query
    await query.answer("Processando fechamento...")

    trade_id = int(query.data.split('_')[-1])
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        trade_to_close = db.query(Trade).filter_by(id=trade_id, user_telegram_id=user_id).first()

        if not trade_to_close:
            await query.edit_message_text("Erro: Trade n√£o encontrado ou j√° fechado.")
            return

        user = db.query(User).filter_by(telegram_id=user_id).first()
        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # --- NOVA L√ìGICA ---
        # 1. Pega o pre√ßo atual para calcular o P/L
        price_result = await get_market_price(trade_to_close.symbol)
        if not price_result.get("success"):
            await context.bot.send_message(chat_id=user_id, text=f"‚ö†Ô∏è N√£o foi poss√≠vel obter o pre√ßo atual de {trade_to_close.symbol} para calcular o P/L.")
            current_price = trade_to_close.entry_price # Fallback
        else:
            current_price = price_result["price"]

        # 2. Fecha a posi√ß√£o
        close_result = await close_partial_position(
            api_key, 
            api_secret, 
            trade_to_close.symbol, 
            trade_to_close.remaining_qty, 
            trade_to_close.side
        )

        if close_result.get("success"):
            # 3. Calcula o P/L e formata a mensagem
            pnl = (current_price - trade_to_close.entry_price) * trade_to_close.remaining_qty if trade_to_close.side == 'LONG' else (trade_to_close.entry_price - current_price) * trade_to_close.remaining_qty
            
            resultado_str = "LUCRO" if pnl >= 0 else "PREJU√çZO"
            emoji = "‚úÖ" if pnl >= 0 else "üîª"
            
            message_text = (
                f"{emoji} <b>Posi√ß√£o Fechada Manualmente ({resultado_str})</b>\n"
                f"<b>Moeda:</b> {trade_to_close.symbol}\n"
                f"<b>Resultado:</b> ${pnl:,.2f}"
            )
            
            trade_to_close.status = 'CLOSED_MANUAL'
            db.commit()
            await query.edit_message_text(message_text, parse_mode='HTML')
            # Atualiza a lista de posi√ß√µes ap√≥s um pequeno delay
            await asyncio.sleep(2)
            await my_positions_handler(update, context)
        else:
            error_msg = close_result.get('error')
            await context.bot.send_message(
                chat_id=user_id,
                text=f"‚ùå Erro ao fechar a posi√ß√£o para {trade_to_close.symbol}: {error_msg}"
            )
    finally:
        db.close()


async def bot_config_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de configura√ß√£o do bot com o modo de aprova√ß√£o atual."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    db = SessionLocal()
    try:
        user = get_user_by_id(user_id)
        if user:
            await query.edit_message_text(
                "<b>ü§ñ Configura√ß√£o do Bot</b>\n\n"
                "Ajuste o comportamento geral do bot.",
                parse_mode='HTML',
                reply_markup=bot_config_keyboard(user)
            )
    finally:
        db.close()

async def toggle_approval_mode_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Alterna o modo de aprova√ß√£o de ordens entre Manual e Autom√°tico."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == user_id).first()
        
        if user:
            if user.approval_mode == 'AUTOMATIC':
                user.approval_mode = 'MANUAL'
            else:
                user.approval_mode = 'AUTOMATIC'
            
            db.commit() 
            
            try:
                await query.edit_message_text(
                    "<b>ü§ñ Configura√ß√£o do Bot</b>\n\n"
                    "Ajuste o comportamento geral do bot.",
                    parse_mode='HTML',
                    reply_markup=bot_config_keyboard(user)
                )
            except BadRequest as e:
                if "Message is not modified" in str(e):
                    pass
                else:
                    logger.error(f"Erro ao editar mensagem em toggle_approval_mode: {e}")
    finally:
        db.close()

async def handle_signal_approval(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    ### ALTERA√á√ÉO INICIADA ###
    # A linha abaixo estava incorreta e n√£o extra√≠a a a√ß√£o ('approve') corretamente.
    # A nova linha usa `partition` para dividir a string de forma mais confi√°vel.
    # Ex: 'approve_signal_123' se torna ('approve', '_signal_', '123')
    action, _, signal_id_str = query.data.partition('_signal_')
    ### ALTERA√á√ÉO FINALIZADA ###

    signal_id = int(signal_id_str)
    
    db = SessionLocal()
    try:
        signal_to_process = db.query(SignalForApproval).filter_by(id=signal_id).first()
        if not signal_to_process:
            await query.edit_message_text("Este sinal j√° foi processado ou expirou.")
            return

        if action == 'approve':
            await query.edit_message_text("‚úÖ **Entrada Aprovada!** Replicando a ordem para todos os usu√°rios...")
            
            await execute_signal_for_all_users(
                signal_data=signal_to_process.signal_data,
                application=context.application,
                db=db,
                source_name=signal_to_process.source_name
            )
            
        elif action == 'reject':
            await query.edit_message_text("‚ùå **Entrada Rejeitada.** O sinal foi descartado.")
        
        db.delete(signal_to_process)
        db.commit()
    finally:
        db.close()

# --- FLUXO DE CONFIGURA√á√ÉO DE METAS DI√ÅRIAS ---

async def ask_profit_target(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usu√°rio a nova meta de lucro di√°rio."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie a sua meta de **lucro di√°rio** em USDT.\n"
        "O bot ir√° parar de abrir novas ordens quando o lucro do dia atingir este valor.\n\n"
        "Envie apenas o n√∫mero (ex: `100` para $100) ou `0` para desativar.",
        parse_mode='Markdown'
    )
    return ASKING_PROFIT_TARGET

async def receive_profit_target(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova meta de lucro."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        target_value = float(update.message.text.replace(',', '.'))
        if target_value < 0:
            raise ValueError("Valor n√£o pode ser negativo")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.daily_profit_target = target_value
            db.commit()
            
            feedback_text = f"‚úÖ Meta de lucro di√°rio atualizada para ${target_value:.2f}."
            if target_value == 0:
                feedback_text = "‚úÖ Meta de lucro di√°rio foi desativada."

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"{feedback_text}\n\nAjuste outra configura√ß√£o ou volte.",
                reply_markup=bot_config_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="‚ùå Valor inv√°lido. Por favor, tente novamente com um n√∫mero (ex: 100)."
        )
        return ASKING_PROFIT_TARGET

    return ConversationHandler.END

async def ask_loss_limit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usu√°rio o novo limite de perda di√°rio."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie o seu limite de **perda di√°ria** em USDT.\n"
        "O bot ir√° parar de abrir novas ordens se a perda do dia atingir este valor.\n\n"
        "Envie um n√∫mero positivo (ex: `50` para um limite de $50) ou `0` para desativar.",
        parse_mode='Markdown'
    )
    return ASKING_LOSS_LIMIT

async def receive_loss_limit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva o novo limite de perda."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        limit_value = float(update.message.text.replace(',', '.'))
        if limit_value < 0:
            raise ValueError("Valor n√£o pode ser negativo")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.daily_loss_limit = limit_value
            db.commit()

            feedback_text = f"‚úÖ Limite de perda di√°rio atualizado para ${limit_value:.2f}."
            if limit_value == 0:
                feedback_text = "‚úÖ Limite de perda di√°rio foi desativado."

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"{feedback_text}\n\nAjuste outra configura√ß√£o ou volte.",
                reply_markup=bot_config_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="‚ùå Valor inv√°lido. Por favor, tente novamente com um n√∫mero positivo (ex: 50)."
        )
        return ASKING_LOSS_LIMIT

    return ConversationHandler.END

# --- MENU DE DESEMPENHO ---

async def performance_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o painel de desempenho e lida com a sele√ß√£o de per√≠odo."""
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id
    
    callback_data = query.data
    now = datetime.now()
    start_dt, end_dt = None, None

    if callback_data == 'perf_today':
        start_dt = datetime.combine(now.date(), time.min)
        end_dt = now
    elif callback_data == 'perf_yesterday':
        yesterday = now.date() - timedelta(days=1)
        start_dt = datetime.combine(yesterday, time.min)
        end_dt = datetime.combine(yesterday, time.max)
    elif callback_data == 'perf_7_days':
        start_dt = datetime.combine(now.date() - timedelta(days=6), time.min)
        end_dt = now
    elif callback_data == 'perf_30_days':
        start_dt = datetime.combine(now.date() - timedelta(days=29), time.min)
        end_dt = now

    if start_dt and end_dt:
        await query.edit_message_text(
            text="‚è≥ Calculando desempenho para o per√≠odo selecionado...",
            reply_markup=performance_menu_keyboard()
        )
        
        report_text = await generate_performance_report(user_id, start_dt, end_dt)
        
        await query.edit_message_text(
            text=report_text,
            parse_mode='HTML',
            reply_markup=performance_menu_keyboard()
        )

# --- FLUXO DE CONFIGURA√á√ÉO DE WHITELIST ---

async def ask_coin_whitelist(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usu√°rio sua nova whitelist de moedas."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        current_whitelist = user.coin_whitelist if user else 'todas'
    finally:
        db.close()

    instructions = (
        f"<b>‚úÖ Whitelist de Moedas</b>\n\n"
        f"Sua configura√ß√£o atual √©: <code>{current_whitelist}</code>\n\n"
        f"Envie uma lista de moedas e/ou categorias separadas por v√≠rgula.\n\n"
        f"<b>Exemplos:</b>\n"
        f"‚Ä¢ <code>todas</code> (para operar todos os sinais)\n"
        f"‚Ä¢ <code>btcusdt, ethusdt, solusdt</code>\n"
        f"‚Ä¢ <code>memecoins, btcusdt</code> (opera moedas meme + BTC)\n\n"
        f"<b>Categorias dispon√≠veis:</b> <code>memecoins</code>, <code>altcoins</code>, <code>defi</code>."
    )
    
    await query.edit_message_text(text=instructions, parse_mode='HTML')
    return ASKING_COIN_WHITELIST

async def receive_coin_whitelist(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova whitelist."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    
    # Apaga a mensagem do usu√°rio para manter o chat limpo
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    # Normaliza a entrada: remove espa√ßos extras e converte para min√∫sculas
    whitelist_text = update.message.text.lower().strip()
    
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            user.coin_whitelist = whitelist_text
            db.commit()
            
            feedback_text = (
                f"‚úÖ Whitelist de moedas atualizada para: <code>{whitelist_text}</code>"
            )

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=feedback_text,
                parse_mode='HTML',
                reply_markup=settings_menu_keyboard(user)
            )
    finally:
        db.close()

    return ConversationHandler.END

========================================
# Arquivo: bot/keyboards.py
========================================

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from database.crud import get_user_by_id

def main_menu_keyboard(telegram_id: int):
    """
    Retorna o teclado do menu principal de forma inteligente,
    verificando o status do usu√°rio diretamente no banco de dados.
    """
    user = get_user_by_id(telegram_id)
    has_api_keys = user and user.api_key_encrypted is not None

    keyboard = []
    if has_api_keys:
        keyboard.append([InlineKeyboardButton("‚ÑπÔ∏è Meu Painel", callback_data='user_dashboard')])
        keyboard.append([InlineKeyboardButton("üìä Minhas Posi√ß√µes", callback_data='user_positions')])
        
        # --- BOT√ÉO ADICIONADO AQUI ---
        keyboard.append([InlineKeyboardButton("üìà Desempenho", callback_data='perf_today')])
        
        keyboard.append([InlineKeyboardButton("‚öôÔ∏è Configura√ß√µes de Trade", callback_data='user_settings')])
        keyboard.append([InlineKeyboardButton("ü§ñ Configura√ß√£o do Bot", callback_data='bot_config')])
    else:
        keyboard.append([InlineKeyboardButton("‚öôÔ∏è Configurar API Bybit", callback_data='config_api')])

    return InlineKeyboardMarkup(keyboard)

def dashboard_menu_keyboard():
    """Retorna o teclado para o painel do usu√°rio, com a op√ß√£o de remover a API."""
    keyboard = [
        [InlineKeyboardButton("üóëÔ∏è Remover API", callback_data='remove_api_prompt')],
        [InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def admin_menu_keyboard():
    """Retorna o teclado do menu de administrador."""
    keyboard = [
        [InlineKeyboardButton("üì° Listar Grupos/Canais", callback_data='admin_list_channels')],
        # --- NOVO BOT√ÉO ---
        [InlineKeyboardButton("üëÅÔ∏è Ver Alvos Ativos", callback_data='admin_view_targets')]
    ]
    return InlineKeyboardMarkup(keyboard)

def view_targets_keyboard():
    """Retorna o teclado para a tela de visualiza√ß√£o de alvos, com um bot√£o de voltar."""
    keyboard = [
        [InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu Admin", callback_data='back_to_admin_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def confirm_remove_keyboard():
    """Retorna o teclado de confirma√ß√£o para remover a API."""
    keyboard = [
        [InlineKeyboardButton("‚úÖ Sim, remover", callback_data='remove_api_confirm')],
        [InlineKeyboardButton("‚ùå N√£o, cancelar", callback_data='remove_api_cancel')],
    ]
    return InlineKeyboardMarkup(keyboard)

def settings_menu_keyboard(user_settings):
    """
    Retorna o teclado do menu de configura√ß√µes, mostrando os valores atuais.
    """
    entry_percent = user_settings.entry_size_percent
    max_leverage = user_settings.max_leverage
    min_confidence = user_settings.min_confidence

    keyboard = [
        [InlineKeyboardButton(f"Tamanho da Entrada: {entry_percent:.2f}%", callback_data='set_entry_percent')],
        [InlineKeyboardButton(f"Alavancagem M√°xima: {max_leverage}x", callback_data='set_max_leverage')],
        [InlineKeyboardButton(f"Confian√ßa M√≠nima (IA): {min_confidence:.2f}%", callback_data='set_min_confidence')],
        # --- ADICIONE O NOVO BOT√ÉO AQUI ---
        [InlineKeyboardButton("‚úÖ Whitelist de Moedas", callback_data='set_coin_whitelist')],
        [InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)


def bot_config_keyboard(user_settings):
    """
    Retorna o teclado para o menu de configura√ß√£o do bot, mostrando o modo de aprova√ß√£o e as metas.
    """
    # Bot√£o de Modo de Aprova√ß√£o (l√≥gica existente)
    mode = user_settings.approval_mode
    if mode == 'AUTOMATIC':
        approval_button_text = "Entrada de Sinais: Autom√°tico ‚ö°"
    else:
        approval_button_text = "Entrada de Sinais: Manual üëã"

    # --- NOVOS BOT√ïES DE METAS ---
    # Formata a meta de lucro para exibi√ß√£o
    profit_target = user_settings.daily_profit_target
    profit_text = f"Meta de Lucro Di√°ria: ${profit_target:.2f}" if profit_target > 0 else "Meta de Lucro Di√°ria: Desativada"

    # Formata o limite de perda para exibi√ß√£o
    loss_limit = user_settings.daily_loss_limit
    loss_text = f"Limite de Perda Di√°rio: ${loss_limit:.2f}" if loss_limit > 0 else "Limite de Perda Di√°rio: Desativado"

    keyboard = [
        [InlineKeyboardButton(approval_button_text, callback_data='toggle_approval_mode')],
        # --- NOVAS LINHAS ADICIONADAS AO TECLADO ---
        [InlineKeyboardButton(profit_text, callback_data='set_profit_target')],
        [InlineKeyboardButton(loss_text, callback_data='set_loss_limit')],
        [InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def signal_approval_keyboard(signal_for_approval_id: int):
    """
    Retorna o teclado com os bot√µes de Aprovar/Rejeitar para um sinal manual.
    """
    keyboard = [
        [
            InlineKeyboardButton("‚úÖ Aprovar Entrada", callback_data=f'approve_signal_{signal_for_approval_id}'),
            InlineKeyboardButton("‚ùå Rejeitar", callback_data=f'reject_signal_{signal_for_approval_id}')
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

def performance_menu_keyboard():
    """
    Retorna o teclado para o menu de an√°lise de desempenho com filtros de per√≠odo.
    """
    keyboard = [
        [
            InlineKeyboardButton("Hoje", callback_data='perf_today'),
            InlineKeyboardButton("Ontem", callback_data='perf_yesterday')
        ],
        [
            InlineKeyboardButton("√öltimos 7 Dias", callback_data='perf_7_days'),
            InlineKeyboardButton("√öltimos 30 Dias", callback_data='perf_30_days')
        ],
        [InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu Principal", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

========================================
# Arquivo: alembic/env.py
========================================

import os
import sys
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# Adiciona a raiz do projeto ao path para que possamos importar 'database.models'
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from database.models import Base

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # --- IN√çCIO DA MODIFICA√á√ÉO ---
    # Pega a configura√ß√£o do alembic.ini
    configuration = config.get_section(config.config_ini_section, {})
    # Tenta pegar a URL de uma vari√°vel de ambiente, se n√£o existir, usa a do .ini
    url = os.getenv('DATABASE_URL', configuration['sqlalchemy.url'])
    configuration['sqlalchemy.url'] = url
    
    connectable = engine_from_config(
        configuration, # Usa a configura√ß√£o modificada
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


========================================
# Arquivo: alembic/versions/09d80b6e64de_add_coin_whitelist_to_users.py
========================================

# Arquivo: alembic/versions/09d80b6e64de_add_coin_whitelist_to_users.py

"""add_coin_whitelist_to_users

Revision ID: 09d80b6e64de
Revises: 
Create Date: 2025-08-22 12:03:06.123456

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '09d80b6e64de'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('coin_whitelist', sa.String(), server_default='todas', nullable=False))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('users', 'coin_whitelist')
    # ### end Alembic commands ###

========================================
# Arquivo: services/__init__.py
========================================



========================================
# Arquivo: services/bybit_service.py
========================================

import logging
import asyncio
from typing import Dict, Any
from datetime import datetime, time, timedelta
from pybit.unified_trading import HTTP
from pybit.exceptions import InvalidRequestError
from database.models import User
from decimal import Decimal, ROUND_DOWN

logger = logging.getLogger(__name__)
INSTRUMENT_INFO_CACHE: Dict[str, Any] = {}

def _round_down_to_step(value: Decimal, step: Decimal) -> Decimal:
    # arredonda para baixo no m√∫ltiplo do step
    if step <= 0:
        return value
    return (value // step) * step

def _round_down_to_tick(price: Decimal, tick: Decimal) -> Decimal:
    if tick <= 0:
        return price
    return (price // tick) * tick

async def get_instrument_info(symbol: str) -> Dict[str, Any]:
    """
    Busca as regras de um instrumento (s√≠mbolo) da Bybit, usando um cache em mem√≥ria.
    Retorna um dicion√°rio com as regras ou um erro.
    """
    if symbol in INSTRUMENT_INFO_CACHE:
        return INSTRUMENT_INFO_CACHE[symbol]

    def _sync_call():
        try:
            session = HTTP(testnet=False)
            response = session.get_instruments_info(category="linear", symbol=symbol)
            
            if response.get("retCode") != 0:
                return {"success": False, "error": response.get("retMsg")}
            
            instrument_list = response.get("result", {}).get("list", [])
            if not instrument_list:
                return {"success": False, "error": f"S√≠mbolo {symbol} n√£o encontrado na Bybit."}

            info = instrument_list[0]
            lot_size_filter = info.get("lotSizeFilter", {})
            price_filter = info.get("priceFilter", {})

            rules = {
                "success": True,
                "status": info.get("status"),
                "qtyStep": Decimal(lot_size_filter.get("qtyStep", "0")),
                "minOrderQty": Decimal(lot_size_filter.get("minOrderQty", "0")),
                "minNotionalValue": Decimal(lot_size_filter.get("minOrderIv", "0")),
                "tickSize": Decimal(price_filter.get("tickSize", "0")),
            }
            INSTRUMENT_INFO_CACHE[symbol] = rules
            return rules
        except Exception as e:
            logger.error(f"Exce√ß√£o em get_instrument_info para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


# Fun√ß√£o auxiliar s√≠ncrona, n√£o precisa de 'async'
def get_session(api_key: str, api_secret: str) -> HTTP:
    """Cria e retorna uma sess√£o HTTP para ser usada em threads."""
    return HTTP(
        testnet=False,
        api_key=api_key,
        api_secret=api_secret
    )

async def get_account_info(api_key: str, api_secret: str) -> dict:
    """Busca o saldo da conta, retornando dados detalhados incluindo a lista de moedas."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.get_wallet_balance(accountType="UNIFIED")

            if response.get('retCode') == 0:
                account_data_list = response['result'].get('list', [])
                if not account_data_list:
                    return {"success": False, "data": {}, "error": "Lista de contas vazia na resposta da API."}
                
                account_data = account_data_list[0]
                
                equity_str = account_data.get('totalEquity')
                total_equity = float(equity_str) if equity_str else 0.0
                coin_list = account_data.get('coin', [])

                available_balance_usdt = 0.0
                for coin_balance in coin_list:
                    if coin_balance.get('coin') == 'USDT':
                        available_str = coin_balance.get('availableToWithdraw')
                        available_balance_usdt = float(available_str) if available_str else 0.0
                        break
                
                return {
                    "success": True, 
                    "data": {
                        "total_equity": total_equity,
                        "available_balance_usdt": available_balance_usdt,
                        "coin_list": coin_list  # <-- Retornando a lista completa
                    }
                }
            return {"success": False, "data": {}, "error": response.get('retMsg', 'Erro desconhecido')}
        except Exception as e:
            logger.error(f"Exce√ß√£o em get_account_info: {e}", exc_info=True)
            return {"success": False, "data": {}, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


async def place_order(api_key: str, api_secret: str, signal_data: dict, user_settings: User, balance: float) -> dict:
    """Abre uma nova posi√ß√£o a mercado (Market) com valida√ß√£o completa."""
    async def pre_flight_checks():
        symbol = signal_data['coin']
        if symbol not in INSTRUMENT_INFO_CACHE:
            await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            symbol = signal_data['coin']

            if not instrument_rules or not instrument_rules.get("success"):
                return instrument_rules or {"success": False, "error": f"Regras para {symbol} n√£o encontradas."}
            if instrument_rules["status"] != "Trading":
                return {"success": False, "error": f"O s√≠mbolo {symbol} n√£o est√° ativo para negocia√ß√£o ({instrument_rules['status']})."}

            session = get_session(api_key, api_secret)
            side = "Buy" if (signal_data.get('order_type') or '').upper() == 'LONG' else "Sell"
            leverage = Decimal(str(user_settings.max_leverage))
            entry_price = Decimal(str(signal_data['entries'][0]))
            margin_in_dollars = Decimal(str(balance)) * (Decimal(str(user_settings.entry_size_percent)) / Decimal("100"))
            notional_value = margin_in_dollars * leverage
            
            if entry_price <= 0: return {"success": False, "error": f"Pre√ßo de entrada inv√°lido: {entry_price}"}

            qty_raw = notional_value / entry_price
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])

            if qty_adj < instrument_rules["minOrderQty"]:
                return {"success": False, "error": f"Qtd. ajustada ({qty_adj:f}) √© menor que a m√≠nima permitida ({instrument_rules['minOrderQty']:f}) para {symbol}."}
            
            final_notional_value = qty_adj * entry_price
            if final_notional_value < instrument_rules["minNotionalValue"]:
                return {"success": False, "error": f"Valor total da ordem (${final_notional_value:.2f}) √© menor que o m√≠nimo permitido de ${instrument_rules['minNotionalValue']:.2f}."}

            # --- L√ìGICA CORRIGIDA ---
            payload = {
                "category": "linear", "symbol": symbol, "side": side,
                "orderType": "Market", "qty": str(qty_adj),
                "takeProfit": str((signal_data.get('targets') or [None])[0]),
                "stopLoss": str(signal_data.get('stop_loss')),
            }

            try:
                session.set_leverage(category="linear", symbol=symbol, buyLeverage=str(leverage), sellLeverage=str(leverage))
            except InvalidRequestError as e:
                if "leverage not modified" in str(e).lower():
                    logger.warning(f"Alavancagem para {symbol} j√° est√° correta. Continuando...")
                else:
                    return {"success": False, "error": str(e)} # Retorna outros erros de alavancagem

            response = session.place_order(**{k: v for k, v in payload.items() if v is not None})
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            return {"success": False, "error": response.get('retMsg')}
        
        except Exception as e:
            logger.error(f"Exce√ß√£o ao abrir ordem (Market): {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"Exce√ß√£o em place_order (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}


async def get_market_price(symbol: str) -> dict:
    """Busca o pre√ßo de mercado atual de forma ass√≠ncrona."""
    def _sync_call():
        try:
            session = HTTP(testnet=False)
            response = session.get_tickers(category="linear", symbol=symbol)
            if response.get('retCode') == 0 and response['result']['list']:
                price = float(response['result']['list'][0]['lastPrice'])
                return {"success": True, "price": price}
            else:
                return {"success": False, "error": response.get('retMsg', 'Pre√ßo n√£o encontrado')}
        except Exception as e:
            logger.error(f"Exce√ß√£o ao buscar pre√ßo de mercado para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def close_partial_position(api_key: str, api_secret: str, symbol: str, qty_to_close: float, side: str) -> dict:
    """Fecha parte de uma posi√ß√£o com Market/ReduceOnly, usando o novo sistema de regras."""
    async def pre_flight_checks():
        if symbol not in INSTRUMENT_INFO_CACHE:
            await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            # 1. VALIDA√á√ÉO DAS REGRAS
            if not instrument_rules or not instrument_rules.get("success"):
                return instrument_rules or {"success": False, "error": f"Regras para {symbol} n√£o encontradas."}

            session = get_session(api_key, api_secret)
            close_side = "Sell" if side == 'LONG' else "Buy"

            # 2. C√ÅLCULO DE QUANTIDADE
            qty_raw = Decimal(str(qty_to_close))
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])

            logger.info(f"[bybit_service] close_partial {symbol}: raw={qty_raw}, step={instrument_rules['qtyStep']}, minQty={instrument_rules['minOrderQty']} => adj={qty_adj}")

            if qty_adj < instrument_rules["minOrderQty"]:
                # Se a quantidade a ser fechada for menor que o m√≠nimo, ignoramos a opera√ß√£o
                # Isso n√£o √© um erro, apenas n√£o h√° o que fazer.
                logger.warning(f"Quantidade a fechar para {symbol} ({qty_adj:f}) √© menor que o m√≠nimo permitido. Ignorando fechamento parcial.")
                return {"success": True, "skipped": True, "reason": "qty_less_than_min_order_qty"}

            # 3. EXECU√á√ÉO
            response = session.place_order(
                category="linear", symbol=symbol, side=close_side,
                orderType="Market", qty=str(qty_adj), reduceOnly=True
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}

        except Exception as e:
            logger.error(f"Exce√ß√£o ao fechar posi√ß√£o parcial: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"Exce√ß√£o em close_partial_position (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}


async def modify_position_stop_loss(api_key: str, api_secret: str, symbol: str, new_stop_loss: float) -> dict:
    """Modifica o Stop Loss de uma posi√ß√£o aberta de forma ass√≠ncrona."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.set_trading_stop(
                category="linear", symbol=symbol, stopLoss=str(new_stop_loss)
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"Exce√ß√£o ao modificar Stop Loss: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def get_open_positions(api_key: str, api_secret: str) -> dict:
    return await get_open_positions_with_pnl(api_key, api_secret)

async def get_pnl_for_period(api_key: str, api_secret: str, start_time: datetime, end_time: datetime) -> dict:
    """Busca o P/L (Lucro/Preju√≠zo) realizado para um per√≠odo de tempo espec√≠fico."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            
            start_timestamp_ms = int(start_time.timestamp() * 1000)
            end_timestamp_ms = int(end_time.timestamp() * 1000)

            response = session.get_closed_pnl(
                category="linear",
                startTime=start_timestamp_ms,
                endTime=end_timestamp_ms,
                limit=200 # Aumentar o limite para buscar mais trades em per√≠odos longos
            )

            if response.get('retCode') == 0:
                pnl_list = response.get('result', {}).get('list', [])
                total_pnl = sum(float(item.get('closedPnl', 0)) for item in pnl_list)
                return {"success": True, "pnl": total_pnl}
            else:
                error_msg = response.get('retMsg', 'Erro desconhecido ao buscar P/L.')
                logger.error(f"Erro da API Bybit ao buscar P/L: {error_msg}")
                return {"success": False, "error": error_msg}

        except Exception as e:
            logger.error(f"Exce√ß√£o em get_pnl_for_period: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


async def get_daily_pnl(api_key: str, api_secret: str) -> dict:
    """Busca o P/L realizado para o dia atual (agora usa a fun√ß√£o gen√©rica)."""
    today_start = datetime.combine(datetime.today(), time.min)
    now = datetime.now()
    return await get_pnl_for_period(api_key, api_secret, today_start, now)


# --- FUN√á√ÉO PARA ENVIAR ORDEM LIMITE ---
async def place_limit_order(api_key: str, api_secret: str, signal_data: dict, user_settings: User, balance: float) -> dict:
    """Envia uma nova ordem limite para a Bybit com valida√ß√£o completa."""
    async def pre_flight_checks():
        symbol = signal_data['coin']
        if symbol not in INSTRUMENT_INFO_CACHE:
            await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            symbol = signal_data['coin']
            
            if not instrument_rules or not instrument_rules.get("success"):
                return instrument_rules or {"success": False, "error": f"Regras para {symbol} n√£o encontradas."}
            if instrument_rules["status"] != "Trading":
                return {"success": False, "error": f"O s√≠mbolo {symbol} n√£o est√° ativo para negocia√ß√£o ({instrument_rules['status']})."}

            session = get_session(api_key, api_secret)
            side = "Buy" if (signal_data.get('order_type') or '').upper() == 'LONG' else "Sell"
            leverage = Decimal(str(user_settings.max_leverage))
            price = Decimal(str(signal_data.get('limit_price')))
            price_adj = (price // instrument_rules["tickSize"]) * instrument_rules["tickSize"]
            margin_in_dollars = Decimal(str(balance)) * (Decimal(str(user_settings.entry_size_percent)) / Decimal("100"))
            notional_value = margin_in_dollars * leverage

            if price_adj <= 0: return {"success": False, "error": f"Pre√ßo de entrada inv√°lido ap√≥s ajuste: {price_adj}"}
            
            qty_raw = notional_value / price_adj
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])
            
            if qty_adj < instrument_rules["minOrderQty"]:
                return {"success": False, "error": f"Qtd. ajustada ({qty_adj:f}) √© menor que a m√≠nima permitida ({instrument_rules['minOrderQty']:f}) para {symbol}."}
            final_notional_value = qty_adj * price_adj
            if final_notional_value < instrument_rules["minNotionalValue"]:
                return {"success": False, "error": f"Valor total da ordem (${final_notional_value:.2f}) √© menor que o m√≠nimo permitido de ${instrument_rules['minNotionalValue']:.2f}."}

            # --- L√ìGICA CORRIGIDA ---
            payload = {
                "category": "linear", "symbol": symbol, "side": side,
                "orderType": "Limit", "qty": str(qty_adj), "price": str(price_adj),
                "takeProfit": str((signal_data.get('targets') or [None])[0]),
                "stopLoss": str(signal_data.get('stop_loss')),
            }

            try:
                session.set_leverage(category="linear", symbol=symbol, buyLeverage=str(leverage), sellLeverage=str(leverage))
            except InvalidRequestError as e:
                if "leverage not modified" in str(e).lower():
                    logger.warning(f"Alavancagem para {symbol} j√° est√° correta. Continuando...")
                else:
                    return {"success": False, "error": str(e)}

            response = session.place_order(**{k: v for k, v in payload.items() if v is not None})
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            return {"success": False, "error": response.get('retMsg')}

        except Exception as e:
            logger.error(f"Exce√ß√£o ao abrir ordem (Limit): {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"Exce√ß√£o em place_limit_order (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}


# --- FUN√á√ÉO PARA VERIFICAR STATUS DE UMA ORDEM ---
async def get_order_status(api_key: str, api_secret: str, order_id: str, symbol: str) -> dict:
    """Verifica o status de uma ordem espec√≠fica na Bybit, procurando em ordens abertas."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            # --- CORRE√á√ÉO: MUDAMOS PARA get_open_orders ---
            response = session.get_open_orders(
                category="linear",
                symbol=symbol,
                orderId=order_id,
            )
            if response.get('retCode') == 0:
                order_list = response.get('result', {}).get('list', [])
                if order_list:
                    # A ordem foi encontrada na lista de ordens abertas
                    return {"success": True, "data": order_list[0]}
                else:
                    # Se n√£o est√° nas ordens abertas, pode j√° ter sido executada ou cancelada.
                    # Por seguran√ßa, vamos verificar o hist√≥rico tamb√©m.
                    hist_response = session.get_order_history(category="linear", orderId=order_id)
                    if hist_response.get('retCode') == 0:
                        hist_list = hist_response.get('result', {}).get('list', [])
                        if hist_list:
                            return {"success": True, "data": hist_list[0]}
                    
                    return {"success": False, "error": "Ordem n√£o encontrada nem nas abertas nem no hist√≥rico."}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"Exce√ß√£o ao verificar status da ordem: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)


# --- FUN√á√ÉO PARA CANCELAR UMA ORDEM ---
async def cancel_order(api_key: str, api_secret: str, order_id: str, symbol: str) -> dict:
    """Cancela uma ordem limite pendente na Bybit."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.cancel_order(
                category="linear",
                symbol=symbol,
                orderId=order_id
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"Exce√ß√£o ao cancelar ordem: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

# --- PNL FECHADO (PERFORMANCE) ---
async def get_closed_pnl_breakdown(api_key: str, api_secret: str, start_time: datetime, end_time: datetime) -> dict:
    """
    Retorna o P/L total e contagem de ganhos/perdas no per√≠odo informado.
    Usa o endpoint oficial de closed PnL e pagina os resultados se o per√≠odo for > 7 dias.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)

            total_pnl = 0.0
            total_wins = 0
            total_losses = 0
            all_items = []

            current_start = start_time

            while current_start < end_time:
                # Calcula o fim da janela atual, limitado a 7 dias ou ao fim do per√≠odo total
                current_end = min(current_start + timedelta(days=7), end_time)

                logger.info(f"[bybit_service] Buscando PnL de {current_start.strftime('%Y-%m-%d')} a {current_end.strftime('%Y-%m-%d')}")

                resp = session.get_closed_pnl(
                    category="linear",
                    startTime=int(current_start.timestamp() * 1000),
                    endTime=int(current_end.timestamp() * 1000),
                    limit=200,
                )

                if resp.get("retCode") != 0:
                    error_msg = resp.get("retMsg", f"Erro desconhecido na pagina√ß√£o de PnL (start={current_start})")
                    logger.error(f"Erro da API Bybit em get_closed_pnl_breakdown: {error_msg}")
                    # Retorna o erro da primeira falha
                    return {"success": False, "error": error_msg}

                items = resp.get("result", {}).get("list", []) or []
                all_items.extend(items)

                # Avan√ßa o in√≠cio da pr√≥xima janela
                current_start += timedelta(days=7)

            # Processa a lista completa de itens coletados
            for it in all_items:
                pnl = float(it.get("closedPnl", 0) or 0)
                total_pnl += pnl
                if pnl > 0:
                    total_wins += 1
                elif pnl < 0:
                    total_losses += 1

            return {
                "success": True,
                "total_pnl": total_pnl,
                "wins": total_wins,
                "losses": total_losses,
                "trades": len(all_items),
            }
        except Exception as e:
            logger.error(f"Exce√ß√£o em get_closed_pnl_breakdown: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


# --- POSI√á√ïES ABERTAS COM PNL ATUAL ---
async def get_open_positions_with_pnl(api_key: str, api_secret: str) -> dict:
    """
    Lista posi√ß√µes abertas com avgPrice, markPrice e P/L atual (valor e %).
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            resp = session.get_positions(category="linear", settleCoin="USDT")
            if resp.get("retCode") != 0:
                return {"success": False, "error": resp.get("retMsg", "erro")}
            out = []
            for p in (resp.get("result", {}).get("list", []) or []):
                size = float(p.get("size", 0) or 0)
                if size <= 0:
                    continue
                symbol = p.get("symbol")
                side = "LONG" if (p.get("side") == "Buy") else "SHORT"
                entry = float(p.get("avgPrice", 0) or 0)
                mark = float((p.get("markPrice") or 0) or 0)
                # se mark vier 0, tenta buscar via tickers
                if not mark and symbol:
                    try:
                        t = session.get_tickers(category="linear", symbol=symbol)
                        mark = float(t["result"]["list"][0]["lastPrice"])
                    except Exception:
                        pass
                if not entry or not mark:
                    # n√£o d√° pra calcular PnL sem pre√ßo
                    pnl = 0.0
                    pnl_pct = 0.0
                else:
                    diff = (mark - entry) if side == "LONG" else (entry - mark)
                    pnl = diff * size
                    pnl_pct = (diff / entry) * 100.0 if entry else 0.0
                out.append({
                    "symbol": symbol,
                    "side": side,
                    "size": size,
                    "entry": entry,
                    "mark": mark,
                    "unrealized_pnl": pnl,
                    "unrealized_pnl_pct": pnl_pct,
                })
            return {"success": True, "data": out}
        except Exception as e:
            logger.error(f"Exce√ß√£o em get_open_positions_with_pnl: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

# Adicione esta nova fun√ß√£o em services/bybit_service.py
# Pode ser adicionada ap√≥s a fun√ß√£o modify_position_stop_loss

async def get_specific_position_size(api_key: str, api_secret: str, symbol: str) -> float:
    """
    Busca o tamanho (size) de uma posi√ß√£o espec√≠fica aberta na Bybit.
    Retorna 0.0 se a posi√ß√£o n√£o existir.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            # Usamos o filtro de s√≠mbolo para buscar apenas a posi√ß√£o de interesse
            response = session.get_positions(category="linear", symbol=symbol)
            
            if response.get('retCode') == 0:
                position_list = response.get('result', {}).get('list', [])
                if position_list and position_list[0]:
                    # Retorna o tamanho da primeira (e √∫nica) posi√ß√£o na lista
                    return float(position_list[0].get('size', 0.0))
            # Se a lista estiver vazia ou houver erro, a posi√ß√£o n√£o existe ou n√£o foi encontrada
            return 0.0
        except Exception as e:
            logger.error(f"Exce√ß√£o em get_specific_position_size para {symbol}: {e}", exc_info=True)
            return 0.0 # Em caso de erro, assumimos que n√£o h√° posi√ß√£o para evitar fechamentos indevidos

    return await asyncio.to_thread(_sync_call)

========================================
# Arquivo: services/notification_service.py
========================================

import logging
from telegram.ext import Application
from utils.config import ADMIN_ID

logger = logging.getLogger(__name__)

async def send_notification(application: Application, message: str):
    """
    Envia uma mensagem de notifica√ß√£o para o administrador do bot.
    """
    if not application:
        logger.warning("Tentativa de enviar notifica√ß√£o sem a inst√¢ncia da aplica√ß√£o.")
        return
    try:
        await application.bot.send_message(
            chat_id=ADMIN_ID,
            text=message,
            parse_mode='HTML'
        )
        logger.info(f"Notifica√ß√£o enviada para o admin: {message[:50]}...")
    except Exception as e:
        logger.error(f"Falha ao enviar notifica√ß√£o para o admin: {e}")

========================================
# Arquivo: services/signal_parser.py
========================================

import re
import logging
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)

# --- DEFINI√á√ÉO CENTRALIZADA DOS TIPOS DE SINAL ---
class SignalType:
    MARKET = 'MARKET'
    LIMIT = 'LIMIT'
    CANCELAR = 'CANCELAR'


# -----------------------
# Helpers de normaliza√ß√£o
# -----------------------
_FLOAT = r'[-+]?\d+(?:[.,]\d+)?'

def _to_float(x: str) -> float:
    """Converte string com v√≠rgula ou ponto para float."""
    if x is None:
        return 0.0
    x = x.strip().replace(' ', '').replace(',', '.')
    # remove percentuais e s√≠mbolos residuais
    x = re.sub(r'[^0-9.+-]', '', x)
    try:
        return float(x)
    except Exception:
        return 0.0

def _normalize_symbol(coin_raw: str) -> str:
    coin = (coin_raw or '').strip().upper()
    # remove emojis e lixo
    coin = re.sub(r'[^A-Z0-9]', '', coin)
    # alguns sinais usam par completo (ex.: AVAXUSDT)
    if coin.endswith('USDT') or coin.endswith('USD'):
        return coin if coin.endswith('USDT') else f'{coin}T'  # USD -> USDT (fail-safe)
    return f'{coin}USDT' if coin else coin

def _pick_first_number(text: str) -> Optional[float]:
    m = re.search(_FLOAT, text)
    return _to_float(m.group(0)) if m else None

def _findall_numbers(text: str) -> List[float]:
    return [_to_float(g) for g in re.findall(_FLOAT, text or '')]


# ----------------------------------------------------
# Padr√µes de alto n√≠vel (ordem importa: espec√≠ficos 1¬∫)
# ----------------------------------------------------
CANCEL_PATTERN = re.compile(r'‚ö†Ô∏è\s*([A-Za-z0-9]+)[^\n]*sinal\s*cancelad[oa]', re.IGNORECASE)

# ‚ÄúOrdem Limite‚Äù / ‚ÄúOrdem a/√† Mercado‚Äù podem aparecer em qualquer lugar
IS_MARKET_PATTERN = re.compile(r'Ordem\s*(?:√†|a)?\s*Mercado', re.IGNORECASE)
IS_LIMIT_PATTERN  = re.compile(r'Ordem\s*Limite', re.IGNORECASE)

# Verificador de ‚Äúsinal completo‚Äù
FULL_SIGNAL_GUARD = re.compile(r'(?=.*(?:Moeda|Coin|Pair)\s*:)(?=.*Tipo\s*:)(?=.*Stop\s*Loss\s*:)', re.IGNORECASE | re.DOTALL)


# ---------------------------
# Extrator de sinal ‚Äúcompleto‚Äù
# ---------------------------
def _full_signal_extractor(message_text: str) -> Optional[Dict[str, Any]]:

    def find_single_value(pattern: str, text: str) -> Optional[str]:
        # Usa .*? para pular emojis e r√≥tulos adicionais na linha
        m = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
        return m.group(1).strip() if m else None

    # --- Campos b√°sicos ---
    coin_raw = find_single_value(r'(?:Moeda|Coin|Pair)\s*:\s*([A-Za-z0-9 ._-]+)', message_text)
    order_type_raw = find_single_value(r'Tipo\s*:\s*([A-Za-z ]+)', message_text)
    entry_raw = find_single_value(r'Zona\s*de\s*Entrada\s*:\s*([^\n\r]+)', message_text)
    sl_raw = find_single_value(r'Stop\s*Loss\s*:\s*([^\n\r]+)', message_text)

    # targets: T1:, T2:, ...
    targets = []
    for tlabel, val in re.findall(r'(?:^|\n)\s*T(\d+)\s*:\s*([^\n\r]+)', message_text, flags=re.IGNORECASE):
        n = _pick_first_number(val)
        if n is not None:
            targets.append(n)

    # confian√ßa (se existir)
    conf_raw = find_single_value(r'Confian[√ßc]a\s*:\s*([0-9.,]+)\s*%', message_text)
    confidence = _to_float(conf_raw) if conf_raw else None

    # normaliza√ß√µes
    coin = _normalize_symbol(coin_raw or '')
    order_type = 'LONG'
    if order_type_raw:
        if 'SHORT' in order_type_raw.upper():
            order_type = 'SHORT'
        elif 'LONG' in order_type_raw.upper():
            order_type = 'LONG'

    # entradas
    entries: List[float] = []
    if entry_raw:
        nums = _findall_numbers(entry_raw)
        # muitos sinais colocam "x - y"; se s√≥ tem um n√∫mero, trata como lista √∫nica
        if len(nums) == 1:
            entries = [nums[0]]
        elif len(nums) >= 2:
            entries = [nums[0], nums[1]]
        else:
            entries = []

    # stop
    stop_loss = _pick_first_number(sl_raw or '') or 0.0

    # --- Determina√ß√£o do tipo (MARKET x LIMIT) ---
    # 1) texto expl√≠cito
    is_market_text = bool(IS_MARKET_PATTERN.search(message_text))
    is_limit_text  = bool(IS_LIMIT_PATTERN.search(message_text))

    # 2) heur√≠stica: ‚Äúentrada √∫nica‚Äù OU faixa id√™ntica => MARKET
    entries_imply_market = False
    if entries:
        if len(entries) == 1:
            entries_imply_market = True
        elif len(entries) >= 2 and abs(entries[0] - entries[1]) < 1e-10:
            entries_imply_market = True

    # decis√£o final
    if is_market_text or (not is_limit_text and entries_imply_market):
        signal_kind = SignalType.MARKET
        # para MARKET garantimos entries[0] preenchida (usa o primeiro n√∫mero visto no bloco de entrada)
        if not entries and entry_raw:
            n = _pick_first_number(entry_raw)
            entries = [n] if n is not None else []
    else:
        signal_kind = SignalType.LIMIT

    if not coin or not entries or stop_loss == 0.0:
        logger.debug("Parser: campos essenciais ausentes: coin=%s entries=%s stop=%s", coin, entries, stop_loss)
        return None

    return {
        "type": signal_kind,
        "coin": coin,
        "order_type": order_type,          # LONG | SHORT
        "entries": entries,                # [pre√ßo] ou [min, max]
        "stop_loss": stop_loss,
        "targets": targets,                # [t1, t2, ...]
        "confidence": confidence,          # opcional (float ou None)
    }


# -----------------
# Fun√ß√£o de entrada
# -----------------
def parse_signal(message_text: str) -> Optional[Dict[str, Any]]:
    """
    Identifica e extrai sinais:
      - CANCELAMENTO: '‚ö†Ô∏è <COIN> ... sinal cancelad(o/a)'
      - ENTRADA COMPLETA: campos Moeda/Coin/Pair, Tipo, Stop Loss (com 'Ordem Limite' ou 'Ordem √† Mercado')
    Retorna um dicion√°rio com os campos normalizados ou None se n√£o reconhecer.
    """
    if not message_text or not isinstance(message_text, str):
        return None

    text = message_text.strip()

    # 1) Cancelamento
    m_cancel = CANCEL_PATTERN.search(text)
    if m_cancel:
        coin = _normalize_symbol(m_cancel.group(1))
        return {"type": SignalType.CANCELAR, "coin": coin}

    # 2) Sinal de entrada (guarda)
    if not FULL_SIGNAL_GUARD.search(text):
        return None

    data = _full_signal_extractor(text)
    return data

========================================
# Arquivo: services/telethon_service.py
========================================

import logging
import asyncio
import os
import re
from telegram.ext import Application
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telethon.sync import TelegramClient
from telethon import events
from telethon.errors.rpcerrorlist import ChannelForumMissingError, ChannelInvalidError
from telethon.tl.functions.channels import GetForumTopicsRequest
from utils.config import API_ID, API_HASH
from database.session import SessionLocal
from database.models import MonitoredTarget
from .signal_parser import parse_signal

logger = logging.getLogger(__name__)

# --- L√ìGICA DE CAMINHO DIN√ÇMICO ---
if os.path.isdir('/data'):
    SESSION_PATH = '/data/tradeflow_user'
else:
    SESSION_PATH = 'tradeflow_user'

# --- DEFINI√á√ÉO √öNICA E CORRETA DO CLIENTE ---
client = TelegramClient(SESSION_PATH, API_ID, API_HASH)
comm_queue = None
# Cache em mem√≥ria para armazenar os IDs das mensagens j√° processadas e evitar duplicidade.
PROCESSED_MESSAGE_IDS = set()


# --- Fun√ß√µes de Busca (Helpers) ---

def get_monitored_targets():
    """Busca no DB a lista de todos os alvos (canal/t√≥pico) monitorados."""
    db = SessionLocal()
    try:
        return db.query(MonitoredTarget).all()
    finally:
        db.close()

async def list_channels():
    """Lista todos os canais e supergrupos com logging detalhado."""
    logger.info("[list_channels] Iniciando busca de di√°logos...")
    channels = []
    count = 0
    try:
        async for dialog in client.iter_dialogs():
            count += 1
            if count % 50 == 0:
                logger.info(f"[list_channels] ... processou {count} di√°logos...")
            
            if dialog.is_channel:
                channels.append((dialog.name, dialog.id))
        
        logger.info(f"[list_channels] Busca de di√°logos finalizada. Total de {count} di√°logos processados.")
    except Exception as e:
        logger.error(f"[list_channels] Erro durante iter_dialogs: {e}", exc_info=True)
        
    return channels

async def list_channel_topics(channel_id: int):
    """Busca os t√≥picos de um canal espec√≠fico."""
    topics = []
    try:
        entity = await client.get_entity(channel_id)
        result = await client(GetForumTopicsRequest(
            channel=entity, offset_date=0, offset_id=0, offset_topic=0, limit=100
        ))
        for topic in result.topics:
            topics.append((topic.title, topic.id))
            
    except (ChannelForumMissingError, ChannelInvalidError):
        logger.warning(f"Canal {channel_id} n√£o possui t√≥picos (n√£o √© um f√≥rum).")
        
    except Exception as e:
        logger.error(f"Exce√ß√£o em list_channel_topics para o canal {channel_id}: {e}", exc_info=True)
        
    return topics

# --- Listener de Sinais ---
# Em vez de filtrar por regex no decorator, ouvimos TUDO e deixamos o parser decidir.
from telethon import events

@client.on(events.NewMessage)          # novas mensagens
@client.on(events.MessageEdited)       # mensagens editadas (muitos canais editam depois)
async def signal_listener(event):
    """
    Ouve TODAS as mensagens nos canais/grupos e:
      - loga que chegou
      - decide se √© alvo monitorado
      - tenta parsear
      - loga '√© sinal' ou 'n√£o √© sinal'
      - se for sinal, coloca na fila para processamento
    """
    global comm_queue

    # sanity checks
    if not isinstance(event, (events.NewMessage.Event, events.MessageEdited.Event)):
        return
    if not comm_queue:
        return

    # texto bruto (mais robusto do que event.text em alguns casos)
    text = (getattr(event, "raw_text", None)
            or getattr(getattr(event, "message", None), "message", None)
            or "")
    chat_id = getattr(event, "chat_id", None)
    message_id = getattr(getattr(event, "message", None), "id", None)
    topic_id = event.reply_to.reply_to_msg_id if getattr(event, "reply_to", None) else None

    # LOG: sempre que chega algo
    preview = text.replace("\n", " ")[:120]
    logger.info(f"üì® [Telethon] Mensagem recebida | chat_id={chat_id} | msg_id={message_id} | preview={preview!r}")

    # Verifica se √© um alvo monitorado (canal/t√≥pico)
    monitored_targets = get_monitored_targets()
    if not monitored_targets:
        logger.info("‚è≠Ô∏è [Telethon] N√£o h√° alvos monitorados configurados.")
        return

    is_target = any(
        (t.channel_id == chat_id and ((t.topic_id is None and topic_id is None) or t.topic_id == topic_id))
        for t in monitored_targets
    )
    if not is_target:
        logger.info(f"‚è≠Ô∏è [Telethon] Mensagem fora dos alvos monitorados (chat_id={chat_id}, topic_id={topic_id}).")
        return

    # Evita duplicidade apenas quando J√Å identificamos como sinal
    if message_id in PROCESSED_MESSAGE_IDS:
        logger.info(f"‚è≠Ô∏è [Telethon] Mensagem {message_id} j√° processada anteriormente. Ignorando duplicata/edi√ß√£o.")
        return

    # Tenta parsear
    from services.signal_parser import parse_signal  # import local p/ evitar ciclos
    parsed = parse_signal(text)

    if parsed:
        logger.info(
            "‚úÖ [Telethon] √â sinal! "
            f"type={parsed.get('type')} coin={parsed.get('coin')} "
            f"order={parsed.get('order_type')} entries={parsed.get('entries')} sl={parsed.get('stop_loss')}"
        )
        # marca como processado s√≥ quando for SINAL
        if message_id is not None:
            PROCESSED_MESSAGE_IDS.add(message_id)

        # Enfileira para o processador com um source_name informativo
        await comm_queue.put({
            "action": "process_signal",
            "signal_text": text,
            "source_name": f"telegram:{chat_id}"
        })
    else:
        logger.debug("‚è≠Ô∏è [Telethon] Chegou mensagem aqui - n√£o √© sinal.")

# --- Processador da Fila ---

async def queue_processor(queue: asyncio.Queue, ptb_app: Application):
    """Processa pedidos da fila, agora passando o 'source_name' adiante."""
    global comm_queue
    comm_queue = queue
    from core.trade_manager import process_new_signal

    while True:
        request = await queue.get()
        action = request.get("action")
        logger.info(f"[Queue Processor] ==> Pedido recebido! A√ß√£o: '{action}'")
        
        try:
            if action == "list_channels":
                logger.info("[Queue Processor] ... Entrou no bloco de 'list_channels'.")
                chat_id = request.get("chat_id")
                message_id = request.get("message_id")
                channels = await list_channels()
                db = SessionLocal()
                monitored_channels_ids = {target.channel_id for target in db.query(MonitoredTarget).all()}
                db.close()
                keyboard = []
                
                if channels:
                    for channel_name, channel_id in channels:
                        suffix = " ‚úÖ" if channel_id in monitored_channels_ids else ""
                        keyboard.append([InlineKeyboardButton(f"{channel_name}{suffix}", callback_data=f"monitor_channel_{channel_id}")])
                
                if keyboard:
                    await ptb_app.bot.edit_message_text(
                        chat_id=chat_id, message_id=message_id,
                        text="Selecione um grupo/canal (‚úÖ = algum monitoramento ativo):",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    await ptb_app.bot.edit_message_text(chat_id=chat_id, message_id=message_id, text="Nenhum canal ou supergrupo encontrado.")

            elif action == "list_topics":
                logger.info("[Queue Processor] ... Entrou no bloco de 'list_topics'.")
                channel_id = request.get("channel_id")
                chat_id = request.get("chat_id")
                message_id = request.get("message_id")
                channel_name = request.get("channel_name")
                
                topics = await list_channel_topics(channel_id)
                db = SessionLocal()
                
                try:
                    if topics:
                        monitored_topic_ids = {t.topic_id for t in db.query(MonitoredTarget).filter_by(channel_id=channel_id).all() if t.topic_id}
                        keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è Voltar para Grupos", callback_data="admin_list_channels")]]
                        for name, topic_id in topics:
                            suffix = " ‚úÖ" if topic_id in monitored_topic_ids else ""
                            keyboard.append([InlineKeyboardButton(f"{name}{suffix}", callback_data=f"monitor_topic_{channel_id}_{topic_id}")])
                        
                        await ptb_app.bot.edit_message_text(
                            chat_id=chat_id, message_id=message_id,
                            text="Selecione o t√≥pico para monitorar (‚úÖ = j√° monitorado):",
                            reply_markup=InlineKeyboardMarkup(keyboard)
                        )
                    else:
                        existing = db.query(MonitoredTarget).filter_by(channel_id=channel_id, topic_id=None).first()
                        if existing:
                            db.delete(existing)
                            feedback_msg = f"‚ùå Canal '{channel_name}' removido da lista de monitoramento."
                        else:
                            new_target = MonitoredTarget(channel_id=channel_id, channel_name=channel_name)
                            db.add(new_target)
                            feedback_msg = f"‚úÖ Canal '{channel_name}' adicionado √† lista de monitoramento."
                        
                        db.commit()
                        await ptb_app.bot.edit_message_text(chat_id=chat_id, message_id=message_id, text=feedback_msg)
                finally:
                    db.close()

            elif action == "process_signal":
                logger.info("[Queue Processor] ... Entrou no bloco de 'process_signal'.")
                signal_text = request.get("signal_text")
                source_name = request.get("source_name", "Fonte Desconhecida")
                
                signal_data = parse_signal(signal_text)
                if signal_data:
                    await process_new_signal(signal_data, ptb_app, source_name)
                else:
                    logger.info("Mensagem da fila n√£o √© um sinal v√°lido.")
            
            else:
                logger.warning(f"[Queue Processor] A√ß√£o desconhecida ou nula recebida: '{action}'")

        except Exception as e:
            logger.error(f"Erro CR√çTICO no processador da fila ao manusear a a√ß√£o '{action}': {e}", exc_info=True)
        finally:
            queue.task_done()
            logger.info(f"[Queue Processor] <== Pedido '{action}' finalizado.")

# --- Fun√ß√£o Principal do Servi√ßo ---

async def start_signal_monitor(queue: asyncio.Queue):
    """Inicia o cliente Telethon, o ouvinte de sinais e o processador da fila."""
    logger.info("Iniciando monitor de sinais com Telethon...")
    
    await client.start()
    
    ptb_app = await queue.get()

    logger.info("‚úÖ Monitor de sinais e processador de fila ativos.")
    
    asyncio.create_task(queue_processor(queue, ptb_app))
    
    await client.run_until_disconnected()

