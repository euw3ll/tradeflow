========================================
# Arquivo: Dockerfile
========================================

# Usa uma imagem oficial do Python como base
FROM python:3.11-slim

# Define o diretório de trabalho dentro do container
WORKDIR /app

# Copia o arquivo de dependências primeiro
COPY requirements.txt .

# Instala as dependências do Python
RUN pip install --no-cache-dir -r requirements.txt

# Copia todo o resto do código do projeto
COPY . .

# Comando que será executado quando o container iniciar, usando o script simplificado
CMD ["./start.sh"]

========================================
# Arquivo: main.py
========================================

import logging
import asyncio
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, 
    ConversationHandler, CallbackQueryHandler
)
from utils.config import TELEGRAM_TOKEN
from bot.handlers import (
    start, receive_invite_code, cancel, WAITING_CODE,
    config_api, receive_api_key, receive_api_secret, WAITING_API_KEY, WAITING_API_SECRET,
    remove_api_prompt, remove_api_action, CONFIRM_REMOVE_API,
    my_positions_handler, user_dashboard_handler, user_settings_handler,
    back_to_main_menu_handler,
    ask_entry_percent, receive_entry_percent, ASKING_ENTRY_PERCENT,
    ask_max_leverage, receive_max_leverage, ASKING_MAX_LEVERAGE,
    ask_min_confidence, receive_min_confidence, ASKING_MIN_CONFIDENCE,
    admin_menu, list_channels_handler, select_channel_to_monitor, select_topic_to_monitor,
    manual_close_handler, admin_view_targets_handler, back_to_admin_menu_handler,
    bot_config_handler, toggle_approval_mode_handler, handle_signal_approval, 
    ask_profit_target, receive_profit_target, ASKING_PROFIT_TARGET,
    ask_loss_limit, receive_loss_limit, ASKING_LOSS_LIMIT, 
    ask_coin_whitelist, receive_coin_whitelist, ASKING_COIN_WHITELIST,
    performance_menu_handler
)
from database.session import init_db
from services.telethon_service import start_signal_monitor
from core.position_tracker import run_tracker

# --- Configuração do Logging ---
logging.basicConfig(
    format="%(asctime)s - [%(levelname)s] - %(name)s - %(message)s",
    level=logging.INFO
)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("telegram").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)

async def run_ptb(application: Application, queue: asyncio.Queue):
    """Inicializa e roda a aplicação python-telegram-bot."""
    application.bot_data['comm_queue'] = queue
    logger.info("Inicializando o bot do Telegram (PTB)...")
    await application.initialize()
    await application.start()
    await application.updater.start_polling()
    logger.info("✅ Bot do Telegram (PTB) ativo.")

async def main():
    """Configura os handlers e inicia o PTB e o Telethon em paralelo."""
    init_db()
    comm_queue = asyncio.Queue()
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    await comm_queue.put(application)

    # --- Handlers de Conversa ---
    register_conv = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={ WAITING_CODE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_invite_code)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    api_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(config_api, pattern='^config_api$')],
        states={
            WAITING_API_KEY: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_api_key)],
            WAITING_API_SECRET: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_api_secret)],
        },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    remove_api_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(remove_api_prompt, pattern='^remove_api_prompt$')],
        states={ CONFIRM_REMOVE_API: [CallbackQueryHandler(remove_api_action, pattern='^remove_api_confirm|remove_api_cancel$')] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    settings_entry_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_entry_percent, pattern='^set_entry_percent$')],
        states={ ASKING_ENTRY_PERCENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_entry_percent)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    settings_leverage_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_max_leverage, pattern='^set_max_leverage$')],
        states={ ASKING_MAX_LEVERAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_max_leverage)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    settings_confidence_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_min_confidence, pattern='^set_min_confidence$')],
        states={ ASKING_MIN_CONFIDENCE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_min_confidence)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    profit_target_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_profit_target, pattern='^set_profit_target$')],
        states={ ASKING_PROFIT_TARGET: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_profit_target)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    loss_limit_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_loss_limit, pattern='^set_loss_limit$')],
        states={ ASKING_LOSS_LIMIT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_loss_limit)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    whitelist_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_coin_whitelist, pattern='^set_coin_whitelist$')],
        states={ ASKING_COIN_WHITELIST: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_coin_whitelist)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )

    # Adicionando todos os handlers
    application.add_handler(register_conv)
    application.add_handler(api_conv)
    application.add_handler(remove_api_conv)
    application.add_handler(settings_entry_conv)
    application.add_handler(settings_leverage_conv)
    application.add_handler(settings_confidence_conv)
    application.add_handler(profit_target_conv)
    application.add_handler(loss_limit_conv)
    application.add_handler(whitelist_conv)
    
    application.add_handler(CommandHandler("admin", admin_menu))
    application.add_handler(CallbackQueryHandler(list_channels_handler, pattern='^admin_list_channels$'))
    application.add_handler(CallbackQueryHandler(select_channel_to_monitor, pattern='^monitor_channel_'))
    application.add_handler(CallbackQueryHandler(select_topic_to_monitor, pattern='^monitor_topic_'))
    application.add_handler(CallbackQueryHandler(admin_view_targets_handler, pattern='^admin_view_targets$'))
    application.add_handler(CallbackQueryHandler(back_to_admin_menu_handler, pattern='^back_to_admin_menu$'))

    application.add_handler(CommandHandler("start", start))
    
    application.add_handler(CallbackQueryHandler(my_positions_handler, pattern='^user_positions$'))
    application.add_handler(CallbackQueryHandler(user_settings_handler, pattern='^user_settings$'))
    application.add_handler(CallbackQueryHandler(user_dashboard_handler, pattern='^user_dashboard$'))
    application.add_handler(CallbackQueryHandler(back_to_main_menu_handler, pattern='^back_to_main_menu$'))
    application.add_handler(CallbackQueryHandler(manual_close_handler, pattern='^manual_close_'))

    application.add_handler(CallbackQueryHandler(performance_menu_handler, pattern='^perf_'))

    application.add_handler(CallbackQueryHandler(bot_config_handler, pattern='^bot_config$'))
    application.add_handler(CallbackQueryHandler(toggle_approval_mode_handler, pattern='^toggle_approval_mode$'))

    application.add_handler(CallbackQueryHandler(handle_signal_approval, pattern=r'^(approve_signal_|reject_signal_)'))


    logger.info("Bot configurado. Iniciando todos os serviços...")

    await asyncio.gather(
        run_ptb(application, comm_queue),
        start_signal_monitor(comm_queue),
        run_tracker(application)
    )

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Bot desligado pelo usuário.")
    except Exception as e:
        logger.critical(f"Erro crítico não tratado: {e}", exc_info=True)

========================================
# Arquivo: start.sh
========================================

#!/bin/sh

echo "Aplicando migrações do banco de dados..."
# Este comando garante que o DB esteja sempre na versão mais recente
alembic upgrade head

echo "Iniciando o bot TradeFlow..."
python main.py

========================================
# Arquivo: database/__init__.py
========================================



========================================
# Arquivo: database/crud.py
========================================

from .session import SessionLocal
from .models import User

def get_user_by_id(telegram_id: int):
    """Busca um usuário no banco de dados pelo seu ID do Telegram."""
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == telegram_id).first()
        return user
    finally:
        db.close()

========================================
# Arquivo: database/models.py
========================================

from sqlalchemy import (Column, Integer, String, BigInteger, Boolean, Float, JSON, DateTime, UniqueConstraint)
from sqlalchemy.orm import declarative_base
from sqlalchemy.sql import func

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)
    first_name = Column(String)
    api_key_encrypted = Column(String)
    api_secret_encrypted = Column(String)
    entry_size_percent = Column(Float, default=5.0)
    max_leverage = Column(Integer, default=10)
    min_confidence = Column(Float, default=0.0)
    approval_mode = Column(String, default='AUTOMATIC', nullable=False)
    daily_profit_target = Column(Float, default=0.0, nullable=False)
    daily_loss_limit = Column(Float, default=0.0, nullable=False)
    # ADICIONE A LINHA ABAIXO
    coin_whitelist = Column(String, default='todas', nullable=False)

class InviteCode(Base):
    __tablename__ = 'invite_codes'
    id = Column(Integer, primary_key=True)
    code = Column(String, unique=True, nullable=False)
    is_used = Column(Boolean, default=False)

class MonitoredTarget(Base):
    __tablename__ = 'monitored_targets'
    id = Column(Integer, primary_key=True)
    channel_id = Column(BigInteger, nullable=False)
    channel_name = Column(String)
    topic_id = Column(BigInteger, unique=True, nullable=True)
    topic_name = Column(String)

class Trade(Base):
    __tablename__ = 'trades'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False)
    order_id = Column(String, unique=True, nullable=False)
    symbol = Column(String, nullable=False)
    side = Column(String, nullable=False)
    qty = Column(Float, nullable=False)
    entry_price = Column(Float)
    stop_loss = Column(Float)
    current_stop_loss = Column(Float)
    initial_targets = Column(JSON)
    status = Column(String, default='ACTIVE')
    remaining_qty = Column(Float)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class PendingSignal(Base):
    __tablename__ = 'pending_signals'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False, index=True)
    
    # --- MUDANÇA APLICADA AQUI ---
    # Removemos o unique=True do symbol
    symbol = Column(String, nullable=False, index=True) 
    
    order_id = Column(String, unique=True, nullable=False)
    signal_data = Column(JSON, nullable=False)

    # Adicionamos uma restrição de unicidade composta
    __table_args__ = (UniqueConstraint('user_telegram_id', 'symbol', name='_user_symbol_uc'),)

class SignalForApproval(Base):
    __tablename__ = 'signals_for_approval'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False, index=True)
    symbol = Column(String, nullable=False)
    source_name = Column(String)
    signal_data = Column(JSON, nullable=False)
    approval_message_id = Column(BigInteger)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

========================================
# Arquivo: database/session.py
========================================

import os # Importa a biblioteca 'os'
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from .models import Base

# --- LÓGICA DE CAMINHO DINÂMICO ---
if os.path.isdir('/data'):
    # Caminho para o banco de dados no servidor Fly.io
    DATABASE_URL = "sqlite:////data/tradeflow.db"
else:
    # Caminho para o banco de dados local (no seu Mac)
    DATABASE_URL = "sqlite:///./tradeflow.db"

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def init_db():
    Base.metadata.create_all(bind=engine)

========================================
# Arquivo: core/__init__.py
========================================



========================================
# Arquivo: core/performance_service.py
========================================

# imports no topo
from services.bybit_service import get_closed_pnl_breakdown
from utils.security import decrypt_data
from database.session import SessionLocal
from database.models import Trade, User
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

async def generate_performance_report(user_id: int, start_dt: datetime, end_dt: datetime) -> str:
    """
    Gera relatório do período usando o closed PnL da Bybit (fonte de verdade)
    e mostra contagem de ganhos/perdas e hit rate. Usa DB apenas como apoio.
    """
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if not user or not user.api_key_encrypted:
            return "Você precisa ter uma chave de API configurada para ver o desempenho financeiro."

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # dados oficiais da corretora
        br = await get_closed_pnl_breakdown(api_key, api_secret, start_dt, end_dt)
        if not br.get("success"):
            logger.error(f"get_closed_pnl_breakdown falhou: {br.get('error')}")
            return "Não foi possível calcular seu desempenho agora."

        total = br["total_pnl"]
        wins = br["wins"]
        losses = br["losses"]
        trades = br["trades"]
        hit_rate = (wins / trades * 100.0) if trades else 0.0

        # (opcional) também buscamos no DB só para exibir um “Total de Trades” local, se quiser
        closed_trades_db = db.query(Trade).filter(
            Trade.user_telegram_id == user_id,
            Trade.status.like('%CLOSED%'),
            Trade.created_at >= start_dt,
            Trade.created_at <= end_dt
        ).count()

        lucro_str = f"📈 <b>Lucro:</b> ${total:.2f}" if total >= 0 else f"📉 <b>Prejuízo:</b> ${abs(total):.2f}"

        msg = (
            f"<b>📊 Desempenho do Período</b>\n"
            f"<i>De {start_dt:%d/%m/%Y} a {end_dt:%d/%m/%Y}</i>\n\n"
            f"{lucro_str}\n\n"
            f"📊 <b>Taxa de Acerto:</b> {hit_rate:.2f}%\n"
            f"📦 <b>Total de Trades:</b> {trades} "
            f"(local: {closed_trades_db})\n"
            f"  - Ganhos: {wins}\n"
            f"  - Perdas: {losses}\n"
        )
        return msg

    except Exception as e:
        logger.error(f"Erro ao gerar relatório de performance para {user_id}: {e}", exc_info=True)
        return "Ocorreu um erro ao gerar seu relatório."
    finally:
        db.close()


========================================
# Arquivo: core/position_tracker.py
========================================

import asyncio
import logging
from telegram.ext import Application
from sqlalchemy.orm import Session
from database.session import SessionLocal
from database.models import Trade, User, PendingSignal
from services.bybit_service import (
    get_market_price, close_partial_position,
    modify_position_stop_loss, get_order_status,
    get_specific_position_size # <-- ADICIONE ESTA LINHA
)
# Mantemos o send_notification se você usar em outros pontos (aqui focamos em mensagem individual)
from services.notification_service import send_notification
from utils.security import decrypt_data

logger = logging.getLogger(__name__)


async def check_pending_orders_for_user(application: Application, user: User, db: Session):
    """Verifica as ordens limite pendentes de UM usuário específico."""
    pending_orders = db.query(PendingSignal).filter_by(user_telegram_id=user.telegram_id).all()
    if not pending_orders:
        return

    logger.info(f"Rastreador: Verificando {len(pending_orders)} ordem(ns) pendente(s) para o usuário {user.telegram_id}.")
    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)

    for order in pending_orders:
        status_result = await get_order_status(api_key, api_secret, order.order_id, order.symbol)
        if not status_result.get("success"):
            logger.error(
                f"Falha ao obter status da ordem {order.order_id} "
                f"para o usuário {user.telegram_id}: {status_result.get('error')}"
            )
            continue

        order_data = status_result["data"] or {}
        order_status = (order_data.get("orderStatus") or "").strip()

        if order_status == 'Filled':
            logger.info(f"Ordem Limite {order.order_id} EXECUTADA para o usuário {user.telegram_id}.")
            signal_data = order.signal_data or {}

            # Fallbacks robustos
            avg_price = order_data.get('avgPrice')
            if avg_price:
                entry_price = float(avg_price)
            else:
                # usa limit_price salvo no signal_data (trade_manager já injeta) ou a 1ª entry
                entry_price = float(signal_data.get('limit_price') or signal_data.get('entries', [0])[0])

            cum_exec_qty = float(order_data.get('cumExecQty', 0.0))
            if cum_exec_qty <= 0:
                # Segurança: se por algum motivo a exchange marcou Filled mas qty veio 0,
                # tratamos como cancelado para não criar Trade inconsistente.
                logger.warning(
                    f"[tracker] Ordem {order.order_id} marcada como Filled, "
                    f"mas cumExecQty=0. Removendo ordem pendente sem criar Trade."
                )
                db.delete(order)
                await application.bot.send_message(
                    chat_id=user.telegram_id,
                    text=(
                        f"ℹ️ Sua ordem limite para <b>{order.symbol}</b> foi finalizada na corretora, "
                        f"mas sem execução reportada. Removida do monitoramento."
                    ),
                    parse_mode='HTML'
                )
                continue

            new_trade = Trade(
                user_telegram_id=order.user_telegram_id,
                order_id=order.order_id,
                symbol=signal_data.get('coin', order.symbol),
                side=signal_data.get('order_type'),
                qty=cum_exec_qty,
                entry_price=entry_price,
                stop_loss=signal_data.get('stop_loss'),
                current_stop_loss=signal_data.get('stop_loss'),
                initial_targets=signal_data.get('targets') or [],
                status='ACTIVE',
                remaining_qty=cum_exec_qty
            )
            db.add(new_trade)
            db.delete(order)
            await application.bot.send_message(
                chat_id=user.telegram_id,
                text=(
                    f"📈 <b>Ordem Limite Executada!</b>\n"
                    f"<b>Moeda:</b> {order.symbol}\n"
                    f"<b>Preço médio:</b> {entry_price}"
                ),
                parse_mode='HTML'
            )

        elif order_status in {'Cancelled', 'Deactivated', 'Rejected'}:
            logger.info(f"Ordem Limite {order.order_id} do usuário {user.telegram_id} foi '{order_status}'. Removendo.")
            db.delete(order)
            await application.bot.send_message(
                chat_id=user.telegram_id,
                text=(
                    f"ℹ️ Sua ordem limite para <b>{order.symbol}</b> foi "
                    f"'<b>{order_status}</b>' pela corretora e removida do monitoramento."
                ),
                parse_mode='HTML'
            )
        else:
            # Estados como 'New', 'PartiallyFilled', etc.: apenas seguir monitorando.
            logger.debug(
                f"[tracker] Ordem {order.order_id} estado='{order_status}' para {user.telegram_id}. "
                f"Seguir monitorando."
            )


async def check_active_trades_for_user(application: Application, user: User, db: Session):
    """Verifica e gerencia os trades ativos de UM usuário específico."""
    active_trades = db.query(Trade).filter(
        Trade.user_telegram_id == user.telegram_id,
        ~Trade.status.like('%CLOSED%')
    ).all()
    if not active_trades:
        return

    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)

    for trade in active_trades:
        live_position_size = await get_specific_position_size(api_key, api_secret, trade.symbol)
        if live_position_size <= 0:
            logger.info(f"[tracker] Posição fantasma detectada para {trade.symbol}. Marcando como fechada.")
            trade.status = 'CLOSED_GHOST'
            trade.remaining_qty = 0.0
            continue

        price_result = await get_market_price(trade.symbol)
        if not price_result.get("success"):
            continue

        current_price = price_result["price"]
        reached_tp = False

        # --- TAKE PROFIT ---
        if trade.initial_targets:
            next_target_price = trade.initial_targets[0]
            if (trade.side == 'LONG' and current_price >= next_target_price) or \
               (trade.side == 'SHORT' and current_price <= next_target_price):
                
                qty_to_close = live_position_size if len(trade.initial_targets) == 1 else (live_position_size / 2.0)
                close_result = await close_partial_position(api_key, api_secret, trade.symbol, qty_to_close, trade.side)

                if close_result.get("success") and not close_result.get("skipped"):
                    # --- NOVA LÓGICA DE NOTIFICAÇÃO DE LUCRO ---
                    profit = (next_target_price - trade.entry_price) * qty_to_close if trade.side == 'LONG' else (trade.entry_price - next_target_price) * qty_to_close
                    
                    # Atualiza o trade no DB
                    trade.remaining_qty = live_position_size - qty_to_close
                    remaining_targets = trade.initial_targets[1:]
                    trade.initial_targets = remaining_targets
                    
                    message_text = ""
                    if not remaining_targets or trade.remaining_qty <= 0.00001:
                        trade.status = 'CLOSED_PROFIT'
                        message_text = (
                            f"🏆 <b>Último Alvo Atingido! (LUCRO)</b> 🏆\n"
                            f"<b>Moeda:</b> {trade.symbol}\n"
                            f"<b>Lucro Realizado:</b> ${profit:,.2f}\n\n"
                            f"A posição foi completamente fechada."
                        )
                    else:
                        trade.status = 'ACTIVE_TP_HIT'
                        message_text = (
                            f"💰 <b>Take Profit Atingido! (LUCRO)</b>\n"
                            f"<b>Moeda:</b> {trade.symbol}\n"
                            f"<b>Lucro Parcial:</b> ${profit:,.2f}\n"
                            f"<b>Alvos Restantes:</b> {len(remaining_targets)}"
                        )
                    
                    await application.bot.send_message(chat_id=user.telegram_id, text=message_text, parse_mode='HTML')
                    reached_tp = True

        # --- STOP LOSS ---
        if not reached_tp:
            stop_hit = (
                (trade.side == 'LONG' and current_price <= trade.current_stop_loss) or
                (trade.side == 'SHORT' and current_price >= trade.current_stop_loss)
            )
            if stop_hit:
                # --- NOVA LÓGICA DE NOTIFICAÇÃO DE PREJUÍZO ---
                loss = (trade.current_stop_loss - trade.entry_price) * live_position_size if trade.side == 'LONG' else (trade.entry_price - trade.current_stop_loss) * live_position_size
                
                trade.status = 'CLOSED_LOSS'
                trade.remaining_qty = 0.0

                message_text = (
                    f"🛑 <b>Stop Loss Atingido (PREJUÍZO)</b>\n"
                    f"<b>Moeda:</b> {trade.symbol}\n"
                    f"<b>Prejuízo Realizado:</b> ${loss:,.2f}\n\n"
                    f"A posição foi completamente fechada."
                )
                await application.bot.send_message(chat_id=user.telegram_id, text=message_text, parse_mode='HTML')



async def run_tracker(application: Application):
    """Função principal que roda o verificador em loop para TODOS os usuários."""
    logger.info("Iniciando Rastreador de Posições e Ordens (Modo Multiusuário)...")
    while True:
        db = SessionLocal()
        try:
            all_users = db.query(User).filter(User.api_key_encrypted.isnot(None)).all()
            if not all_users:
                logger.info("Rastreador: Nenhum usuário com API para verificar.")
            else:
                logger.info(f"Rastreador: Verificando assets para {len(all_users)} usuário(s).")
                for user in all_users:
                    await check_pending_orders_for_user(application, user, db)
                    await check_active_trades_for_user(application, user, db)

                # commit das modificações (Trades atualizados, remoção de Pending, etc.)
                db.commit()

        except Exception as e:
            logger.critical(f"Erro crítico no loop do rastreador: {e}", exc_info=True)
            db.rollback()
        finally:
            db.close()

        await asyncio.sleep(60)


========================================
# Arquivo: core/trade_manager.py
========================================

import os
import logging
from typing import Tuple
from telegram.ext import Application
from sqlalchemy.orm import Session
from database.session import SessionLocal
from database.models import User, Trade, PendingSignal, SignalForApproval
from services.bybit_service import (
    place_order, get_account_info,
    place_limit_order, cancel_order
)
from services.notification_service import send_notification
from utils.security import decrypt_data
from utils.config import ADMIN_ID
from bot.keyboards import signal_approval_keyboard
from services.signal_parser import SignalType
from core.whitelist_service import is_coin_in_whitelist

logger = logging.getLogger(__name__)


def _avaliar_sinal(signal_data: dict, user_settings: User) -> Tuple[bool, str]:
    min_confidence = user_settings.min_confidence
    signal_confidence = signal_data.get('confidence', 0.0)
    if signal_confidence is not None and signal_confidence < min_confidence:
        motivo = f"Confiança ({signal_confidence:.2f}%) é menor que o seu mínimo ({min_confidence:.2f}%)"
        return False, motivo
    return True, "Sinal aprovado pelos seus critérios."

async def _execute_trade(signal_data: dict, user: User, application: Application, db: Session, source_name: str):
    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)
    
    account_info = await get_account_info(api_key, api_secret)
    if not account_info.get("success"):
        await application.bot.send_message(chat_id=user.telegram_id, text=f"❌ Falha ao buscar seu saldo Bybit para operar {signal_data['coin']}.")
        return

    balance_data = account_info.get("data", {})
    balance = float(balance_data.get('available_balance', 0))
    result = await place_order(api_key, api_secret, signal_data, user, balance)
    
    if result.get("success"):
        order_data = result['data']
        order_id = order_data['orderId']
        new_trade = Trade(
            user_telegram_id=user.telegram_id, order_id=order_id,
            symbol=signal_data['coin'], side=signal_data['order_type'],
            qty=float(order_data.get('qty', 0)), entry_price=signal_data['entries'][0],
            stop_loss=signal_data['stop_loss'], current_stop_loss=signal_data['stop_loss'],
            initial_targets=signal_data['targets'], status='ACTIVE',
            remaining_qty=float(order_data.get('qty', 0))
        )
        db.add(new_trade)
        logger.info(f"Trade {order_id} para o usuário {user.telegram_id} salvo no DB.")
        await application.bot.send_message(chat_id=user.telegram_id, text=f"📈 <b>Ordem Aberta com Sucesso!</b>\n<b>Moeda:</b> {signal_data['coin']}", parse_mode='HTML')
    else:
        error_msg = result.get('error')
        await application.bot.send_message(chat_id=user.telegram_id, text=f"❌ <b>Falha ao Abrir Ordem</b>\n<b>Moeda:</b> {signal_data['coin']}\n<b>Motivo:</b> {error_msg}", parse_mode='HTML')


async def execute_signal_for_all_users(signal_data: dict, application: Application, db: Session, source_name: str):
    signal_type = signal_data.get("type")
    symbol = signal_data.get("coin")

    all_users_to_trade = db.query(User).filter(User.api_key_encrypted.isnot(None)).all()
    if not all_users_to_trade:
        logger.info("Nenhum usuário com API configurada para replicar o trade.")
        return

    logger.info(f"Sinal ({signal_type}) aprovado. Replicando para {len(all_users_to_trade)} usuário(s)...")

    for user in all_users_to_trade:
        if not is_coin_in_whitelist(symbol, user.coin_whitelist):
            logger.info(f"Sinal para {symbol} ignorado para o usuário {user.telegram_id} devido à sua whitelist ('{user.coin_whitelist}').")
            # Opcional: notificar o usuário que o sinal foi ignorado
            # await application.bot.send_message(chat_id=user.telegram_id, text=f"ℹ️ Sinal para {symbol} ignorado devido à sua whitelist.")
            continue # Pula para o próximo usuário
        if signal_type == SignalType.MARKET:
            await _execute_trade(signal_data, user, application, db, source_name)
        elif signal_type == SignalType.LIMIT:
            existing_pending = db.query(PendingSignal).filter_by(user_telegram_id=user.telegram_id, symbol=symbol).first()
            if existing_pending:
                await application.bot.send_message(
                    chat_id=user.telegram_id,
                    text=f"ℹ️ Você já tem uma ordem limite pendente para <b>{symbol}</b>. O novo sinal foi ignorado.",
                    parse_mode='HTML'
                )
                continue

            # ---- NOVO: escolher um único preço para a ordem limite ----
            entries = (signal_data.get('entries') or [])[:2]
            if not entries:
                await application.bot.send_message(
                    chat_id=user.telegram_id,
                    text=f"❌ Sinal LIMIT para <b>{symbol}</b> sem preços de entrada válidos.",
                    parse_mode='HTML'
                )
                continue

            if len(entries) == 1:
                limit_price = float(entries[0])
            else:
                lo = float(min(entries[0], entries[1]))
                hi = float(max(entries[0], entries[1]))
                if (signal_data.get('order_type') or '').upper() == 'LONG':
                    limit_price = lo   # LONG -> comprar no mais baixo da faixa
                else:
                    limit_price = hi   # SHORT -> vender no mais alto da faixa

            # injeta no payload para a bybit_service
            signal_data_with_price = dict(signal_data)
            signal_data_with_price['limit_price'] = limit_price
            # -----------------------------------------------------------

            user_api_key = decrypt_data(user.api_key_encrypted)
            user_api_secret = decrypt_data(user.api_secret_encrypted)

            account_info = await get_account_info(user_api_key, user_api_secret)
            if not account_info.get("success"):
                await application.bot.send_message(
                    chat_id=user.telegram_id,
                    text=f"❌ Falha ao buscar seu saldo Bybit para posicionar LIMIT em <b>{symbol}</b>.",
                    parse_mode='HTML'
                )
                continue

            balance_data = account_info.get("data", {})
            balance = float(balance_data.get('available_balance', 0))

            # >>> IMPORTANTE: agora enviamos signal_data_with_price <<<
            limit_order_result = await place_limit_order(user_api_key, user_api_secret, signal_data_with_price, user, balance)

            if limit_order_result.get("success"):
                order_id = limit_order_result["data"]["orderId"]
                db.add(PendingSignal(
                    user_telegram_id=user.telegram_id,
                    symbol=symbol,
                    order_id=order_id,
                    signal_data=signal_data_with_price
                ))
                await application.bot.send_message(
                    chat_id=user.telegram_id,
                    text=(
                        f"✅ Ordem <b>Limite</b> posicionada para <b>{symbol}</b> ({signal_data.get('order_type')}).\n"
                        f"🎯 Preço: <b>{limit_price}</b>\n"
                        f"🛑 Stop: <b>{signal_data.get('stop_loss')}</b>\n"
                        f"👀 Monitorando a execução…"
                    ),
                    parse_mode='HTML'
                )
            else:
                error = limit_order_result.get('error') or limit_order_result
                await application.bot.send_message(
                    chat_id=user.telegram_id,
                    text=f"❌ Falha ao posicionar sua ordem limite para <b>{symbol}</b>.\n<b>Motivo:</b> {error}",
                    parse_mode='HTML'
                )
    db.commit()

async def process_new_signal(signal_data: dict, application: Application, source_name: str):
    """
    Processa apenas sinais de ENTRADA e CANCELAMENTO, ignorando todos os outros.
    """
    signal_type = signal_data.get("type")
    symbol = signal_data.get("coin")
    db = SessionLocal()
    try:
        # --- LÓGICA DE CANCELAMENTO ---
        if signal_type == SignalType.CANCELAR:
            logger.info(f"Recebido sinal de cancelamento para {symbol}.")
            pending_orders = db.query(PendingSignal).filter_by(symbol=symbol).all()
            if not pending_orders:
                await send_notification(application, f"ℹ️ Recebido sinal de cancelamento para <b>{symbol}</b>, mas nenhuma ordem pendente foi encontrada.")
                return
            
            for order in pending_orders:
                user_keys = db.query(User).filter_by(telegram_id=order.user_telegram_id).first()
                if not user_keys: continue
                api_key = decrypt_data(user_keys.api_key_encrypted)
                api_secret = decrypt_data(user_keys.api_secret_encrypted)
                cancel_result = await cancel_order(api_key, api_secret, order.order_id, symbol)
                if cancel_result.get("success"):
                    await application.bot.send_message(chat_id=order.user_telegram_id, text=f"✅ Sua ordem limite para <b>{symbol}</b> foi cancelada com sucesso.", parse_mode='HTML')
                    db.delete(order)
                else:
                    await application.bot.send_message(chat_id=order.user_telegram_id, text=f"⚠️ Falha ao cancelar sua ordem limite para <b>{symbol}</b>.", parse_mode='HTML')
            db.commit()
            return

        # --- LÓGICA DE SINAIS DE ENTRADA ---
        elif signal_type in [SignalType.MARKET, SignalType.LIMIT]:
            admin_user = db.query(User).filter_by(telegram_id=ADMIN_ID).first()
            if not admin_user or not admin_user.api_key_encrypted:
                logger.error("Admin não configurado, não é possível processar sinais de entrada.")
                return

            aprovado, motivo = _avaliar_sinal(signal_data, admin_user)
            if not aprovado:
                await send_notification(application, f"ℹ️ Sinal para {symbol} ignorado pelo admin: {motivo}")
                return
            
            if admin_user.approval_mode == 'AUTOMATIC':
                await execute_signal_for_all_users(signal_data, application, db, source_name)
            
            elif admin_user.approval_mode == 'MANUAL':
                logger.info(f"Modo MANUAL. Enviando sinal ({signal_type}) de entrada para aprovação do Admin.")
                
                new_signal_for_approval = SignalForApproval(
                    user_telegram_id=ADMIN_ID, symbol=symbol,
                    source_name=source_name, signal_data=signal_data
                )
                db.add(new_signal_for_approval)
                db.commit()

                signal_details = (
                    f"<b>Sinal ({signal_type}) de: {source_name}</b>\n\n<b>Moeda:</b> {signal_data['coin']}\n"
                    f"<b>Tipo:</b> {signal_data['order_type']}\n<b>Entrada:</b> {signal_data['entries'][0]}\n"
                    f"<b>Stop:</b> {signal_data['stop_loss']}\n<b>Alvo 1:</b> {signal_data['targets'][0]}\n\n"
                    f"O sinal passou nos seus filtros. Você aprova a entrada?"
                )
                sent_message = await application.bot.send_message(
                    chat_id=ADMIN_ID, text=signal_details, parse_mode='HTML',
                    reply_markup=signal_approval_keyboard(new_signal_for_approval.id)
                )
                new_signal_for_approval.approval_message_id = sent_message.message_id
                db.commit()
        else:
            logger.info(f"Sinal do tipo '{signal_type}' recebido e ignorado conforme a estratégia de autonomia.")
            
    finally:
        db.close()

========================================
# Arquivo: core/whitelist_service.py
========================================

import logging
from typing import Set

logger = logging.getLogger(__name__)

# --- CATEGORIAS DE MOEDAS ---
# Estas listas podem ser expandidas no futuro. Usamos Sets para performance.

# Moedas de grande capitalização e projetos estabelecidos (excluindo BTC e ETH)
ALTCOINS_L1_L2: Set[str] = {
    'SOLUSDT', 'XRPUSDT', 'ADAUSDT', 'AVAXUSDT', 'DOTUSDT', 'MATICUSDT',
    'LINKUSDT', 'TRXUSDT', 'ATOMUSDT', 'NEARUSDT', 'APTUSDT', 'OPUSDT',
    'ARBUSDT', 'LDOUSDT', 'SUIUSDT'
}

# Moedas relacionadas a Finanças Descentralizadas
DEFI: Set[str] = {
    'UNIUSDT', 'AAVEUSDT', 'MKRUSDT', 'SNXUSDT', 'COMPUSDT', 'CRVUSDT',
    'SUSHIUSDT', 'YFIUSDT'
}

# Moedas de "memes" com alta volatilidade
MEMECOINS: Set[str] = {
    'DOGEUSDT', 'SHIBUSDT', 'PEPEUSDT', 'WIFUSDT', 'FLOKIUSDT', 'BONKUSDT'
}

# Dicionário que mapeia a palavra-chave da categoria para o Set de moedas
CATEGORIES = {
    'altcoins': ALTCOINS_L1_L2,
    'defi': DEFI,
    'memecoins': MEMECOINS,
}

def is_coin_in_whitelist(symbol: str, user_whitelist_str: str) -> bool:
    """
    Verifica se um símbolo de moeda está na whitelist de um usuário.

    A whitelist pode conter:
    - O keyword 'todas'.
    - Símbolos específicos (ex: 'btcusdt').
    - Keywords de categorias (ex: 'memecoins').
    """
    if not user_whitelist_str or 'todas' in user_whitelist_str.lower():
        return True

    # Normaliza a entrada do usuário: minúsculas, remove espaços, divide por vírgula
    user_list = {item.strip() for item in user_whitelist_str.lower().split(',')}
    
    # 1. Verifica se o símbolo exato está na lista do usuário
    if symbol.lower() in user_list:
        return True

    # 2. Verifica se alguma das categorias da lista do usuário contém o símbolo
    for category_keyword in user_list:
        if category_keyword in CATEGORIES and symbol in CATEGORIES[category_keyword]:
            return True
            
    # Se nenhuma das condições acima for atendida, a moeda não está na whitelist
    return False

========================================
# Arquivo: tests/__init__.py
========================================



========================================
# Arquivo: tests/test_signal_cyber_e2e.py
========================================

# tests/test_signal_cyber_e2e.py
import sys
import types
import textwrap
import pytest

# ======== STUBS mínimos (telegram e keyboards) ========
telegram = types.ModuleType("telegram")
telegram_ext = types.ModuleType("telegram.ext")
telegram_constants = types.ModuleType("telegram.constants")

class InlineKeyboardButton:
    def __init__(self, text, callback_data=None, url=None):
        self.text = text; self.callback_data = callback_data; self.url = url

class InlineKeyboardMarkup:
    def __init__(self, keyboard): self.keyboard = keyboard

class Application:
    def __init__(self): self.bot = None

telegram.InlineKeyboardButton = InlineKeyboardButton
telegram.InlineKeyboardMarkup = InlineKeyboardMarkup
telegram.constants = telegram_constants
telegram_ext.Application = Application

sys.modules.setdefault("telegram", telegram)
sys.modules.setdefault("telegram.ext", telegram_ext)
sys.modules.setdefault("telegram.constants", telegram_constants)

bot_pkg = types.ModuleType("bot")
bot_keyboards = types.ModuleType("bot.keyboards")
def signal_approval_keyboard(signal_id: int):
    return InlineKeyboardMarkup([[InlineKeyboardButton("Aprovar", callback_data=f"approve:{signal_id}")]])
bot_keyboards.signal_approval_keyboard = signal_approval_keyboard
sys.modules.setdefault("bot", bot_pkg)
sys.modules.setdefault("bot.keyboards", bot_keyboards)

# ======== Imports reais do projeto ========
from services.signal_parser import parse_signal, SignalType
import core.trade_manager as tm

# ======== Fakes utilitários ========
class FakeUser:
    def __init__(self, telegram_id=111, api_key_encrypted="enc_k", api_secret_encrypted="enc_s"):
        self.telegram_id = telegram_id
        self.api_key_encrypted = api_key_encrypted
        self.api_secret_encrypted = api_secret_encrypted

class _QueryList:
    def __init__(self, data_list): self._data = data_list
    def filter(self, *a, **k): return self
    def filter_by(self, **k):
        def ok(obj): return all(getattr(obj, kk, None) == vv for kk, vv in k.items())
        return _QueryList([x for x in self._data if ok(x)])
    def all(self): return list(self._data)
    def first(self): return self._data[0] if self._data else None

class FakeDB:
    def __init__(self, users=None, pendings=None):
        self._users = users or []
        self._pendings = pendings or []
        self.added = []; self.deleted = []; self.commits = 0
    def query(self, Model):
        if Model is tm.User: return _QueryList(self._users)
        if Model is tm.PendingSignal: return _QueryList(self._pendings)
        return _QueryList([])
    def add(self, obj):
        self.added.append(obj)
        if isinstance(obj, tm.PendingSignal) or getattr(obj, "__class__", None).__name__ == "DummyPending":
            self._pendings.append(obj)
    def delete(self, obj):
        self.deleted.append(obj)
        if obj in self._pendings: self._pendings.remove(obj)
    def commit(self): self.commits += 1

class FakeBot:
    def __init__(self): self.sent = []
    async def send_message(self, **kwargs): self.sent.append(kwargs)

class FakeApplication(Application):
    def __init__(self): super().__init__(); self.bot = FakeBot()

# ======== Sinal CYBER (LIMIT/SHORT) ========
CYBER_SIGNAL = textwrap.dedent("""
⏳ #38792 - Ordem Limite

💎 Moeda: CYBER
📊 Tipo: SHORT (Futures)

💰 Zona de Entrada: 2.52500000 - 2.64000000
🛑 Stop Loss: 2.90000000 (12.2943%)
🎯 Alvos:
T1: 2.44000000 (5.52%)
T2: 2.37000000 (8.23%)
T3: 2.29000000 (11.33%)
T4: 2.20000000 (14.81%)
""")

@pytest.mark.asyncio
async def test_cyber_limit_short_positions_limit_order(monkeypatch):
    parsed = parse_signal(CYBER_SIGNAL)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "SHORT"
    assert parsed["coin"] == "CYBERUSDT"
    assert parsed["entries"] == [2.525, 2.64]
    assert parsed["stop_loss"] == 2.9

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=777)])

    # dummy PendingSignal para não depender de SQLAlchemy real
    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    # Capturas
    called = {"market": False, "limit_payload": None}

    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        # guardamos o payload passado — deve conter limit_price = 2.64
        called["limit_payload"] = dict(signal_data)
        return {"success": True, "data": {"orderId": "CYB-LIM-001"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "123.45"}]}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    # patches
    monkeypatch.setattr(tm, "place_order", fake_place_order)  # não deve ser chamado
    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # 1) NÃO abriu a mercado
    assert not called["market"], "LIMIT/SHORT não deve abrir ordem a mercado"

    # 2) Chamou limit com limit_price = 2.64 (maior da faixa)
    assert called["limit_payload"] is not None, "place_limit_order não foi chamado"
    assert called["limit_payload"].get("limit_price") == pytest.approx(2.64, rel=1e-6)

    # 3) Criou PendingSignal
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal não foi criado"

    # 4) Enviou mensagem ao usuário
    assert app.bot.sent, "Nenhuma mensagem foi enviada ao usuário"
    texts = [m.get("text", "").lower() for m in app.bot.sent]
    assert any("limite" in t or "monitorando" in t for t in texts), texts


========================================
# Arquivo: tests/test_signal_parser.py
========================================

import textwrap

from services.signal_parser import parse_signal, SignalType


def test_parse_signal_without_diamond():
    message = textwrap.dedent(
        """
        ⏳ #1 - Ordem Limite
        Moeda: SOL
        Tipo: SHORT (Futures)
        Zona de Entrada: 182.66 - 182.66
        Stop Loss: 186.36
        Alvos:
        T1: 181.18
        """
    )

    data = parse_signal(message)

    assert data["coin"] == "SOLUSDT"
    assert data["type"] == SignalType.LIMIT


def test_parse_signal_with_coin_synonym():
    message = textwrap.dedent(
        """
        ⏳ #2 - Ordem Limite
        Coin: NMR
        Tipo: SHORT (Futures)
        Zona de Entrada: 8.04 - 8.28
        Stop Loss: 8.55
        Alvos:
        T1: 7.99
        """
    )

    data = parse_signal(message)

    assert data["coin"] == "NMRUSDT"
    assert data["type"] == SignalType.LIMIT


def test_parse_complex_signal_with_emojis_and_extra_text():
    message = textwrap.dedent(
        """
        ⏳ #38792 - Ordem Limite

        📢 Canal: GRE - 58
        🌐 Plataforma: telegram

        💎 Moeda: CYBER
        📊 Tipo: SHORT (Futures)
        📈 Alavancagem: 10x

        💰 Zona de Entrada: 2.52500000 - 2.64000000
        🛑 Stop Loss: 2.90000000 (12.2943%)
        🎯 Alvos:
        T1: 2.44000000 (5.52%)
        T2: 2.37000000 (8.23%)
        T3: 2.29000000 (11.33%)
        T4: 2.20000000 (14.81%)
        ☯️ R/R ratio: 0.4

        📊 Status: Sinal aberto

        🟢 Confiança: 66.67%  🧭 Consenso: 4/6
        """
    )

    data = parse_signal(message)

    assert data is not None, "O parser não deveria retornar None para este sinal"
    assert data["type"] == SignalType.LIMIT
    assert data["coin"] == "CYBERUSDT"
    assert data["order_type"] == "SHORT"
    assert data["entries"] == [2.525, 2.64]
    assert data["stop_loss"] == 2.9
    assert data["targets"] == [2.44, 2.37, 2.29, 2.2]
    assert data["confidence"] == 66.67



# --- NOVO TESTE: MARKET (Ordem à Mercado) ---
def test_parse_market_signal_with_accent():
    message = textwrap.dedent(
        """
        🏁 #39170 - Ordem à Mercado

        💎 Moeda: AVAX
        📊 Tipo: SHORT (Futures)

        💰 Zona de Entrada: 22.85000000 - 22.85000000
        🛑 Stop Loss: 24.22000000
        Alvos:
        T1: 22.69000000
        T2: 22.55000000
        """
    )

    data = parse_signal(message)

    assert data is not None
    assert data["type"] == SignalType.MARKET
    assert data["coin"] == "AVAXUSDT"
    assert data["order_type"] == "SHORT"
    assert data["entries"][0] == 22.85
    assert data["stop_loss"] == 24.22
    assert 22.69 in data["targets"]
    assert 22.55 in data["targets"]


# --- NOVO TESTE: CANCELAR ---
def test_parse_cancel_signal():
    message = textwrap.dedent(
        """
        ⚠️ BTC sinal cancelado
        """
    )

    data = parse_signal(message)

    assert data is not None
    assert data["type"] == SignalType.CANCELAR
    assert data["coin"] == "BTCUSDT"


========================================
# Arquivo: tests/test_trade_manager_e2e.py
========================================

# tests/test_trade_manager_e2e.py

import sys
import types
import textwrap
import pytest

# ===========================
# STUBS: telegram e bot.keyboards
# ===========================
telegram = types.ModuleType("telegram")
telegram_ext = types.ModuleType("telegram.ext")
telegram_constants = types.ModuleType("telegram.constants")

class InlineKeyboardButton:
    def __init__(self, text, callback_data=None, url=None):
        self.text = text
        self.callback_data = callback_data
        self.url = url

class InlineKeyboardMarkup:
    def __init__(self, keyboard):
        self.keyboard = keyboard

class Application:
    def __init__(self):
        self.bot = None

# expõe no módulo stub
telegram.InlineKeyboardButton = InlineKeyboardButton
telegram.InlineKeyboardMarkup = InlineKeyboardMarkup
telegram.constants = telegram_constants
telegram_ext.Application = Application

# registra stubs
sys.modules.setdefault("telegram", telegram)
sys.modules.setdefault("telegram.ext", telegram_ext)
sys.modules.setdefault("telegram.constants", telegram_constants)

# bot.keyboards stub (para satisfazer "from bot.keyboards import signal_approval_keyboard")
bot_pkg = types.ModuleType("bot")
bot_keyboards = types.ModuleType("bot.keyboards")
def signal_approval_keyboard(signal_id: int):
    return InlineKeyboardMarkup([[InlineKeyboardButton("Aprovar", callback_data=f"approve:{signal_id}")]])
bot_keyboards.signal_approval_keyboard = signal_approval_keyboard
sys.modules.setdefault("bot", bot_pkg)
sys.modules.setdefault("bot.keyboards", bot_keyboards)

# ===========================
# Imports reais do projeto
# ===========================
from services.signal_parser import parse_signal, SignalType
import core.trade_manager as tm


# ===========================
# Fakes utilitários
# ===========================
class FakeUser:
    def __init__(self, telegram_id=111, api_key_encrypted="enc_k", api_secret_encrypted="enc_s", min_confidence=0.0, approval_mode="AUTOMATIC"):
        self.telegram_id = telegram_id
        self.api_key_encrypted = api_key_encrypted
        self.api_secret_encrypted = api_secret_encrypted
        self.min_confidence = min_confidence
        self.approval_mode = approval_mode

class _QueryList:
    def __init__(self, data_list):
        self._data = data_list
    def filter(self, *args, **kwargs):  # compat simples
        return self
    def filter_by(self, **kwargs):
        # Implementação leve para casos .filter_by(user_telegram_id=..., symbol=...)
        def match(obj):
            return all(getattr(obj, k, None) == v for k, v in kwargs.items())
        return _QueryList([x for x in self._data if match(x)])
    def all(self):
        return list(self._data)
    def first(self):
        return self._data[0] if self._data else None

class FakeDB:
    """DB fake que suporta .query(Model) e listas de users/pendings."""
    def __init__(self, users=None, pendings=None):
        self._users = users or []
        self._pendings = pendings or []
        self.added = []
        self.deleted = []
        self.commits = 0
        self.closed = False
    def query(self, Model):
        if Model is tm.User:
            return _QueryList(self._users)
        if Model is tm.PendingSignal:
            return _QueryList(self._pendings)
        if Model is tm.Trade:
            # raramente consultado em testes; devolve vazio
            return _QueryList([])
        if Model is tm.SignalForApproval:
            return _QueryList([])
        return _QueryList([])
    def add(self, obj):
        self.added.append(obj)
        # se for PendingSignal "persistido", também aparece em consultas subsequentes
        if isinstance(obj, tm.PendingSignal) or getattr(obj, "__class__", None).__name__ == "DummyPending":
            self._pendings.append(obj)
    def delete(self, obj):
        self.deleted.append(obj)
        if obj in self._pendings:
            self._pendings.remove(obj)
    def commit(self):
        self.commits += 1
    def close(self):
        self.closed = True

class FakeBot:
    def __init__(self):
        self.sent = []
    async def send_message(self, **kwargs):
        self.sent.append(kwargs)

class FakeApplication(Application):
    def __init__(self):
        super().__init__()
        self.bot = FakeBot()


# ===========================
# Textos de sinais
# ===========================
MARKET_SIGNAL = textwrap.dedent("""
🏁 #39170 - Ordem à Mercado

💎 Moeda: AVAX
📊 Tipo: SHORT (Futures)

💰 Zona de Entrada: 22.85000000 - 22.85000000
🛑 Stop Loss: 24.22000000
Alvos:
T1: 22.69000000
T2: 22.55000000
""")

LIMIT_SIGNAL_SHORT = textwrap.dedent("""
⏳ #38792 - Ordem Limite

💎 Moeda: CYBER
📊 Tipo: SHORT (Futures)

💰 Zona de Entrada: 2.52500000 - 2.64000000
🛑 Stop Loss: 2.90000000
Alvos:
T1: 2.44000000
T2: 2.37000000
T3: 2.29000000
T4: 2.20000000
""")

LIMIT_SIGNAL_LONG = textwrap.dedent("""
⏳ #50001 - Ordem Limite

💎 Moeda: XRP
📊 Tipo: LONG (Futures)

💰 Zona de Entrada: 0.4500 - 0.4510
🛑 Stop Loss: 0.4400
Alvos:
T1: 0.4600
T2: 0.4700
""")

CANCEL_SIGNAL_XRP = "⚠️ XRP sinal cancelado"


# ===========================
# TESTES
# ===========================
@pytest.mark.asyncio
async def test_market_flow_calls_place_order(monkeypatch):
    parsed = parse_signal(MARKET_SIGNAL)
    assert parsed and parsed["type"] == SignalType.MARKET

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=999)])

    class DummyTrade:
        def __init__(self, **kwargs):
            self.kwargs = kwargs

    called = {}
    async def fake_place_order(api_key, api_secret, signal_data, user, balance):
        called["api_key"] = api_key
        called["api_secret"] = api_secret
        called["signal_data"] = signal_data
        called["user_id"] = user.telegram_id
        called["balance"] = balance
        return {"success": True, "data": {"orderId": "fake-123", "qty": "1.0"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "100.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_order", fake_place_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "Trade", DummyTrade)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # Validações
    assert called, "place_order não foi chamado"
    assert called["user_id"] == 999
    assert called["signal_data"]["coin"] == "AVAXUSDT"
    assert called["signal_data"]["order_type"] == "SHORT"
    assert called["signal_data"]["entries"][0] == pytest.approx(22.85, rel=1e-6)
    assert called["signal_data"]["stop_loss"] == pytest.approx(24.22, rel=1e-6)
    assert called["balance"] == 100.0

    # Mensagem ao usuário
    assert app.bot.sent, "Nenhuma mensagem foi enviada"
    texts = [m.get("text", "").lower() for m in app.bot.sent]
    assert any(("ordem" in t) or ("aberta" in t) or ("sucesso" in t) for t in texts), texts


@pytest.mark.asyncio
async def test_limit_short_creates_pending_and_uses_upper_bound(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_SHORT)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "SHORT"

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=777)])

    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    called = {"market": False, "limit": None}

    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        called["limit"] = dict(signal_data)  # capturar signal_data com limit_price
        return {"success": True, "data": {"orderId": "LIM-001"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "50.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_order", fake_place_order)  # não deve ser chamado
    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # Não deve ter chamado market
    assert not called["market"], "LIMIT (SHORT) não deve abrir ordem a mercado"
    # Deve ter chamado limit com limit_price == high (2.64000000)
    assert called["limit"] and called["limit"].get("limit_price") == pytest.approx(2.64, rel=1e-6)
    # Deve ter criado PendingSignal e avisado usuário
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal não criado"
    assert app.bot.sent, "Sem mensagem de confirmação ao usuário"


@pytest.mark.asyncio
async def test_limit_long_uses_lower_bound(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_LONG)
    assert parsed and parsed["type"] == SignalType.LIMIT and parsed["order_type"] == "LONG"

    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=888)])

    class DummyPending:
        def __init__(self, **kw):
            self.user_telegram_id = kw.get("user_telegram_id")
            self.symbol = kw.get("symbol")
            self.order_id = kw.get("order_id")
            self.signal_data = kw.get("signal_data")

    called = {"limit": None}

    async def fake_place_limit_order(api_key, api_secret, signal_data, user, balance):
        called["limit"] = dict(signal_data)
        return {"success": True, "data": {"orderId": "LIM-002"}}

    async def fake_get_account_info(api_key, api_secret):
        return {"success": True, "data": [{"totalEquity": "80.0"}]}

    def fake_decrypt(data):
        return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "PendingSignal", DummyPending)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    assert called["limit"] is not None, "place_limit_order não foi chamado"
    assert called["limit"]["limit_price"] == pytest.approx(0.4500, rel=1e-6), "LONG deve usar menor preço da faixa"
    assert any(isinstance(x, DummyPending) for x in db.added), "PendingSignal não criado"
    assert app.bot.sent, "Sem mensagem ao usuário"


@pytest.mark.asyncio
async def test_limit_skips_when_existing_pending(monkeypatch):
    parsed = parse_signal(LIMIT_SIGNAL_LONG)
    assert parsed and parsed["type"] == SignalType.LIMIT

    app = FakeApplication()

    class DummyPending:
        def __init__(self, user_telegram_id, symbol, order_id="old", signal_data=None):
            self.user_telegram_id = user_telegram_id
            self.symbol = symbol
            self.order_id = order_id
            self.signal_data = signal_data or {}

    # já existe um pendente para o mesmo símbolo e usuário
    existing = DummyPending(user_telegram_id=777, symbol="XRPUSDT")
    db = FakeDB(users=[FakeUser(telegram_id=777)], pendings=[existing])

    called = {"limit": False}
    async def fake_place_limit_order(*a, **k):
        called["limit"] = True
        return {"success": True}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")
    async def fake_get_account_info(api_key, api_secret): return {"success": True, "data": [{"totalEquity": "10"}]}

    monkeypatch.setattr(tm, "place_limit_order", fake_place_limit_order)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    # não deve chamar place_limit_order
    assert not called["limit"], "Não deveria tentar posicionar nova LIMIT com pendente existente"
    # deve ter avisado usuário
    assert app.bot.sent and any("já tem uma ordem limite pendente" in (m.get("text","")) for m in app.bot.sent)


@pytest.mark.asyncio
async def test_cancel_removes_pending_and_notifies(monkeypatch):
    # preparar db com pending XRP para user 123
    class DummyPending:
        def __init__(self, user_telegram_id, symbol, order_id="LIM-XYZ", signal_data=None):
            self.user_telegram_id = user_telegram_id
            self.symbol = symbol
            self.order_id = order_id
            self.signal_data = signal_data or {}

    pend = DummyPending(user_telegram_id=123, symbol="XRPUSDT")
    users = [FakeUser(telegram_id=123)]
    base_db = FakeDB(users=users, pendings=[pend])

    # monkeypatch SessionLocal para devolver nosso FakeDB
    def fake_SessionLocal():
        # devolve uma "nova" instância por chamada, clonando o estado base
        return FakeDB(users=list(base_db._users), pendings=list(base_db._pendings))

    app = FakeApplication()

    async def fake_cancel_order(api_key, api_secret, order_id, symbol):
        return {"success": True}

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    monkeypatch.setattr(tm, "SessionLocal", fake_SessionLocal)
    monkeypatch.setattr(tm, "cancel_order", fake_cancel_order)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)

    parsed_cancel = parse_signal(CANCEL_SIGNAL_XRP)
    assert parsed_cancel and parsed_cancel["type"] == SignalType.CANCELAR

    await tm.process_new_signal(parsed_cancel, app, source_name="TEST-CHANNEL")

    # Como usamos uma instância nova de FakeDB dentro do process, não temos referência direta
    # mas podemos validar pelo envio de mensagem de sucesso
    assert app.bot.sent and any("foi cancelada com sucesso" in (m.get("text","").lower()) for m in app.bot.sent)


@pytest.mark.asyncio
async def test_cancel_without_pending_sends_info_notification(monkeypatch):
    # DB sem pendentes
    base_db = FakeDB(users=[FakeUser(telegram_id=1)], pendings=[])
    def fake_SessionLocal():
        return FakeDB(users=list(base_db._users), pendings=list(base_db._pendings))

    app = FakeApplication()
    captured = {"msg": None}

    async def fake_send_notification(application, text):
        captured["msg"] = text

    monkeypatch.setattr(tm, "SessionLocal", fake_SessionLocal)
    monkeypatch.setattr(tm, "send_notification", fake_send_notification)

    parsed_cancel = parse_signal(CANCEL_SIGNAL_XRP)
    await tm.process_new_signal(parsed_cancel, app, source_name="TEST-CHANNEL")

    assert captured["msg"] is not None
    assert "nenhuma ordem pendente foi encontrada" in captured["msg"].lower()


@pytest.mark.asyncio
async def test_market_fails_on_balance_fetch(monkeypatch):
    parsed = parse_signal(MARKET_SIGNAL)
    app = FakeApplication()
    db = FakeDB(users=[FakeUser(telegram_id=321)])

    async def fake_get_account_info(api_key, api_secret):
        return {"success": False}  # falha

    def fake_decrypt(data): return "DECRYPTED-" + (data or "")

    called = {"market": False}
    async def fake_place_order(*a, **k):
        called["market"] = True
        return {"success": True}

    monkeypatch.setattr(tm, "get_account_info", fake_get_account_info)
    monkeypatch.setattr(tm, "decrypt_data", fake_decrypt)
    monkeypatch.setattr(tm, "place_order", fake_place_order)

    await tm.execute_signal_for_all_users(parsed, app, db, source_name="TEST-CHANNEL")

    assert not called["market"], "Não deve tentar abrir ordem sem saldo"
    assert app.bot.sent and any("falha ao buscar seu saldo bybit" in (m.get("text","").lower()) for m in app.bot.sent)


========================================
# Arquivo: utils/__init__.py
========================================



========================================
# Arquivo: utils/config.py
========================================

import os
from dotenv import load_dotenv

load_dotenv()

TELEGRAM_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
ENCRYPTION_KEY = os.getenv('ENCRYPTION_KEY')

API_ID = os.getenv('API_ID')
API_HASH = os.getenv('API_HASH')
ADMIN_ID = int(os.getenv('ADMIN_TELEGRAM_ID', 0)) # Converte para int

========================================
# Arquivo: utils/security.py
========================================

from cryptography.fernet import Fernet
from .config import ENCRYPTION_KEY

# Inicializa o 'cofre' com a sua chave
cipher_suite = Fernet(ENCRYPTION_KEY.encode())

def encrypt_data(data: str) -> str:
    """Criptografa um texto e retorna a versão em string."""
    if not data:
        return None
    encrypted_bytes = cipher_suite.encrypt(data.encode())
    return encrypted_bytes.decode()

def decrypt_data(encrypted_data: str) -> str:
    """Descriptografa um texto e retorna a versão original."""
    if not encrypted_data:
        return None
    decrypted_bytes = cipher_suite.decrypt(encrypted_data.encode())
    return decrypted_bytes.decode()

========================================
# Arquivo: scripts/create_invite.py
========================================

import sys
from database.session import SessionLocal, init_db
from database.models import InviteCode

def create_invite_code(code: str):
    db = SessionLocal()
    try:
        existing_code = db.query(InviteCode).filter(InviteCode.code == code).first()
        if existing_code:
            print(f"Código '{code}' já existe.")
            return

        new_code = InviteCode(code=code)
        db.add(new_code)
        db.commit()
        print(f"Código de convite '{code}' criado com sucesso!")
    finally:
        db.close()

if __name__ == "__main__":
    init_db()
    # Agora ele lê o código a partir do seu comando no terminal
    if len(sys.argv) > 1:
        code_to_create = sys.argv[1]
        create_invite_code(code_to_create)
    else:
        print("Erro: Por favor, forneça um código para criar. Exemplo: python create_invite.py MEU-CODIGO-NOVO")

========================================
# Arquivo: bot/__init__.py
========================================



========================================
# Arquivo: bot/handlers.py
========================================

import logging
import asyncio
from database.models import PendingSignal
from services.bybit_service import place_limit_order, get_account_info
from datetime import datetime, time, timedelta 
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler
from telegram.error import BadRequest
from database.session import SessionLocal
from database.models import User, InviteCode, MonitoredTarget, Trade, SignalForApproval
from .keyboards import (
    main_menu_keyboard, confirm_remove_keyboard, admin_menu_keyboard, 
    dashboard_menu_keyboard, settings_menu_keyboard, view_targets_keyboard, 
    bot_config_keyboard, performance_menu_keyboard)
from utils.security import encrypt_data, decrypt_data
from services.bybit_service import (
    get_open_positions, 
    get_account_info, 
    close_partial_position, 
    get_open_positions_with_pnl,
    get_market_price
)
from utils.config import ADMIN_ID
from database.crud import get_user_by_id
from core.trade_manager import _execute_trade
from core.performance_service import generate_performance_report
from core.trade_manager import execute_signal_for_all_users


# Estados para as conversas
(WAITING_CODE, WAITING_API_KEY, WAITING_API_SECRET, CONFIRM_REMOVE_API) = range(4)
(ASKING_ENTRY_PERCENT, ASKING_MAX_LEVERAGE, ASKING_MIN_CONFIDENCE) = range(10, 13)
(ASKING_PROFIT_TARGET, ASKING_LOSS_LIMIT) = range(13, 15)
ASKING_COIN_WHITELIST = 15

logger = logging.getLogger(__name__)

# --- FLUXO DE USUÁRIO (START, CADASTRO, MENUS) ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    telegram_user = update.effective_user
    user_in_db = get_user_by_id(telegram_user.id)
    if user_in_db:
        await update.message.reply_text(
            "Menu Principal:",
            reply_markup=main_menu_keyboard(telegram_id=telegram_user.id)
        )
        return ConversationHandler.END
    else:
        await update.message.reply_text(
            f"Olá, {telegram_user.first_name}! Para usar o TradeFlow, insira seu código de convite."
        )
        return WAITING_CODE

async def receive_invite_code(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    code_text = update.message.text
    telegram_user = update.effective_user
    db = SessionLocal()
    try:
        invite_code = db.query(InviteCode).filter(InviteCode.code == code_text, InviteCode.is_used == False).first()
        if invite_code:
            new_user = User(telegram_id=telegram_user.id, first_name=telegram_user.first_name)
            db.add(new_user)
            invite_code.is_used = True
            db.commit()
            await update.message.reply_text(
                "✅ Cadastro realizado com sucesso! O próximo passo é configurar sua API.",
                reply_markup=main_menu_keyboard(telegram_id=telegram_user.id)
            )
            return ConversationHandler.END
        else:
            await update.message.reply_text("❌ Código de convite inválido ou já utilizado. Tente novamente.")
            return WAITING_CODE
    finally:
        db.close()

async def back_to_main_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        "Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=update.effective_user.id)
    )

# --- FLUXO DE CONFIGURAÇÃO DE API ---
async def config_api(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Inicia o fluxo de configuração de API com um tutorial melhorado."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['entry_message_id'] = query.message.message_id
    
    tutorial_text = (
        "🔑 <b>Como Criar suas Chaves de API na Bybit</b> 🔑\n\n"
        "Siga estes passos com atenção para conectar sua conta:\n\n"
        "1️⃣  Faça login em <b>Bybit.com</b> e vá para <i>Perfil > API</i>.\n\n"
        "2️⃣  Clique em <b>'Criar Nova Chave'</b> e selecione <i>'Chaves Geradas pelo Sistema'</i>.\n\n"
        "3️⃣  Dê um nome para sua chave (ex: `TradeFlowBot`) e selecione as permissões de <b>'Leitura e Escrita'</b>.\n\n"
        "4️⃣  Nas permissões, marque <b>APENAS</b> as seguintes caixas:\n"
        "   - <b>Contrato</b> (`Contract`): ✅ `Ordens` e ✅ `Posições`\n"
        "   - <b>Trading Unificado</b> (`UTA`): ✅ `Trade`\n\n"
        "5️⃣  🛡️ <b>MUITO IMPORTANTE:</b> Por segurança, <b>NÃO</b> marque a permissão de <i>'Saque' (Withdraw)</i>.\n\n"
        "⚠️ <b>Atenção:</b> Este bot opera exclusivamente com pares de trade terminados em **USDT**.\n\n"
        "6️⃣  Conclua a verificação de segurança e copie sua <b>API Key</b> e <b>API Secret</b>.\n\n"
        "-------------------------------------\n"
        "Pronto! Agora, por favor, envie sua <b>API Key</b>."
    )
    
    await query.edit_message_text(
        text=tutorial_text,
        parse_mode='HTML'
    )
    return WAITING_API_KEY

async def receive_api_key(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe a API Key, apaga a mensagem do usuário e pede a API Secret."""
    await context.bot.delete_message(
        chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    api_key = update.message.text
    context.user_data['api_key'] = api_key
    
    prompt_message = await update.message.reply_text(
        "Chave API recebida com segurança. Agora, por favor, envie sua *API Secret*.",
        parse_mode='Markdown'
    )
    context.user_data['prompt_message_id'] = prompt_message.message_id
    
    return WAITING_API_SECRET

async def receive_api_secret(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe a API Secret, apaga as mensagens, criptografa e salva no banco."""
    await context.bot.delete_message(
        chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    prompt_message_id = context.user_data.get('prompt_message_id')
    if prompt_message_id:
        await context.bot.delete_message(
            chat_id=update.effective_chat.id,
            message_id=prompt_message_id
        )

    api_secret = update.message.text
    api_key = context.user_data.get('api_key')
    telegram_id = update.effective_user.id

    encrypted_key = encrypt_data(api_key)
    encrypted_secret = encrypt_data(api_secret)

    db = SessionLocal()
    try:
        user_to_update = db.query(User).filter(User.telegram_id == telegram_id).first()
        if user_to_update:
            user_to_update.api_key_encrypted = encrypted_key
            user_to_update.api_secret_encrypted = encrypted_secret
            db.commit()
            
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=context.user_data['entry_message_id'],
                text="✅ Suas chaves de API foram salvas com sucesso!",
            )
            await context.bot.send_message(
                chat_id=telegram_id,
                text="Menu Principal:",
                reply_markup=main_menu_keyboard(telegram_id=telegram_id)
            )
        else:
            await update.message.reply_text("Ocorreu um erro. Usuário não encontrado.")
    finally:
        db.close()
        context.user_data.clear()

    return ConversationHandler.END

# --- FLUXO DE REMOÇÃO DE API ---
async def remove_api_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        text="⚠️ Você tem certeza que deseja remover suas chaves de API?",
        reply_markup=confirm_remove_keyboard()
    )
    return CONFIRM_REMOVE_API

async def remove_api_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id

    if query.data == 'remove_api_confirm':
        db = SessionLocal()
        try:
            user_to_update = db.query(User).filter(User.telegram_id == telegram_id).first()
            if user_to_update:
                user_to_update.api_key_encrypted = None
                user_to_update.api_secret_encrypted = None
                db.commit()
            await query.edit_message_text("✅ Suas chaves de API foram removidas.")
        finally:
            db.close()
    else: # Cancelou
        await query.edit_message_text("Operação cancelada.")

    await context.bot.send_message(
        chat_id=telegram_id,
        text="Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=telegram_id)
    )
    return ConversationHandler.END

# --- PAINÉIS DO USUÁRIO ---
async def my_positions_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("Buscando suas posições gerenciadas...")

    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if not user or not user.api_key_encrypted:
            await query.edit_message_text(
                "Você ainda não configurou suas chaves de API.",
            )
            return

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # posições abertas (live) com P/L atual
        live = await get_open_positions_with_pnl(api_key, api_secret)
        live_positions = live["data"] if live.get("success") else []

        # trades que o BOT está gerenciando (para os botões/IDs)
        active_trades = db.query(Trade).filter(
            Trade.user_telegram_id == user_id,
            ~Trade.status.like('%CLOSED%')
        ).all()

        # monta um índice por símbolo -> trade.id (se existir)
        trade_id_by_symbol = {t.symbol: t.id for t in active_trades}

        lines = ["<b>📊 Suas Posições Ativas (Gerenciadas pelo Bot)</b>", ""]
        keyboard = []

        if not live_positions and not active_trades:
            lines.append("Nenhuma posição sendo gerenciada no momento.")
        else:
            for pos in live_positions:
                arrow = "⬆️" if pos["side"] == "LONG" else "⬇️"
                sym = pos["symbol"]
                size = pos["size"]
                entry = pos["entry"] or 0.0
                mark = pos["mark"] or 0.0
                pnl = pos["unrealized_pnl"]
                pnl_pct = pos["unrealized_pnl_pct"]

                lines.append(
                    f"- {arrow} <b>{sym}</b> ({size:g} unid.)\n"
                    f"  Entrada: ${entry:.4f} | Preço: ${mark:.4f}\n"
                    f"  P/L: <b>{pnl:+.2f} USDT</b> ({pnl_pct:+.2f}%)\n"
                )

                # se o bot estiver gerenciando esse símbolo, mostra o botão fechar
                if sym in trade_id_by_symbol:
                    trade_id = trade_id_by_symbol[sym]
                    keyboard.append([
                        InlineKeyboardButton(
                            f"Fechar {sym} ❌",
                            callback_data=f"manual_close_{trade_id}"
                        )
                    ])

            # fallback: se existir trade “gerenciado” sem posição viva (ex.: zerou na corretora),
            # ainda mostramos o item para permitir fechamento/limpeza manual.
            for t in active_trades:
                if t.symbol not in {p["symbol"] for p in live_positions}:
                    side_emoji = "⬆️" if t.side == 'LONG' else "⬇️"
                    lines.append(
                        f"- {side_emoji} <b>{t.symbol}</b> ({t.qty:g} unid.)\n"
                        f"  Entrada: ${t.entry_price:.4f} | Status: {t.status}\n"
                    )
                    keyboard.append([
                        InlineKeyboardButton(
                            f"Fechar {t.symbol} ❌",
                            callback_data=f"manual_close_{t.id}"
                        )
                    ])

        keyboard.append([InlineKeyboardButton("⬅️ Voltar ao Menu", callback_data='back_to_main_menu')])
        await query.edit_message_text(
            "\n".join(lines),
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    finally:
        db.close()

async def user_dashboard_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o painel com saldo focado em USDT, outras moedas e posições."""
    query = update.callback_query
    try:
        await query.answer()
    except BadRequest as e:
        logger.warning(f"Não foi possível responder ao callback_query (pode ser antigo): {e}")
        return

    await query.edit_message_text("Buscando informações do painel...")
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        user = get_user_by_id(user_id)
        if not user or not user.api_key_encrypted:
            await query.edit_message_text("Você precisa configurar sua API primeiro.", reply_markup=main_menu_keyboard(telegram_id=user_id))
            return

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        account_info, positions_info = await asyncio.gather(
            get_account_info(api_key, api_secret),
            get_open_positions_with_pnl(api_key, api_secret)
        )

        message = "<b>ℹ️ Seu Painel de Controle</b>\n\n"
        message += "<b>Saldos na Carteira:</b>\n"

        if account_info.get("success"):
            balance_data = account_info.get("data", {})
            coin_list = balance_data.get("coin_list", [])
            
            usdt_balance_value = 0.0
            other_coins_lines = []

            for c in coin_list:
                coin = (c.get("coin") or "").upper()
                wallet_balance_str = c.get("walletBalance")
                wallet_balance = float(wallet_balance_str) if wallet_balance_str else 0.0

                if coin == "USDT":
                    usdt_balance_value = wallet_balance
                elif wallet_balance >= 0.1:
                    other_coins_lines.append(f"- {coin}: {wallet_balance:.2f}")

            message += f"<b>- USDT: {usdt_balance_value:.2f}</b>\n"
            if other_coins_lines:
                message += "\n".join(other_coins_lines)
            elif usdt_balance_value == 0.0:
                 message += "Nenhum saldo relevante encontrado.\n"
        else:
            message += f"Erro ao buscar saldo: {account_info.get('error')}\n"

        message += "\n\n<b>Posições Abertas:</b>\n"
        if positions_info.get("success") and positions_info.get("data"):
            for p in positions_info["data"]:
                side = (p.get("side") or "").upper()
                arrow = "🔼" if side == "LONG" else "🔽"
                symbol = p.get("symbol", "???")
                size = p.get("size", 0)
                entry = float(p.get("entry_price") or 0)
                mark = float(p.get("mark_price") or 0)
                pnl = float(p.get("unrealized_pnl") or 0)
                pnl_pct = float(p.get("unrealized_pnl_pct") or 0)

                message += (
                    f"- {arrow} {symbol}: {size:g}\n"
                    f"  Entrada: ${entry:,.4f} | Atual: ${mark:,.4f}\n"
                    f"  P/L: <b>${pnl:+.2f} ({pnl_pct:+.2f}%)</b>\n"
                )
        else:
            message += "- Nenhuma posição aberta no momento."

        message += "\n\n<i>⚠️ Este bot opera exclusivamente com pares USDT.</i>"

        await query.edit_message_text(message, parse_mode="HTML", reply_markup=dashboard_menu_keyboard())

    except Exception as e:
        logger.error(f"Erro ao montar o painel do usuário: {e}", exc_info=True)
        await query.edit_message_text("Ocorreu um erro ao buscar os dados do seu painel.")
    finally:
        db.close()


# --- CANCELAMENTO ---
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancela a operação atual."""
    await update.message.reply_text("Operação cancelada.")
    return ConversationHandler.END

# --- FLUXO DE ADMINISTRAÇÃO ---
async def admin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra o menu de administrador, se o usuário for o admin."""
    user_id = update.effective_user.id
    if user_id != ADMIN_ID:
        await update.message.reply_text("Você não tem permissão para usar este comando.")
        return

    await update.message.reply_text(
        "Bem-vindo ao painel de administração.",
        reply_markup=admin_menu_keyboard()
    )


async def admin_view_targets_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Busca e exibe a lista de todos os canais e tópicos sendo monitorados."""
    query = update.callback_query
    await query.answer()
    
    db = SessionLocal()
    try:
        targets = db.query(MonitoredTarget).all()
        
        message = "<b>👁️ Alvos Atualmente Monitorados</b>\n\n"
        
        if targets:
            for target in targets:
                if target.topic_name:
                    message += f"- <b>Grupo:</b> {target.channel_name}\n  - <b>Tópico:</b> {target.topic_name}\n"
                else:
                    message += f"- <b>Canal:</b> {target.channel_name}\n"
        else:
            message += "Nenhum alvo sendo monitorado no momento."
            
        await query.edit_message_text(
            text=message,
            parse_mode='HTML',
            reply_markup=view_targets_keyboard()
        )
    finally:
        db.close()

async def back_to_admin_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usuário para o menu de administração principal."""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        "Bem-vindo ao painel de administração.",
        reply_markup=admin_menu_keyboard()
    )

async def list_channels_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Coloca um pedido na fila para listar os grupos e canais do usuário."""
    query = update.callback_query
    await query.answer()
    
    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue:
        await query.edit_message_text("Erro: Fila de comunicação não encontrada.")
        return
    
    request_data = {
        "action": "list_channels",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
    }
    
    await comm_queue.put(request_data)
    
    await query.edit_message_text("Buscando sua lista de canais... Se você tiver muitos grupos, isso pode levar até um minuto. Por favor, aguarde.")
    
async def select_channel_to_monitor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Coloca um pedido na fila para listar tópicos (ou gerenciar um canal plano)."""
    query = update.callback_query
    await query.answer()
    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue: return

    user_id = update.effective_user.id
    if user_id != ADMIN_ID: return

    channel_id = int(query.data.split('_')[-1])
    
    channel_name = ""
    for row in query.message.reply_markup.inline_keyboard:
        for button in row:
            if button.callback_data == query.data:
                channel_name = button.text.replace(" ✅", "")
                break

    request_data = {
        "action": "list_topics",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
        "channel_id": channel_id,
        "channel_name": channel_name
    }
    
    await comm_queue.put(request_data)
    await query.edit_message_text("Processando...")

async def select_topic_to_monitor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Salva/remove o tópico e pede para a fila recarregar o menu de tópicos."""
    query = update.callback_query
    await query.answer() 

    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue:
        logger.error("Fila de comunicação não encontrada no contexto do bot.")
        return

    user_id = update.effective_user.id
    if user_id != ADMIN_ID: return

    _, _, channel_id_str, topic_id_str = query.data.split('_')
    channel_id = int(channel_id_str)
    topic_id = int(topic_id_str)
    
    db = SessionLocal()
    try:
        existing_target = db.query(MonitoredTarget).filter_by(channel_id=channel_id, topic_id=topic_id).first()
        
        if existing_target:
            db.delete(existing_target)
        else:
            topic_name = ""
            for row in query.message.reply_markup.inline_keyboard:
                for button in row:
                    if button.callback_data == query.data:
                        topic_name = button.text.replace(" ✅", "")
                        break
            new_target = MonitoredTarget(channel_id=channel_id, topic_id=topic_id, topic_name=topic_name)
            db.add(new_target)
        
        db.commit()
    finally:
        db.close()

    request_data = {
        "action": "list_topics",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
        "channel_id": channel_id,
        "channel_name": ""
    }
    await comm_queue.put(request_data)

async def back_to_channels_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usuário para a lista de canais/grupos."""
    await list_channels_handler(update, context)

# --- FUNÇÕES DUPLICADAS REMOVIDAS PARA LIMPEZA ---
# my_dashboard_handler, my_positions_handler, back_to_main_menu_handler
# já estavam definidas acima.

async def user_settings_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de configurações de trade com os valores atuais do usuário."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            await query.edit_message_text(
                "<b>⚙️ Configurações de Trade</b>\n\n"
                "Aqui você pode definir seus parâmetros de risco e automação.",
                parse_mode='HTML',
                reply_markup=settings_menu_keyboard(user)
            )
    finally:
        db.close()

async def ask_entry_percent(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuário qual a nova porcentagem da banca por entrada."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie a porcentagem da sua banca em USDT que você deseja usar para cada entrada.\n\n"
        "Exemplo: se você tem $100 e define `10`, cada entrada terá o valor de $10.\n"
        "Envie apenas o número (ex: `10` para 10%)."
    )
    return ASKING_ENTRY_PERCENT

async def receive_entry_percent(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova porcentagem de entrada."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        percent_value = float(update.message.text.replace(',', '.'))
        if not (0.1 <= percent_value <= 100):
            raise ValueError("Valor fora do range permitido (0.1 a 100)")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.entry_size_percent = percent_value
            db.commit()
            
            api_key = decrypt_data(user.api_key_encrypted)
            api_secret = decrypt_data(user.api_secret_encrypted)
            account_info = await get_account_info(api_key, api_secret)
            
            usdt_balance = 0.0
            if account_info.get("success"):
                balances = account_info.get("data", [])
                if balances:
                    coin_list = balances[0].get('coin', [])
                    for coin in coin_list:
                        if coin.get('coin') == 'USDT':
                            usdt_balance = float(coin.get('walletBalance', 0))
                            break
            
            entry_value = usdt_balance * (percent_value / 100)
            
            feedback_text = (
                f"✅ Tamanho da entrada atualizado para <b>{percent_value:.2f}%</b>.\n\n"
                f"Com seu saldo atual, cada entrada será de aprox. <b>${entry_value:,.2f} USDT</b>."
            )

            if percent_value > 25:
                feedback_text += "\n\n⚠️ <b>Atenção:</b> Uma porcentagem acima de 25% é considerada de altíssimo risco!"

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=feedback_text,
                parse_mode='HTML',
                reply_markup=settings_menu_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="❌ Valor inválido. Por favor, tente novamente com um número entre 0.1 e 100 (ex: 10)."
        )
        return ASKING_ENTRY_PERCENT

    return ConversationHandler.END        

async def ask_max_leverage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuário qual a nova alavancagem máxima."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Qual a alavancagem máxima que o bot deve usar?\n"
        "Envie apenas o número (ex: `10` para 10x)."
    )
    return ASKING_MAX_LEVERAGE

async def receive_max_leverage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova alavancagem máxima."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    try:
        leverage_value = int(update.message.text)
        if not (1 <= leverage_value <= 125):
            raise ValueError("Alavancagem fora do limite (1-125)")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.max_leverage = leverage_value
            db.commit()
            
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"✅ Alavancagem máxima atualizada para {leverage_value}x.\n\n"
                     "Selecione outra opção para editar ou volte.",
                reply_markup=settings_menu_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="❌ Valor inválido. Por favor, tente novamente com um número inteiro (ex: 10)."
        )
        return ASKING_MAX_LEVERAGE
    finally:
        await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    return ConversationHandler.END

async def ask_min_confidence(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuário qual o novo valor de confiança mínima."""
    query = update.callback_query
    await query.answer()
    context.user_data['settings_message_id'] = query.message.message_id
    await query.edit_message_text("Envie o valor da confiança mínima da IA (ex: 75 para 75%).\nSinais com confiança abaixo disso serão ignorados.")
    return ASKING_MIN_CONFIDENCE

async def receive_min_confidence(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva o novo valor de confiança."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        confidence_value = float(update.message.text.replace(',', '.'))
        if not (0 <= confidence_value <= 100):
            raise ValueError("Valor fora do range permitido (0-100)")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.min_confidence = confidence_value
            db.commit()
            
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"✅ Confiança mínima atualizada para {confidence_value:.2f}%.\n\n"
                     "Selecione outra opção para editar ou volte.",
                reply_markup=settings_menu_keyboard(user)
            )
        finally:
            db.close()

        return ConversationHandler.END

    except (ValueError, TypeError):
        logger.warning(f"Usuário {user_id} enviou um valor inválido para confiança: {update.message.text}")
        
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="❌ <b>Valor inválido.</b>\nPor favor, envie apenas um número entre 0 e 100 (ex: 75).",
            parse_mode='HTML'
        )
        
        return ASKING_MIN_CONFIDENCE
    
async def manual_close_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Lida com o fechamento manual de uma posição pelo usuário."""
    query = update.callback_query
    await query.answer("Processando fechamento...")

    trade_id = int(query.data.split('_')[-1])
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        trade_to_close = db.query(Trade).filter_by(id=trade_id, user_telegram_id=user_id).first()

        if not trade_to_close:
            await query.edit_message_text("Erro: Trade não encontrado ou já fechado.")
            return

        user = db.query(User).filter_by(telegram_id=user_id).first()
        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # --- NOVA LÓGICA ---
        # 1. Pega o preço atual para calcular o P/L
        price_result = await get_market_price(trade_to_close.symbol)
        if not price_result.get("success"):
            await context.bot.send_message(chat_id=user_id, text=f"⚠️ Não foi possível obter o preço atual de {trade_to_close.symbol} para calcular o P/L.")
            current_price = trade_to_close.entry_price # Fallback
        else:
            current_price = price_result["price"]

        # 2. Fecha a posição
        close_result = await close_partial_position(
            api_key, 
            api_secret, 
            trade_to_close.symbol, 
            trade_to_close.remaining_qty, 
            trade_to_close.side
        )

        if close_result.get("success"):
            # 3. Calcula o P/L e formata a mensagem
            pnl = (current_price - trade_to_close.entry_price) * trade_to_close.remaining_qty if trade_to_close.side == 'LONG' else (trade_to_close.entry_price - current_price) * trade_to_close.remaining_qty
            
            resultado_str = "LUCRO" if pnl >= 0 else "PREJUÍZO"
            emoji = "✅" if pnl >= 0 else "🔻"
            
            message_text = (
                f"{emoji} <b>Posição Fechada Manualmente ({resultado_str})</b>\n"
                f"<b>Moeda:</b> {trade_to_close.symbol}\n"
                f"<b>Resultado:</b> ${pnl:,.2f}"
            )
            
            trade_to_close.status = 'CLOSED_MANUAL'
            db.commit()
            await query.edit_message_text(message_text, parse_mode='HTML')
            # Atualiza a lista de posições após um pequeno delay
            await asyncio.sleep(2)
            await my_positions_handler(update, context)
        else:
            error_msg = close_result.get('error')
            await context.bot.send_message(
                chat_id=user_id,
                text=f"❌ Erro ao fechar a posição para {trade_to_close.symbol}: {error_msg}"
            )
    finally:
        db.close()


async def bot_config_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de configuração do bot com o modo de aprovação atual."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    db = SessionLocal()
    try:
        user = get_user_by_id(user_id)
        if user:
            await query.edit_message_text(
                "<b>🤖 Configuração do Bot</b>\n\n"
                "Ajuste o comportamento geral do bot.",
                parse_mode='HTML',
                reply_markup=bot_config_keyboard(user)
            )
    finally:
        db.close()

async def toggle_approval_mode_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Alterna o modo de aprovação de ordens entre Manual e Automático."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == user_id).first()
        
        if user:
            if user.approval_mode == 'AUTOMATIC':
                user.approval_mode = 'MANUAL'
            else:
                user.approval_mode = 'AUTOMATIC'
            
            db.commit() 
            
            try:
                await query.edit_message_text(
                    "<b>🤖 Configuração do Bot</b>\n\n"
                    "Ajuste o comportamento geral do bot.",
                    parse_mode='HTML',
                    reply_markup=bot_config_keyboard(user)
                )
            except BadRequest as e:
                if "Message is not modified" in str(e):
                    pass
                else:
                    logger.error(f"Erro ao editar mensagem em toggle_approval_mode: {e}")
    finally:
        db.close()

async def handle_signal_approval(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    ### ALTERAÇÃO INICIADA ###
    # A linha abaixo estava incorreta e não extraía a ação ('approve') corretamente.
    # A nova linha usa `partition` para dividir a string de forma mais confiável.
    # Ex: 'approve_signal_123' se torna ('approve', '_signal_', '123')
    action, _, signal_id_str = query.data.partition('_signal_')
    ### ALTERAÇÃO FINALIZADA ###

    signal_id = int(signal_id_str)
    
    db = SessionLocal()
    try:
        signal_to_process = db.query(SignalForApproval).filter_by(id=signal_id).first()
        if not signal_to_process:
            await query.edit_message_text("Este sinal já foi processado ou expirou.")
            return

        if action == 'approve':
            await query.edit_message_text("✅ **Entrada Aprovada!** Replicando a ordem para todos os usuários...")
            
            await execute_signal_for_all_users(
                signal_data=signal_to_process.signal_data,
                application=context.application,
                db=db,
                source_name=signal_to_process.source_name
            )
            
        elif action == 'reject':
            await query.edit_message_text("❌ **Entrada Rejeitada.** O sinal foi descartado.")
        
        db.delete(signal_to_process)
        db.commit()
    finally:
        db.close()

# --- FLUXO DE CONFIGURAÇÃO DE METAS DIÁRIAS ---

async def ask_profit_target(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuário a nova meta de lucro diário."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie a sua meta de **lucro diário** em USDT.\n"
        "O bot irá parar de abrir novas ordens quando o lucro do dia atingir este valor.\n\n"
        "Envie apenas o número (ex: `100` para $100) ou `0` para desativar.",
        parse_mode='Markdown'
    )
    return ASKING_PROFIT_TARGET

async def receive_profit_target(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova meta de lucro."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        target_value = float(update.message.text.replace(',', '.'))
        if target_value < 0:
            raise ValueError("Valor não pode ser negativo")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.daily_profit_target = target_value
            db.commit()
            
            feedback_text = f"✅ Meta de lucro diário atualizada para ${target_value:.2f}."
            if target_value == 0:
                feedback_text = "✅ Meta de lucro diário foi desativada."

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"{feedback_text}\n\nAjuste outra configuração ou volte.",
                reply_markup=bot_config_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="❌ Valor inválido. Por favor, tente novamente com um número (ex: 100)."
        )
        return ASKING_PROFIT_TARGET

    return ConversationHandler.END

async def ask_loss_limit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuário o novo limite de perda diário."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Envie o seu limite de **perda diária** em USDT.\n"
        "O bot irá parar de abrir novas ordens se a perda do dia atingir este valor.\n\n"
        "Envie um número positivo (ex: `50` para um limite de $50) ou `0` para desativar.",
        parse_mode='Markdown'
    )
    return ASKING_LOSS_LIMIT

async def receive_loss_limit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva o novo limite de perda."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        limit_value = float(update.message.text.replace(',', '.'))
        if limit_value < 0:
            raise ValueError("Valor não pode ser negativo")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.daily_loss_limit = limit_value
            db.commit()

            feedback_text = f"✅ Limite de perda diário atualizado para ${limit_value:.2f}."
            if limit_value == 0:
                feedback_text = "✅ Limite de perda diário foi desativado."

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"{feedback_text}\n\nAjuste outra configuração ou volte.",
                reply_markup=bot_config_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="❌ Valor inválido. Por favor, tente novamente com um número positivo (ex: 50)."
        )
        return ASKING_LOSS_LIMIT

    return ConversationHandler.END

# --- MENU DE DESEMPENHO ---

async def performance_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o painel de desempenho e lida com a seleção de período."""
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id
    
    callback_data = query.data
    now = datetime.now()
    start_dt, end_dt = None, None

    if callback_data == 'perf_today':
        start_dt = datetime.combine(now.date(), time.min)
        end_dt = now
    elif callback_data == 'perf_yesterday':
        yesterday = now.date() - timedelta(days=1)
        start_dt = datetime.combine(yesterday, time.min)
        end_dt = datetime.combine(yesterday, time.max)
    elif callback_data == 'perf_7_days':
        start_dt = datetime.combine(now.date() - timedelta(days=6), time.min)
        end_dt = now
    elif callback_data == 'perf_30_days':
        start_dt = datetime.combine(now.date() - timedelta(days=29), time.min)
        end_dt = now

    if start_dt and end_dt:
        await query.edit_message_text(
            text="⏳ Calculando desempenho para o período selecionado...",
            reply_markup=performance_menu_keyboard()
        )
        
        report_text = await generate_performance_report(user_id, start_dt, end_dt)
        
        await query.edit_message_text(
            text=report_text,
            parse_mode='HTML',
            reply_markup=performance_menu_keyboard()
        )

# --- FLUXO DE CONFIGURAÇÃO DE WHITELIST ---

async def ask_coin_whitelist(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usuário sua nova whitelist de moedas."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        current_whitelist = user.coin_whitelist if user else 'todas'
    finally:
        db.close()

    instructions = (
        f"<b>✅ Whitelist de Moedas</b>\n\n"
        f"Sua configuração atual é: <code>{current_whitelist}</code>\n\n"
        f"Envie uma lista de moedas e/ou categorias separadas por vírgula.\n\n"
        f"<b>Exemplos:</b>\n"
        f"• <code>todas</code> (para operar todos os sinais)\n"
        f"• <code>btcusdt, ethusdt, solusdt</code>\n"
        f"• <code>memecoins, btcusdt</code> (opera moedas meme + BTC)\n\n"
        f"<b>Categorias disponíveis:</b> <code>memecoins</code>, <code>altcoins</code>, <code>defi</code>."
    )
    
    await query.edit_message_text(text=instructions, parse_mode='HTML')
    return ASKING_COIN_WHITELIST

async def receive_coin_whitelist(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova whitelist."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    
    # Apaga a mensagem do usuário para manter o chat limpo
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    # Normaliza a entrada: remove espaços extras e converte para minúsculas
    whitelist_text = update.message.text.lower().strip()
    
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            user.coin_whitelist = whitelist_text
            db.commit()
            
            feedback_text = (
                f"✅ Whitelist de moedas atualizada para: <code>{whitelist_text}</code>"
            )

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=feedback_text,
                parse_mode='HTML',
                reply_markup=settings_menu_keyboard(user)
            )
    finally:
        db.close()

    return ConversationHandler.END

========================================
# Arquivo: bot/keyboards.py
========================================

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from database.crud import get_user_by_id

def main_menu_keyboard(telegram_id: int):
    """
    Retorna o teclado do menu principal de forma inteligente,
    verificando o status do usuário diretamente no banco de dados.
    """
    user = get_user_by_id(telegram_id)
    has_api_keys = user and user.api_key_encrypted is not None

    keyboard = []
    if has_api_keys:
        keyboard.append([InlineKeyboardButton("ℹ️ Meu Painel", callback_data='user_dashboard')])
        keyboard.append([InlineKeyboardButton("📊 Minhas Posições", callback_data='user_positions')])
        
        # --- BOTÃO ADICIONADO AQUI ---
        keyboard.append([InlineKeyboardButton("📈 Desempenho", callback_data='perf_today')])
        
        keyboard.append([InlineKeyboardButton("⚙️ Configurações de Trade", callback_data='user_settings')])
        keyboard.append([InlineKeyboardButton("🤖 Configuração do Bot", callback_data='bot_config')])
    else:
        keyboard.append([InlineKeyboardButton("⚙️ Configurar API Bybit", callback_data='config_api')])

    return InlineKeyboardMarkup(keyboard)

def dashboard_menu_keyboard():
    """Retorna o teclado para o painel do usuário, com a opção de remover a API."""
    keyboard = [
        [InlineKeyboardButton("🗑️ Remover API", callback_data='remove_api_prompt')],
        [InlineKeyboardButton("⬅️ Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def admin_menu_keyboard():
    """Retorna o teclado do menu de administrador."""
    keyboard = [
        [InlineKeyboardButton("📡 Listar Grupos/Canais", callback_data='admin_list_channels')],
        # --- NOVO BOTÃO ---
        [InlineKeyboardButton("👁️ Ver Alvos Ativos", callback_data='admin_view_targets')]
    ]
    return InlineKeyboardMarkup(keyboard)

def view_targets_keyboard():
    """Retorna o teclado para a tela de visualização de alvos, com um botão de voltar."""
    keyboard = [
        [InlineKeyboardButton("⬅️ Voltar ao Menu Admin", callback_data='back_to_admin_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def confirm_remove_keyboard():
    """Retorna o teclado de confirmação para remover a API."""
    keyboard = [
        [InlineKeyboardButton("✅ Sim, remover", callback_data='remove_api_confirm')],
        [InlineKeyboardButton("❌ Não, cancelar", callback_data='remove_api_cancel')],
    ]
    return InlineKeyboardMarkup(keyboard)

def settings_menu_keyboard(user_settings):
    """
    Retorna o teclado do menu de configurações, mostrando os valores atuais.
    """
    entry_percent = user_settings.entry_size_percent
    max_leverage = user_settings.max_leverage
    min_confidence = user_settings.min_confidence

    keyboard = [
        [InlineKeyboardButton(f"Tamanho da Entrada: {entry_percent:.2f}%", callback_data='set_entry_percent')],
        [InlineKeyboardButton(f"Alavancagem Máxima: {max_leverage}x", callback_data='set_max_leverage')],
        [InlineKeyboardButton(f"Confiança Mínima (IA): {min_confidence:.2f}%", callback_data='set_min_confidence')],
        # --- ADICIONE O NOVO BOTÃO AQUI ---
        [InlineKeyboardButton("✅ Whitelist de Moedas", callback_data='set_coin_whitelist')],
        [InlineKeyboardButton("⬅️ Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)


def bot_config_keyboard(user_settings):
    """
    Retorna o teclado para o menu de configuração do bot, mostrando o modo de aprovação e as metas.
    """
    # Botão de Modo de Aprovação (lógica existente)
    mode = user_settings.approval_mode
    if mode == 'AUTOMATIC':
        approval_button_text = "Entrada de Sinais: Automático ⚡"
    else:
        approval_button_text = "Entrada de Sinais: Manual 👋"

    # --- NOVOS BOTÕES DE METAS ---
    # Formata a meta de lucro para exibição
    profit_target = user_settings.daily_profit_target
    profit_text = f"Meta de Lucro Diária: ${profit_target:.2f}" if profit_target > 0 else "Meta de Lucro Diária: Desativada"

    # Formata o limite de perda para exibição
    loss_limit = user_settings.daily_loss_limit
    loss_text = f"Limite de Perda Diário: ${loss_limit:.2f}" if loss_limit > 0 else "Limite de Perda Diário: Desativado"

    keyboard = [
        [InlineKeyboardButton(approval_button_text, callback_data='toggle_approval_mode')],
        # --- NOVAS LINHAS ADICIONADAS AO TECLADO ---
        [InlineKeyboardButton(profit_text, callback_data='set_profit_target')],
        [InlineKeyboardButton(loss_text, callback_data='set_loss_limit')],
        [InlineKeyboardButton("⬅️ Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def signal_approval_keyboard(signal_for_approval_id: int):
    """
    Retorna o teclado com os botões de Aprovar/Rejeitar para um sinal manual.
    """
    keyboard = [
        [
            InlineKeyboardButton("✅ Aprovar Entrada", callback_data=f'approve_signal_{signal_for_approval_id}'),
            InlineKeyboardButton("❌ Rejeitar", callback_data=f'reject_signal_{signal_for_approval_id}')
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

def performance_menu_keyboard():
    """
    Retorna o teclado para o menu de análise de desempenho com filtros de período.
    """
    keyboard = [
        [
            InlineKeyboardButton("Hoje", callback_data='perf_today'),
            InlineKeyboardButton("Ontem", callback_data='perf_yesterday')
        ],
        [
            InlineKeyboardButton("Últimos 7 Dias", callback_data='perf_7_days'),
            InlineKeyboardButton("Últimos 30 Dias", callback_data='perf_30_days')
        ],
        [InlineKeyboardButton("⬅️ Voltar ao Menu Principal", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

========================================
# Arquivo: alembic/env.py
========================================

import os
import sys
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# Adiciona a raiz do projeto ao path para que possamos importar 'database.models'
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from database.models import Base

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # --- INÍCIO DA MODIFICAÇÃO ---
    # Pega a configuração do alembic.ini
    configuration = config.get_section(config.config_ini_section, {})
    # Tenta pegar a URL de uma variável de ambiente, se não existir, usa a do .ini
    url = os.getenv('DATABASE_URL', configuration['sqlalchemy.url'])
    configuration['sqlalchemy.url'] = url
    
    connectable = engine_from_config(
        configuration, # Usa a configuração modificada
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


========================================
# Arquivo: alembic/versions/09d80b6e64de_add_coin_whitelist_to_users.py
========================================

# Arquivo: alembic/versions/09d80b6e64de_add_coin_whitelist_to_users.py

"""add_coin_whitelist_to_users

Revision ID: 09d80b6e64de
Revises: 
Create Date: 2025-08-22 12:03:06.123456

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '09d80b6e64de'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('coin_whitelist', sa.String(), server_default='todas', nullable=False))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('users', 'coin_whitelist')
    # ### end Alembic commands ###

========================================
# Arquivo: services/__init__.py
========================================



========================================
# Arquivo: services/bybit_service.py
========================================

import logging
import asyncio
from typing import Dict, Any
from datetime import datetime, time, timedelta
from pybit.unified_trading import HTTP
from pybit.exceptions import InvalidRequestError
from database.models import User
from decimal import Decimal, ROUND_DOWN

logger = logging.getLogger(__name__)
INSTRUMENT_INFO_CACHE: Dict[str, Any] = {}

def _round_down_to_step(value: Decimal, step: Decimal) -> Decimal:
    # arredonda para baixo no múltiplo do step
    if step <= 0:
        return value
    return (value // step) * step

def _round_down_to_tick(price: Decimal, tick: Decimal) -> Decimal:
    if tick <= 0:
        return price
    return (price // tick) * tick

async def get_instrument_info(symbol: str) -> Dict[str, Any]:
    """
    Busca as regras de um instrumento (símbolo) da Bybit, usando um cache em memória.
    Retorna um dicionário com as regras ou um erro.
    """
    if symbol in INSTRUMENT_INFO_CACHE:
        return INSTRUMENT_INFO_CACHE[symbol]

    def _sync_call():
        try:
            session = HTTP(testnet=False)
            response = session.get_instruments_info(category="linear", symbol=symbol)
            
            if response.get("retCode") != 0:
                return {"success": False, "error": response.get("retMsg")}
            
            instrument_list = response.get("result", {}).get("list", [])
            if not instrument_list:
                return {"success": False, "error": f"Símbolo {symbol} não encontrado na Bybit."}

            info = instrument_list[0]
            lot_size_filter = info.get("lotSizeFilter", {})
            price_filter = info.get("priceFilter", {})

            rules = {
                "success": True,
                "status": info.get("status"),
                "qtyStep": Decimal(lot_size_filter.get("qtyStep", "0")),
                "minOrderQty": Decimal(lot_size_filter.get("minOrderQty", "0")),
                "minNotionalValue": Decimal(lot_size_filter.get("minOrderIv", "0")),
                "tickSize": Decimal(price_filter.get("tickSize", "0")),
            }
            INSTRUMENT_INFO_CACHE[symbol] = rules
            return rules
        except Exception as e:
            logger.error(f"Exceção em get_instrument_info para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


# Função auxiliar síncrona, não precisa de 'async'
def get_session(api_key: str, api_secret: str) -> HTTP:
    """Cria e retorna uma sessão HTTP para ser usada em threads."""
    return HTTP(
        testnet=False,
        api_key=api_key,
        api_secret=api_secret
    )

async def get_account_info(api_key: str, api_secret: str) -> dict:
    """Busca o saldo da conta, retornando dados detalhados incluindo a lista de moedas."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.get_wallet_balance(accountType="UNIFIED")

            if response.get('retCode') == 0:
                account_data_list = response['result'].get('list', [])
                if not account_data_list:
                    return {"success": False, "data": {}, "error": "Lista de contas vazia na resposta da API."}
                
                account_data = account_data_list[0]
                
                equity_str = account_data.get('totalEquity')
                total_equity = float(equity_str) if equity_str else 0.0
                coin_list = account_data.get('coin', [])

                available_balance_usdt = 0.0
                for coin_balance in coin_list:
                    if coin_balance.get('coin') == 'USDT':
                        available_str = coin_balance.get('availableToWithdraw')
                        available_balance_usdt = float(available_str) if available_str else 0.0
                        break
                
                return {
                    "success": True, 
                    "data": {
                        "total_equity": total_equity,
                        "available_balance_usdt": available_balance_usdt,
                        "coin_list": coin_list  # <-- Retornando a lista completa
                    }
                }
            return {"success": False, "data": {}, "error": response.get('retMsg', 'Erro desconhecido')}
        except Exception as e:
            logger.error(f"Exceção em get_account_info: {e}", exc_info=True)
            return {"success": False, "data": {}, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


async def place_order(api_key: str, api_secret: str, signal_data: dict, user_settings: User, balance: float) -> dict:
    """Abre uma nova posição a mercado (Market) com validação completa."""
    async def pre_flight_checks():
        symbol = signal_data['coin']
        if symbol not in INSTRUMENT_INFO_CACHE:
            await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            symbol = signal_data['coin']

            if not instrument_rules or not instrument_rules.get("success"):
                return instrument_rules or {"success": False, "error": f"Regras para {symbol} não encontradas."}
            if instrument_rules["status"] != "Trading":
                return {"success": False, "error": f"O símbolo {symbol} não está ativo para negociação ({instrument_rules['status']})."}

            session = get_session(api_key, api_secret)
            side = "Buy" if (signal_data.get('order_type') or '').upper() == 'LONG' else "Sell"
            leverage = Decimal(str(user_settings.max_leverage))
            entry_price = Decimal(str(signal_data['entries'][0]))
            margin_in_dollars = Decimal(str(balance)) * (Decimal(str(user_settings.entry_size_percent)) / Decimal("100"))
            notional_value = margin_in_dollars * leverage
            
            if entry_price <= 0: return {"success": False, "error": f"Preço de entrada inválido: {entry_price}"}

            qty_raw = notional_value / entry_price
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])

            if qty_adj < instrument_rules["minOrderQty"]:
                return {"success": False, "error": f"Qtd. ajustada ({qty_adj:f}) é menor que a mínima permitida ({instrument_rules['minOrderQty']:f}) para {symbol}."}
            
            final_notional_value = qty_adj * entry_price
            if final_notional_value < instrument_rules["minNotionalValue"]:
                return {"success": False, "error": f"Valor total da ordem (${final_notional_value:.2f}) é menor que o mínimo permitido de ${instrument_rules['minNotionalValue']:.2f}."}

            # --- LÓGICA CORRIGIDA ---
            payload = {
                "category": "linear", "symbol": symbol, "side": side,
                "orderType": "Market", "qty": str(qty_adj),
                "takeProfit": str((signal_data.get('targets') or [None])[0]),
                "stopLoss": str(signal_data.get('stop_loss')),
            }

            try:
                session.set_leverage(category="linear", symbol=symbol, buyLeverage=str(leverage), sellLeverage=str(leverage))
            except InvalidRequestError as e:
                if "leverage not modified" in str(e).lower():
                    logger.warning(f"Alavancagem para {symbol} já está correta. Continuando...")
                else:
                    return {"success": False, "error": str(e)} # Retorna outros erros de alavancagem

            response = session.place_order(**{k: v for k, v in payload.items() if v is not None})
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            return {"success": False, "error": response.get('retMsg')}
        
        except Exception as e:
            logger.error(f"Exceção ao abrir ordem (Market): {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"Exceção em place_order (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}


async def get_market_price(symbol: str) -> dict:
    """Busca o preço de mercado atual de forma assíncrona."""
    def _sync_call():
        try:
            session = HTTP(testnet=False)
            response = session.get_tickers(category="linear", symbol=symbol)
            if response.get('retCode') == 0 and response['result']['list']:
                price = float(response['result']['list'][0]['lastPrice'])
                return {"success": True, "price": price}
            else:
                return {"success": False, "error": response.get('retMsg', 'Preço não encontrado')}
        except Exception as e:
            logger.error(f"Exceção ao buscar preço de mercado para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def close_partial_position(api_key: str, api_secret: str, symbol: str, qty_to_close: float, side: str) -> dict:
    """Fecha parte de uma posição com Market/ReduceOnly, usando o novo sistema de regras."""
    async def pre_flight_checks():
        if symbol not in INSTRUMENT_INFO_CACHE:
            await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            # 1. VALIDAÇÃO DAS REGRAS
            if not instrument_rules or not instrument_rules.get("success"):
                return instrument_rules or {"success": False, "error": f"Regras para {symbol} não encontradas."}

            session = get_session(api_key, api_secret)
            close_side = "Sell" if side == 'LONG' else "Buy"

            # 2. CÁLCULO DE QUANTIDADE
            qty_raw = Decimal(str(qty_to_close))
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])

            logger.info(f"[bybit_service] close_partial {symbol}: raw={qty_raw}, step={instrument_rules['qtyStep']}, minQty={instrument_rules['minOrderQty']} => adj={qty_adj}")

            if qty_adj < instrument_rules["minOrderQty"]:
                # Se a quantidade a ser fechada for menor que o mínimo, ignoramos a operação
                # Isso não é um erro, apenas não há o que fazer.
                logger.warning(f"Quantidade a fechar para {symbol} ({qty_adj:f}) é menor que o mínimo permitido. Ignorando fechamento parcial.")
                return {"success": True, "skipped": True, "reason": "qty_less_than_min_order_qty"}

            # 3. EXECUÇÃO
            response = session.place_order(
                category="linear", symbol=symbol, side=close_side,
                orderType="Market", qty=str(qty_adj), reduceOnly=True
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}

        except Exception as e:
            logger.error(f"Exceção ao fechar posição parcial: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"Exceção em close_partial_position (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}


async def modify_position_stop_loss(api_key: str, api_secret: str, symbol: str, new_stop_loss: float) -> dict:
    """Modifica o Stop Loss de uma posição aberta de forma assíncrona."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.set_trading_stop(
                category="linear", symbol=symbol, stopLoss=str(new_stop_loss)
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"Exceção ao modificar Stop Loss: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def get_open_positions(api_key: str, api_secret: str) -> dict:
    return await get_open_positions_with_pnl(api_key, api_secret)

async def get_pnl_for_period(api_key: str, api_secret: str, start_time: datetime, end_time: datetime) -> dict:
    """Busca o P/L (Lucro/Prejuízo) realizado para um período de tempo específico."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            
            start_timestamp_ms = int(start_time.timestamp() * 1000)
            end_timestamp_ms = int(end_time.timestamp() * 1000)

            response = session.get_closed_pnl(
                category="linear",
                startTime=start_timestamp_ms,
                endTime=end_timestamp_ms,
                limit=200 # Aumentar o limite para buscar mais trades em períodos longos
            )

            if response.get('retCode') == 0:
                pnl_list = response.get('result', {}).get('list', [])
                total_pnl = sum(float(item.get('closedPnl', 0)) for item in pnl_list)
                return {"success": True, "pnl": total_pnl}
            else:
                error_msg = response.get('retMsg', 'Erro desconhecido ao buscar P/L.')
                logger.error(f"Erro da API Bybit ao buscar P/L: {error_msg}")
                return {"success": False, "error": error_msg}

        except Exception as e:
            logger.error(f"Exceção em get_pnl_for_period: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


async def get_daily_pnl(api_key: str, api_secret: str) -> dict:
    """Busca o P/L realizado para o dia atual (agora usa a função genérica)."""
    today_start = datetime.combine(datetime.today(), time.min)
    now = datetime.now()
    return await get_pnl_for_period(api_key, api_secret, today_start, now)


# --- FUNÇÃO PARA ENVIAR ORDEM LIMITE ---
async def place_limit_order(api_key: str, api_secret: str, signal_data: dict, user_settings: User, balance: float) -> dict:
    """Envia uma nova ordem limite para a Bybit com validação completa."""
    async def pre_flight_checks():
        symbol = signal_data['coin']
        if symbol not in INSTRUMENT_INFO_CACHE:
            await get_instrument_info(symbol)
        return INSTRUMENT_INFO_CACHE.get(symbol)

    def _sync_call(instrument_rules: Dict[str, Any]):
        try:
            symbol = signal_data['coin']
            
            if not instrument_rules or not instrument_rules.get("success"):
                return instrument_rules or {"success": False, "error": f"Regras para {symbol} não encontradas."}
            if instrument_rules["status"] != "Trading":
                return {"success": False, "error": f"O símbolo {symbol} não está ativo para negociação ({instrument_rules['status']})."}

            session = get_session(api_key, api_secret)
            side = "Buy" if (signal_data.get('order_type') or '').upper() == 'LONG' else "Sell"
            leverage = Decimal(str(user_settings.max_leverage))
            price = Decimal(str(signal_data.get('limit_price')))
            price_adj = (price // instrument_rules["tickSize"]) * instrument_rules["tickSize"]
            margin_in_dollars = Decimal(str(balance)) * (Decimal(str(user_settings.entry_size_percent)) / Decimal("100"))
            notional_value = margin_in_dollars * leverage

            if price_adj <= 0: return {"success": False, "error": f"Preço de entrada inválido após ajuste: {price_adj}"}
            
            qty_raw = notional_value / price_adj
            qty_adj = _round_down_to_step(qty_raw, instrument_rules["qtyStep"])
            
            if qty_adj < instrument_rules["minOrderQty"]:
                return {"success": False, "error": f"Qtd. ajustada ({qty_adj:f}) é menor que a mínima permitida ({instrument_rules['minOrderQty']:f}) para {symbol}."}
            final_notional_value = qty_adj * price_adj
            if final_notional_value < instrument_rules["minNotionalValue"]:
                return {"success": False, "error": f"Valor total da ordem (${final_notional_value:.2f}) é menor que o mínimo permitido de ${instrument_rules['minNotionalValue']:.2f}."}

            # --- LÓGICA CORRIGIDA ---
            payload = {
                "category": "linear", "symbol": symbol, "side": side,
                "orderType": "Limit", "qty": str(qty_adj), "price": str(price_adj),
                "takeProfit": str((signal_data.get('targets') or [None])[0]),
                "stopLoss": str(signal_data.get('stop_loss')),
            }

            try:
                session.set_leverage(category="linear", symbol=symbol, buyLeverage=str(leverage), sellLeverage=str(leverage))
            except InvalidRequestError as e:
                if "leverage not modified" in str(e).lower():
                    logger.warning(f"Alavancagem para {symbol} já está correta. Continuando...")
                else:
                    return {"success": False, "error": str(e)}

            response = session.place_order(**{k: v for k, v in payload.items() if v is not None})
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            return {"success": False, "error": response.get('retMsg')}

        except Exception as e:
            logger.error(f"Exceção ao abrir ordem (Limit): {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    try:
        rules = await pre_flight_checks()
        return await asyncio.to_thread(_sync_call, rules)
    except Exception as e:
        logger.error(f"Exceção em place_limit_order (async): {e}", exc_info=True)
        return {"success": False, "error": str(e)}


# --- FUNÇÃO PARA VERIFICAR STATUS DE UMA ORDEM ---
async def get_order_status(api_key: str, api_secret: str, order_id: str, symbol: str) -> dict:
    """Verifica o status de uma ordem específica na Bybit, procurando em ordens abertas."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            # --- CORREÇÃO: MUDAMOS PARA get_open_orders ---
            response = session.get_open_orders(
                category="linear",
                symbol=symbol,
                orderId=order_id,
            )
            if response.get('retCode') == 0:
                order_list = response.get('result', {}).get('list', [])
                if order_list:
                    # A ordem foi encontrada na lista de ordens abertas
                    return {"success": True, "data": order_list[0]}
                else:
                    # Se não está nas ordens abertas, pode já ter sido executada ou cancelada.
                    # Por segurança, vamos verificar o histórico também.
                    hist_response = session.get_order_history(category="linear", orderId=order_id)
                    if hist_response.get('retCode') == 0:
                        hist_list = hist_response.get('result', {}).get('list', [])
                        if hist_list:
                            return {"success": True, "data": hist_list[0]}
                    
                    return {"success": False, "error": "Ordem não encontrada nem nas abertas nem no histórico."}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"Exceção ao verificar status da ordem: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)


# --- FUNÇÃO PARA CANCELAR UMA ORDEM ---
async def cancel_order(api_key: str, api_secret: str, order_id: str, symbol: str) -> dict:
    """Cancela uma ordem limite pendente na Bybit."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.cancel_order(
                category="linear",
                symbol=symbol,
                orderId=order_id
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"Exceção ao cancelar ordem: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

# --- PNL FECHADO (PERFORMANCE) ---
async def get_closed_pnl_breakdown(api_key: str, api_secret: str, start_time: datetime, end_time: datetime) -> dict:
    """
    Retorna o P/L total e contagem de ganhos/perdas no período informado.
    Usa o endpoint oficial de closed PnL e pagina os resultados se o período for > 7 dias.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)

            total_pnl = 0.0
            total_wins = 0
            total_losses = 0
            all_items = []

            current_start = start_time

            while current_start < end_time:
                # Calcula o fim da janela atual, limitado a 7 dias ou ao fim do período total
                current_end = min(current_start + timedelta(days=7), end_time)

                logger.info(f"[bybit_service] Buscando PnL de {current_start.strftime('%Y-%m-%d')} a {current_end.strftime('%Y-%m-%d')}")

                resp = session.get_closed_pnl(
                    category="linear",
                    startTime=int(current_start.timestamp() * 1000),
                    endTime=int(current_end.timestamp() * 1000),
                    limit=200,
                )

                if resp.get("retCode") != 0:
                    error_msg = resp.get("retMsg", f"Erro desconhecido na paginação de PnL (start={current_start})")
                    logger.error(f"Erro da API Bybit em get_closed_pnl_breakdown: {error_msg}")
                    # Retorna o erro da primeira falha
                    return {"success": False, "error": error_msg}

                items = resp.get("result", {}).get("list", []) or []
                all_items.extend(items)

                # Avança o início da próxima janela
                current_start += timedelta(days=7)

            # Processa a lista completa de itens coletados
            for it in all_items:
                pnl = float(it.get("closedPnl", 0) or 0)
                total_pnl += pnl
                if pnl > 0:
                    total_wins += 1
                elif pnl < 0:
                    total_losses += 1

            return {
                "success": True,
                "total_pnl": total_pnl,
                "wins": total_wins,
                "losses": total_losses,
                "trades": len(all_items),
            }
        except Exception as e:
            logger.error(f"Exceção em get_closed_pnl_breakdown: {e}", exc_info=True)
            return {"success": False, "error": str(e)}

    return await asyncio.to_thread(_sync_call)


# --- POSIÇÕES ABERTAS COM PNL ATUAL ---
async def get_open_positions_with_pnl(api_key: str, api_secret: str) -> dict:
    """
    Lista posições abertas com avgPrice, markPrice e P/L atual (valor e %).
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            resp = session.get_positions(category="linear", settleCoin="USDT")
            if resp.get("retCode") != 0:
                return {"success": False, "error": resp.get("retMsg", "erro")}
            out = []
            for p in (resp.get("result", {}).get("list", []) or []):
                size = float(p.get("size", 0) or 0)
                if size <= 0:
                    continue
                symbol = p.get("symbol")
                side = "LONG" if (p.get("side") == "Buy") else "SHORT"
                entry = float(p.get("avgPrice", 0) or 0)
                mark = float((p.get("markPrice") or 0) or 0)
                # se mark vier 0, tenta buscar via tickers
                if not mark and symbol:
                    try:
                        t = session.get_tickers(category="linear", symbol=symbol)
                        mark = float(t["result"]["list"][0]["lastPrice"])
                    except Exception:
                        pass
                if not entry or not mark:
                    # não dá pra calcular PnL sem preço
                    pnl = 0.0
                    pnl_pct = 0.0
                else:
                    diff = (mark - entry) if side == "LONG" else (entry - mark)
                    pnl = diff * size
                    pnl_pct = (diff / entry) * 100.0 if entry else 0.0
                out.append({
                    "symbol": symbol,
                    "side": side,
                    "size": size,
                    "entry": entry,
                    "mark": mark,
                    "unrealized_pnl": pnl,
                    "unrealized_pnl_pct": pnl_pct,
                })
            return {"success": True, "data": out}
        except Exception as e:
            logger.error(f"Exceção em get_open_positions_with_pnl: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

# Adicione esta nova função em services/bybit_service.py
# Pode ser adicionada após a função modify_position_stop_loss

async def get_specific_position_size(api_key: str, api_secret: str, symbol: str) -> float:
    """
    Busca o tamanho (size) de uma posição específica aberta na Bybit.
    Retorna 0.0 se a posição não existir.
    """
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            # Usamos o filtro de símbolo para buscar apenas a posição de interesse
            response = session.get_positions(category="linear", symbol=symbol)
            
            if response.get('retCode') == 0:
                position_list = response.get('result', {}).get('list', [])
                if position_list and position_list[0]:
                    # Retorna o tamanho da primeira (e única) posição na lista
                    return float(position_list[0].get('size', 0.0))
            # Se a lista estiver vazia ou houver erro, a posição não existe ou não foi encontrada
            return 0.0
        except Exception as e:
            logger.error(f"Exceção em get_specific_position_size para {symbol}: {e}", exc_info=True)
            return 0.0 # Em caso de erro, assumimos que não há posição para evitar fechamentos indevidos

    return await asyncio.to_thread(_sync_call)

========================================
# Arquivo: services/notification_service.py
========================================

import logging
from telegram.ext import Application
from utils.config import ADMIN_ID

logger = logging.getLogger(__name__)

async def send_notification(application: Application, message: str):
    """
    Envia uma mensagem de notificação para o administrador do bot.
    """
    if not application:
        logger.warning("Tentativa de enviar notificação sem a instância da aplicação.")
        return
    try:
        await application.bot.send_message(
            chat_id=ADMIN_ID,
            text=message,
            parse_mode='HTML'
        )
        logger.info(f"Notificação enviada para o admin: {message[:50]}...")
    except Exception as e:
        logger.error(f"Falha ao enviar notificação para o admin: {e}")

========================================
# Arquivo: services/signal_parser.py
========================================

import re
import logging
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)

# --- DEFINIÇÃO CENTRALIZADA DOS TIPOS DE SINAL ---
class SignalType:
    MARKET = 'MARKET'
    LIMIT = 'LIMIT'
    CANCELAR = 'CANCELAR'


# -----------------------
# Helpers de normalização
# -----------------------
_FLOAT = r'[-+]?\d+(?:[.,]\d+)?'

def _to_float(x: str) -> float:
    """Converte string com vírgula ou ponto para float."""
    if x is None:
        return 0.0
    x = x.strip().replace(' ', '').replace(',', '.')
    # remove percentuais e símbolos residuais
    x = re.sub(r'[^0-9.+-]', '', x)
    try:
        return float(x)
    except Exception:
        return 0.0

def _normalize_symbol(coin_raw: str) -> str:
    coin = (coin_raw or '').strip().upper()
    # remove emojis e lixo
    coin = re.sub(r'[^A-Z0-9]', '', coin)
    # alguns sinais usam par completo (ex.: AVAXUSDT)
    if coin.endswith('USDT') or coin.endswith('USD'):
        return coin if coin.endswith('USDT') else f'{coin}T'  # USD -> USDT (fail-safe)
    return f'{coin}USDT' if coin else coin

def _pick_first_number(text: str) -> Optional[float]:
    m = re.search(_FLOAT, text)
    return _to_float(m.group(0)) if m else None

def _findall_numbers(text: str) -> List[float]:
    return [_to_float(g) for g in re.findall(_FLOAT, text or '')]


# ----------------------------------------------------
# Padrões de alto nível (ordem importa: específicos 1º)
# ----------------------------------------------------
CANCEL_PATTERN = re.compile(r'⚠️\s*([A-Za-z0-9]+)[^\n]*sinal\s*cancelad[oa]', re.IGNORECASE)

# “Ordem Limite” / “Ordem a/à Mercado” podem aparecer em qualquer lugar
IS_MARKET_PATTERN = re.compile(r'Ordem\s*(?:à|a)?\s*Mercado', re.IGNORECASE)
IS_LIMIT_PATTERN  = re.compile(r'Ordem\s*Limite', re.IGNORECASE)

# Verificador de “sinal completo”
FULL_SIGNAL_GUARD = re.compile(r'(?=.*(?:Moeda|Coin|Pair)\s*:)(?=.*Tipo\s*:)(?=.*Stop\s*Loss\s*:)', re.IGNORECASE | re.DOTALL)


# ---------------------------
# Extrator de sinal “completo”
# ---------------------------
def _full_signal_extractor(message_text: str) -> Optional[Dict[str, Any]]:

    def find_single_value(pattern: str, text: str) -> Optional[str]:
        # Usa .*? para pular emojis e rótulos adicionais na linha
        m = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
        return m.group(1).strip() if m else None

    # --- Campos básicos ---
    coin_raw = find_single_value(r'(?:Moeda|Coin|Pair)\s*:\s*([A-Za-z0-9 ._-]+)', message_text)
    order_type_raw = find_single_value(r'Tipo\s*:\s*([A-Za-z ]+)', message_text)
    entry_raw = find_single_value(r'Zona\s*de\s*Entrada\s*:\s*([^\n\r]+)', message_text)
    sl_raw = find_single_value(r'Stop\s*Loss\s*:\s*([^\n\r]+)', message_text)

    # targets: T1:, T2:, ...
    targets = []
    for tlabel, val in re.findall(r'(?:^|\n)\s*T(\d+)\s*:\s*([^\n\r]+)', message_text, flags=re.IGNORECASE):
        n = _pick_first_number(val)
        if n is not None:
            targets.append(n)

    # confiança (se existir)
    conf_raw = find_single_value(r'Confian[çc]a\s*:\s*([0-9.,]+)\s*%', message_text)
    confidence = _to_float(conf_raw) if conf_raw else None

    # normalizações
    coin = _normalize_symbol(coin_raw or '')
    order_type = 'LONG'
    if order_type_raw:
        if 'SHORT' in order_type_raw.upper():
            order_type = 'SHORT'
        elif 'LONG' in order_type_raw.upper():
            order_type = 'LONG'

    # entradas
    entries: List[float] = []
    if entry_raw:
        nums = _findall_numbers(entry_raw)
        # muitos sinais colocam "x - y"; se só tem um número, trata como lista única
        if len(nums) == 1:
            entries = [nums[0]]
        elif len(nums) >= 2:
            entries = [nums[0], nums[1]]
        else:
            entries = []

    # stop
    stop_loss = _pick_first_number(sl_raw or '') or 0.0

    # --- Determinação do tipo (MARKET x LIMIT) ---
    # 1) texto explícito
    is_market_text = bool(IS_MARKET_PATTERN.search(message_text))
    is_limit_text  = bool(IS_LIMIT_PATTERN.search(message_text))

    # 2) heurística: “entrada única” OU faixa idêntica => MARKET
    entries_imply_market = False
    if entries:
        if len(entries) == 1:
            entries_imply_market = True
        elif len(entries) >= 2 and abs(entries[0] - entries[1]) < 1e-10:
            entries_imply_market = True

    # decisão final
    if is_market_text or (not is_limit_text and entries_imply_market):
        signal_kind = SignalType.MARKET
        # para MARKET garantimos entries[0] preenchida (usa o primeiro número visto no bloco de entrada)
        if not entries and entry_raw:
            n = _pick_first_number(entry_raw)
            entries = [n] if n is not None else []
    else:
        signal_kind = SignalType.LIMIT

    if not coin or not entries or stop_loss == 0.0:
        logger.debug("Parser: campos essenciais ausentes: coin=%s entries=%s stop=%s", coin, entries, stop_loss)
        return None

    return {
        "type": signal_kind,
        "coin": coin,
        "order_type": order_type,          # LONG | SHORT
        "entries": entries,                # [preço] ou [min, max]
        "stop_loss": stop_loss,
        "targets": targets,                # [t1, t2, ...]
        "confidence": confidence,          # opcional (float ou None)
    }


# -----------------
# Função de entrada
# -----------------
def parse_signal(message_text: str) -> Optional[Dict[str, Any]]:
    """
    Identifica e extrai sinais:
      - CANCELAMENTO: '⚠️ <COIN> ... sinal cancelad(o/a)'
      - ENTRADA COMPLETA: campos Moeda/Coin/Pair, Tipo, Stop Loss (com 'Ordem Limite' ou 'Ordem à Mercado')
    Retorna um dicionário com os campos normalizados ou None se não reconhecer.
    """
    if not message_text or not isinstance(message_text, str):
        return None

    text = message_text.strip()

    # 1) Cancelamento
    m_cancel = CANCEL_PATTERN.search(text)
    if m_cancel:
        coin = _normalize_symbol(m_cancel.group(1))
        return {"type": SignalType.CANCELAR, "coin": coin}

    # 2) Sinal de entrada (guarda)
    if not FULL_SIGNAL_GUARD.search(text):
        return None

    data = _full_signal_extractor(text)
    return data

========================================
# Arquivo: services/telethon_service.py
========================================

import logging
import asyncio
import os
import re
from telegram.ext import Application
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telethon.sync import TelegramClient
from telethon import events
from telethon.errors.rpcerrorlist import ChannelForumMissingError, ChannelInvalidError
from telethon.tl.functions.channels import GetForumTopicsRequest
from utils.config import API_ID, API_HASH
from database.session import SessionLocal
from database.models import MonitoredTarget
from .signal_parser import parse_signal

logger = logging.getLogger(__name__)

# --- LÓGICA DE CAMINHO DINÂMICO ---
if os.path.isdir('/data'):
    SESSION_PATH = '/data/tradeflow_user'
else:
    SESSION_PATH = 'tradeflow_user'

# --- DEFINIÇÃO ÚNICA E CORRETA DO CLIENTE ---
client = TelegramClient(SESSION_PATH, API_ID, API_HASH)
comm_queue = None
# Cache em memória para armazenar os IDs das mensagens já processadas e evitar duplicidade.
PROCESSED_MESSAGE_IDS = set()


# --- Funções de Busca (Helpers) ---

def get_monitored_targets():
    """Busca no DB a lista de todos os alvos (canal/tópico) monitorados."""
    db = SessionLocal()
    try:
        return db.query(MonitoredTarget).all()
    finally:
        db.close()

async def list_channels():
    """Lista todos os canais e supergrupos com logging detalhado."""
    logger.info("[list_channels] Iniciando busca de diálogos...")
    channels = []
    count = 0
    try:
        async for dialog in client.iter_dialogs():
            count += 1
            if count % 50 == 0:
                logger.info(f"[list_channels] ... processou {count} diálogos...")
            
            if dialog.is_channel:
                channels.append((dialog.name, dialog.id))
        
        logger.info(f"[list_channels] Busca de diálogos finalizada. Total de {count} diálogos processados.")
    except Exception as e:
        logger.error(f"[list_channels] Erro durante iter_dialogs: {e}", exc_info=True)
        
    return channels

async def list_channel_topics(channel_id: int):
    """Busca os tópicos de um canal específico."""
    topics = []
    try:
        entity = await client.get_entity(channel_id)
        result = await client(GetForumTopicsRequest(
            channel=entity, offset_date=0, offset_id=0, offset_topic=0, limit=100
        ))
        for topic in result.topics:
            topics.append((topic.title, topic.id))
            
    except (ChannelForumMissingError, ChannelInvalidError):
        logger.warning(f"Canal {channel_id} não possui tópicos (não é um fórum).")
        
    except Exception as e:
        logger.error(f"Exceção em list_channel_topics para o canal {channel_id}: {e}", exc_info=True)
        
    return topics

# --- Listener de Sinais ---
# Em vez de filtrar por regex no decorator, ouvimos TUDO e deixamos o parser decidir.
from telethon import events

@client.on(events.NewMessage)          # novas mensagens
@client.on(events.MessageEdited)       # mensagens editadas (muitos canais editam depois)
async def signal_listener(event):
    """
    Ouve TODAS as mensagens nos canais/grupos e:
      - loga que chegou
      - decide se é alvo monitorado
      - tenta parsear
      - loga 'é sinal' ou 'não é sinal'
      - se for sinal, coloca na fila para processamento
    """
    global comm_queue

    # sanity checks
    if not isinstance(event, (events.NewMessage.Event, events.MessageEdited.Event)):
        return
    if not comm_queue:
        return

    # texto bruto (mais robusto do que event.text em alguns casos)
    text = (getattr(event, "raw_text", None)
            or getattr(getattr(event, "message", None), "message", None)
            or "")
    chat_id = getattr(event, "chat_id", None)
    message_id = getattr(getattr(event, "message", None), "id", None)
    topic_id = event.reply_to.reply_to_msg_id if getattr(event, "reply_to", None) else None

    # LOG: sempre que chega algo
    preview = text.replace("\n", " ")[:120]
    logger.info(f"📨 [Telethon] Mensagem recebida | chat_id={chat_id} | msg_id={message_id} | preview={preview!r}")

    # Verifica se é um alvo monitorado (canal/tópico)
    monitored_targets = get_monitored_targets()
    if not monitored_targets:
        logger.info("⏭️ [Telethon] Não há alvos monitorados configurados.")
        return

    is_target = any(
        (t.channel_id == chat_id and ((t.topic_id is None and topic_id is None) or t.topic_id == topic_id))
        for t in monitored_targets
    )
    if not is_target:
        logger.info(f"⏭️ [Telethon] Mensagem fora dos alvos monitorados (chat_id={chat_id}, topic_id={topic_id}).")
        return

    # Evita duplicidade apenas quando JÁ identificamos como sinal
    if message_id in PROCESSED_MESSAGE_IDS:
        logger.info(f"⏭️ [Telethon] Mensagem {message_id} já processada anteriormente. Ignorando duplicata/edição.")
        return

    # Tenta parsear
    from services.signal_parser import parse_signal  # import local p/ evitar ciclos
    parsed = parse_signal(text)

    if parsed:
        logger.info(
            "✅ [Telethon] É sinal! "
            f"type={parsed.get('type')} coin={parsed.get('coin')} "
            f"order={parsed.get('order_type')} entries={parsed.get('entries')} sl={parsed.get('stop_loss')}"
        )
        # marca como processado só quando for SINAL
        if message_id is not None:
            PROCESSED_MESSAGE_IDS.add(message_id)

        # Enfileira para o processador com um source_name informativo
        await comm_queue.put({
            "action": "process_signal",
            "signal_text": text,
            "source_name": f"telegram:{chat_id}"
        })
    else:
        logger.debug("⏭️ [Telethon] Chegou mensagem aqui - não é sinal.")

# --- Processador da Fila ---

async def queue_processor(queue: asyncio.Queue, ptb_app: Application):
    """Processa pedidos da fila, agora passando o 'source_name' adiante."""
    global comm_queue
    comm_queue = queue
    from core.trade_manager import process_new_signal

    while True:
        request = await queue.get()
        action = request.get("action")
        logger.info(f"[Queue Processor] ==> Pedido recebido! Ação: '{action}'")
        
        try:
            if action == "list_channels":
                logger.info("[Queue Processor] ... Entrou no bloco de 'list_channels'.")
                chat_id = request.get("chat_id")
                message_id = request.get("message_id")
                channels = await list_channels()
                db = SessionLocal()
                monitored_channels_ids = {target.channel_id for target in db.query(MonitoredTarget).all()}
                db.close()
                keyboard = []
                
                if channels:
                    for channel_name, channel_id in channels:
                        suffix = " ✅" if channel_id in monitored_channels_ids else ""
                        keyboard.append([InlineKeyboardButton(f"{channel_name}{suffix}", callback_data=f"monitor_channel_{channel_id}")])
                
                if keyboard:
                    await ptb_app.bot.edit_message_text(
                        chat_id=chat_id, message_id=message_id,
                        text="Selecione um grupo/canal (✅ = algum monitoramento ativo):",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    await ptb_app.bot.edit_message_text(chat_id=chat_id, message_id=message_id, text="Nenhum canal ou supergrupo encontrado.")

            elif action == "list_topics":
                logger.info("[Queue Processor] ... Entrou no bloco de 'list_topics'.")
                channel_id = request.get("channel_id")
                chat_id = request.get("chat_id")
                message_id = request.get("message_id")
                channel_name = request.get("channel_name")
                
                topics = await list_channel_topics(channel_id)
                db = SessionLocal()
                
                try:
                    if topics:
                        monitored_topic_ids = {t.topic_id for t in db.query(MonitoredTarget).filter_by(channel_id=channel_id).all() if t.topic_id}
                        keyboard = [[InlineKeyboardButton("⬅️ Voltar para Grupos", callback_data="admin_list_channels")]]
                        for name, topic_id in topics:
                            suffix = " ✅" if topic_id in monitored_topic_ids else ""
                            keyboard.append([InlineKeyboardButton(f"{name}{suffix}", callback_data=f"monitor_topic_{channel_id}_{topic_id}")])
                        
                        await ptb_app.bot.edit_message_text(
                            chat_id=chat_id, message_id=message_id,
                            text="Selecione o tópico para monitorar (✅ = já monitorado):",
                            reply_markup=InlineKeyboardMarkup(keyboard)
                        )
                    else:
                        existing = db.query(MonitoredTarget).filter_by(channel_id=channel_id, topic_id=None).first()
                        if existing:
                            db.delete(existing)
                            feedback_msg = f"❌ Canal '{channel_name}' removido da lista de monitoramento."
                        else:
                            new_target = MonitoredTarget(channel_id=channel_id, channel_name=channel_name)
                            db.add(new_target)
                            feedback_msg = f"✅ Canal '{channel_name}' adicionado à lista de monitoramento."
                        
                        db.commit()
                        await ptb_app.bot.edit_message_text(chat_id=chat_id, message_id=message_id, text=feedback_msg)
                finally:
                    db.close()

            elif action == "process_signal":
                logger.info("[Queue Processor] ... Entrou no bloco de 'process_signal'.")
                signal_text = request.get("signal_text")
                source_name = request.get("source_name", "Fonte Desconhecida")
                
                signal_data = parse_signal(signal_text)
                if signal_data:
                    await process_new_signal(signal_data, ptb_app, source_name)
                else:
                    logger.info("Mensagem da fila não é um sinal válido.")
            
            else:
                logger.warning(f"[Queue Processor] Ação desconhecida ou nula recebida: '{action}'")

        except Exception as e:
            logger.error(f"Erro CRÍTICO no processador da fila ao manusear a ação '{action}': {e}", exc_info=True)
        finally:
            queue.task_done()
            logger.info(f"[Queue Processor] <== Pedido '{action}' finalizado.")

# --- Função Principal do Serviço ---

async def start_signal_monitor(queue: asyncio.Queue):
    """Inicia o cliente Telethon, o ouvinte de sinais e o processador da fila."""
    logger.info("Iniciando monitor de sinais com Telethon...")
    
    await client.start()
    
    ptb_app = await queue.get()

    logger.info("✅ Monitor de sinais e processador de fila ativos.")
    
    asyncio.create_task(queue_processor(queue, ptb_app))
    
    await client.run_until_disconnected()

