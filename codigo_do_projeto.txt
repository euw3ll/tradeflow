========================================
# Arquivo: Dockerfile
========================================

# Usa uma imagem oficial do Python como base
FROM python:3.11-slim

# Define o diret√≥rio de trabalho dentro do container
WORKDIR /app

# --- NOVA SE√á√ÉO: INSTALA√á√ÉO DO TAILSCALE ---
# Adiciona pacotes necess√°rios para a instala√ß√£o e funcionamento do Tailscale
RUN apt-get update && apt-get install -y ca-certificates curl gnupg && \
    # Adiciona o reposit√≥rio do Tailscale
    curl -fsSL https://pkgs.tailscale.com/stable/debian/bookworm.noarmor.gpg | tee /usr/share/keyrings/tailscale-archive-keyring.gpg >/dev/null && \
    curl -fsSL https://pkgs.tailscale.com/stable/debian/bookworm.tailscale-keyring.list | tee /etc/apt/sources.list.d/tailscale.list && \
    # Instala o Tailscale
    apt-get update && apt-get install -y tailscale && \
    # Limpa o cache
    rm -rf /var/lib/apt/lists/*
# ----------------------------------------------

# Copia o arquivo de depend√™ncias primeiro
COPY requirements.txt .

# Instala as depend√™ncias do Python
RUN pip install --no-cache-dir -r requirements.txt

# Copia todo o resto do c√≥digo do projeto
COPY . .

# Comando que ser√° executado quando o container iniciar
CMD ["./start.sh"]

========================================
# Arquivo: fly.toml
========================================

app = "tradeflow"
primary_region = "gru"

[build]
  dockerfile = "Dockerfile"

[mounts]
  source = "tradeflow_data"
  destination = "/data"

[processes]
  app = "./start.sh" # Agora o processo principal √© nosso script

========================================
# Arquivo: main.py
========================================

import logging
import asyncio
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, 
    ConversationHandler, CallbackQueryHandler
)
from utils.config import TELEGRAM_TOKEN
from bot.handlers import (
    start, receive_invite_code, cancel, WAITING_CODE,
    config_api, receive_api_key, receive_api_secret, WAITING_API_KEY, WAITING_API_SECRET,
    remove_api_prompt, remove_api_action, CONFIRM_REMOVE_API,
    my_positions_handler, user_dashboard_handler, user_settings_handler,
    back_to_main_menu_handler,
    ask_risk_percent, receive_risk_percent, ASKING_RISK_PERCENT,
    ask_max_leverage, receive_max_leverage, ASKING_MAX_LEVERAGE,
    ask_min_confidence, receive_min_confidence, ASKING_MIN_CONFIDENCE,
    admin_menu, list_channels_handler, select_channel_to_monitor, select_topic_to_monitor,
    report_handler, manual_close_handler, admin_view_targets_handler, back_to_admin_menu_handler,
    bot_config_handler, toggle_approval_mode_handler, handle_signal_approval
)
from database.session import init_db
from services.telethon_service import start_signal_monitor
from core.position_tracker import run_tracker

# --- Configura√ß√£o do Logging ---
logging.basicConfig(
    format="%(asctime)s - [%(levelname)s] - %(name)s - %(message)s",
    level=logging.INFO
)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("telegram").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)

async def run_ptb(application: Application, queue: asyncio.Queue):
    """Inicializa e roda a aplica√ß√£o python-telegram-bot."""
    application.bot_data['comm_queue'] = queue
    logger.info("Inicializando o bot do Telegram (PTB)...")
    await application.initialize()
    await application.start()
    await application.updater.start_polling()
    logger.info("‚úÖ Bot do Telegram (PTB) ativo.")

async def main():
    """Configura os handlers e inicia o PTB e o Telethon em paralelo."""
    init_db()
    comm_queue = asyncio.Queue()
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    await comm_queue.put(application)

    # --- Handlers de Conversa ---
    register_conv = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={ WAITING_CODE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_invite_code)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    api_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(config_api, pattern='^config_api$')],
        states={
            WAITING_API_KEY: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_api_key)],
            WAITING_API_SECRET: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_api_secret)],
        },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    remove_api_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(remove_api_prompt, pattern='^remove_api_prompt$')],
        states={ CONFIRM_REMOVE_API: [CallbackQueryHandler(remove_api_action, pattern='^remove_api_confirm|remove_api_cancel$')] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    settings_risk_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_risk_percent, pattern='^set_risk_percent$')],
        states={ ASKING_RISK_PERCENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_risk_percent)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    settings_leverage_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_max_leverage, pattern='^set_max_leverage$')],
        states={ ASKING_MAX_LEVERAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_max_leverage)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    settings_confidence_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(ask_min_confidence, pattern='^set_min_confidence$')],
        states={ ASKING_MIN_CONFIDENCE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_min_confidence)] },
        fallbacks=[CommandHandler("cancel", cancel)], per_message=False,
    )
    
    # Adicionando todos os handlers
    application.add_handler(register_conv)
    application.add_handler(api_conv)
    application.add_handler(remove_api_conv)
    application.add_handler(settings_risk_conv)
    application.add_handler(settings_leverage_conv)
    application.add_handler(settings_confidence_conv)
    
    application.add_handler(CommandHandler("admin", admin_menu))
    application.add_handler(CallbackQueryHandler(list_channels_handler, pattern='^admin_list_channels$'))
    application.add_handler(CallbackQueryHandler(select_channel_to_monitor, pattern='^monitor_channel_'))
    application.add_handler(CallbackQueryHandler(select_topic_to_monitor, pattern='^monitor_topic_'))
    application.add_handler(CallbackQueryHandler(admin_view_targets_handler, pattern='^admin_view_targets$'))
    application.add_handler(CallbackQueryHandler(back_to_admin_menu_handler, pattern='^back_to_admin_menu$'))

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("relatorio", report_handler))
    
    application.add_handler(CallbackQueryHandler(my_positions_handler, pattern='^user_positions$'))
    application.add_handler(CallbackQueryHandler(user_settings_handler, pattern='^user_settings$'))
    application.add_handler(CallbackQueryHandler(user_dashboard_handler, pattern='^user_dashboard$'))
    application.add_handler(CallbackQueryHandler(back_to_main_menu_handler, pattern='^back_to_main_menu$'))
    application.add_handler(CallbackQueryHandler(manual_close_handler, pattern='^manual_close_'))

    application.add_handler(CallbackQueryHandler(bot_config_handler, pattern='^bot_config$'))
    application.add_handler(CallbackQueryHandler(toggle_approval_mode_handler, pattern='^toggle_approval_mode$'))

    application.add_handler(CallbackQueryHandler(handle_signal_approval, pattern=r'^(approve_signal_|reject_signal_)'))


    logger.info("Bot configurado. Iniciando todos os servi√ßos...")

    await asyncio.gather(
        run_ptb(application, comm_queue),
        start_signal_monitor(comm_queue),
        run_tracker(application)
    )

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Bot desligado pelo usu√°rio.")
    except Exception as e:
        logger.critical(f"Erro cr√≠tico n√£o tratado: {e}", exc_info=True)

========================================
# Arquivo: start.sh
========================================

#!/bin/sh

# Inicia o Tailscale em segundo plano
/usr/sbin/tailscaled --state=/var/lib/tailscale/tailscaled.state --socket=/var/run/tailscale/tailscaled.sock &

# Espera um pouco para o Tailscale iniciar
sleep 2

# Conecta √† rede Tailscale usando a chave de autentica√ß√£o
/usr/bin/tailscale up --authkey=${TAILSCALE_AUTHKEY} --hostname="tradeflow-bot"

# Inicia a aplica√ß√£o principal do bot
echo "Iniciando o bot TradeFlow..."
python main.py

========================================
# Arquivo: database/__init__.py
========================================



========================================
# Arquivo: database/crud.py
========================================

from .session import SessionLocal
from .models import User

def get_user_by_id(telegram_id: int):
    """Busca um usu√°rio no banco de dados pelo seu ID do Telegram."""
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.telegram_id == telegram_id).first()
        return user
    finally:
        db.close()

========================================
# Arquivo: database/models.py
========================================

from sqlalchemy import (Column, Integer, String, BigInteger, 
                        Boolean, Float, JSON, DateTime)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.sql import func

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)
    first_name = Column(String)
    api_key_encrypted = Column(String)
    api_secret_encrypted = Column(String)
    risk_per_trade_percent = Column(Float, default=1.0)
    max_leverage = Column(Integer, default=10)
    min_confidence = Column(Float, default=0.0)
    approval_mode = Column(String, default='AUTOMATIC', nullable=False)

class InviteCode(Base):
    __tablename__ = 'invite_codes'
    id = Column(Integer, primary_key=True)
    code = Column(String, unique=True, nullable=False)
    is_used = Column(Boolean, default=False)

class MonitoredTarget(Base):
    __tablename__ = 'monitored_targets'
    id = Column(Integer, primary_key=True)
    channel_id = Column(BigInteger, nullable=False)
    channel_name = Column(String)
    topic_id = Column(BigInteger, unique=True, nullable=True)
    topic_name = Column(String)

class Trade(Base):
    __tablename__ = 'trades'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False)
    order_id = Column(String, unique=True, nullable=False)
    symbol = Column(String, nullable=False)
    side = Column(String, nullable=False)
    qty = Column(Float, nullable=False)
    entry_price = Column(Float)
    stop_loss = Column(Float)
    current_stop_loss = Column(Float)
    initial_targets = Column(JSON)
    status = Column(String, default='ACTIVE')
    remaining_qty = Column(Float)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class PendingSignal(Base):
    __tablename__ = 'pending_signals'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False)
    symbol = Column(String, nullable=False, unique=True, index=True)
    signal_data = Column(JSON, nullable=False)

class SignalForApproval(Base):
    __tablename__ = 'signals_for_approval'
    id = Column(Integer, primary_key=True)
    user_telegram_id = Column(BigInteger, nullable=False, index=True)
    symbol = Column(String, nullable=False)
    source_name = Column(String)
    signal_data = Column(JSON, nullable=False)
    approval_message_id = Column(BigInteger)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

========================================
# Arquivo: database/session.py
========================================

import os # Importa a biblioteca 'os'
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from .models import Base

# --- L√ìGICA DE CAMINHO DIN√ÇMICO ---
if os.path.isdir('/data'):
    # Caminho para o banco de dados no servidor Fly.io
    DATABASE_URL = "sqlite:////data/tradeflow.db"
else:
    # Caminho para o banco de dados local (no seu Mac)
    DATABASE_URL = "sqlite:///./tradeflow.db"

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def init_db():
    Base.metadata.create_all(bind=engine)

========================================
# Arquivo: core/__init__.py
========================================



========================================
# Arquivo: core/position_tracker.py
========================================

import asyncio
import logging
from telegram.ext import Application
from database.session import SessionLocal
from database.models import Trade, User
from services.bybit_service import get_market_price, close_partial_position, modify_position_stop_loss
from services.notification_service import send_notification
from utils.security import decrypt_data
from utils.config import ADMIN_ID

logger = logging.getLogger(__name__)

async def check_active_trades(application: Application):
    """Verifica e gerencia ativamente os trades com m√∫ltiplos TPs e trailing stop."""
    db = SessionLocal()
    try:
        # Busca todos os trades que n√£o est√£o completamente fechados
        active_trades = db.query(Trade).filter(~Trade.status.like('%CLOSED%')).all()
        if not active_trades: return

        logger.info(f"Rastreador: {len(active_trades)} trade(s) ativo(s) para verificar.")
        
        admin_user = db.query(User).filter_by(telegram_id=ADMIN_ID).first()
        if not admin_user or not admin_user.api_key_encrypted:
            logger.error("Rastreador: Admin ou chaves de API n√£o encontrados.")
            return
        
        api_key = decrypt_data(admin_user.api_key_encrypted)
        api_secret = decrypt_data(admin_user.api_secret_encrypted)

        for trade in active_trades:
            price_result = get_market_price(trade.symbol)
            if not price_result.get("success"):
                # ... (c√≥digo de erro)
                continue
            
            current_price = price_result["price"]
            
            # --- L√ìGICA DE TAKE PROFIT (MULTI-ALVO) ---
            if trade.initial_targets:
                next_target_price = trade.initial_targets[0]

                if (trade.side == 'LONG' and current_price >= next_target_price) or \
                   (trade.side == 'SHORT' and current_price <= next_target_price):
                    
                    total_targets = len(db.query(Trade).filter_by(id=trade.id).first().initial_targets)
                    current_tp_number = total_targets - len(trade.initial_targets) + 1
                    
                    logger.info(f"‚úÖ TP{current_tp_number} ATINGIDO para {trade.symbol}! Pre√ßo: {current_price}")
                    
                    # Define a quantidade a ser fechada (ex: 50% no TP1, 100% do restante no TP2)
                    qty_to_close = trade.remaining_qty if len(trade.initial_targets) == 1 else trade.remaining_qty / 2
                    
                    close_result = close_partial_position(api_key, api_secret, trade.symbol, qty_to_close, trade.side)
                    
                    if close_result.get("success"):
                        # --- L√ìGICA DE TRAILING STOP ---
                        # No TP1, move para o breakeven. Nos TPs seguintes, move para o TP anterior.
                        new_stop_loss = trade.entry_price if trade.status == 'ACTIVE' else trade.initial_targets[-1]
                        
                        sl_result = modify_position_stop_loss(api_key, api_secret, trade.symbol, new_stop_loss)

                        if sl_result.get("success"):
                            # Atualiza o trade no banco de dados
                            trade.remaining_qty -= qty_to_close
                            trade.initial_targets = trade.initial_targets[1:]
                            trade.current_stop_loss = new_stop_loss # Atualiza o SL no DB
                            
                            if trade.remaining_qty < 0.0001:
                                trade.status = 'CLOSED_PROFIT'
                            else:
                                trade.status = f'ACTIVE_TP{current_tp_number}'
                            
                            await send_notification(
                                application,
                                f"üí∞ <b>TP{current_tp_number} Atingido! ({trade.symbol})</b>\n"
                                f"Posi√ß√£o parcialmente realizada. Novo Stop Loss em ${new_stop_loss:,.4f}."
                            )
                        else:
                            logger.error(f"-> Falha ao mover Stop Loss: {sl_result.get('error')}")
                            await send_notification(application, f"‚ö†Ô∏è Falha ao mover Stop Loss para {trade.symbol}.")
                    else:
                        logger.error(f"-> Falha ao fechar posi√ß√£o parcial: {close_result.get('error')}")
                        await send_notification(application, f"‚ö†Ô∏è Falha ao realizar lucro parcial para {trade.symbol}.")

            # --- L√ìGICA DE STOP LOSS ---
            if (trade.side == 'LONG' and current_price <= trade.current_stop_loss) or \
               (trade.side == 'SHORT' and current_price >= trade.current_stop_loss):
                logger.info(f"‚ùå STOP LOSS ATINGIDO para {trade.symbol}! Pre√ßo: {current_price}, Stop: {trade.current_stop_loss}")
                trade.status = 'CLOSED_LOSS'
                await send_notification(
                    application,
                    f"üõë <b>Stop Loss Atingido</b>\n<b>Moeda:</b> {trade.symbol}\nPosi√ß√£o foi fechada pela corretora."
                )
        
        db.commit()
        
    except Exception as e:
        logger.error(f"Erro no ciclo do rastreador de posi√ß√µes: {e}", exc_info=True)
    finally:
        db.close()

async def run_tracker(application: Application):
    """Fun√ß√£o principal que roda o verificador em loop."""
    logger.info("Iniciando Rastreador de Posi√ß√µes...")
    while True:
        try:
            await check_active_trades(application)
        except Exception as e:
            logger.critical(f"Erro cr√≠tico no loop do rastreador: {e}", exc_info=True)
        # Espera 60 segundos antes de verificar novamente
        await asyncio.sleep(60)

========================================
# Arquivo: core/report_service.py
========================================

import logging
from database.session import SessionLocal
from database.models import Trade

logger = logging.getLogger(__name__)

def generate_performance_report(user_telegram_id: int) -> str:
    """
    Busca os trades fechados de um usu√°rio e gera um relat√≥rio de texto.
    """
    db = SessionLocal()
    try:
        # Busca todos os trades que foram fechados (com lucro ou preju√≠zo)
        closed_trades = db.query(Trade).filter(
            Trade.user_telegram_id == user_telegram_id,
            Trade.status.like('%CLOSED%')
        ).all()

        if not closed_trades:
            return "Nenhum trade fechado encontrado para gerar um relat√≥rio."

        # --- C√°lculos ---
        total_trades = len(closed_trades)
        winning_trades = [t for t in closed_trades if t.status == 'CLOSED_PROFIT']
        losing_trades = [t for t in closed_trades if t.status == 'CLOSED_LOSS']
        
        win_rate = (len(winning_trades) / total_trades) * 100 if total_trades > 0 else 0

        # --- Montagem da Mensagem ---
        report_message = "<b>üìä Relat√≥rio de Performance do Bot</b>\n\n"
        report_message += f"<b>Total de Trades Fechados:</b> {total_trades}\n"
        report_message += f"<b>Trades Vencedores:</b> {len(winning_trades)}\n"
        report_message += f"<b>Trades Perdedores:</b> {len(losing_trades)}\n"
        report_message += f"<b>Taxa de Acerto:</b> {win_rate:.2f}%\n\n"
        report_message += "Este √© um relat√≥rio inicial. Futuramente, podemos adicionar o P/L (Lucro/Preju√≠zo) total."

        return report_message

    except Exception as e:
        logger.error(f"Erro ao gerar relat√≥rio de performance: {e}")
        return "Ocorreu um erro ao gerar seu relat√≥rio."
    finally:
        db.close()

========================================
# Arquivo: core/trade_manager.py
========================================

import os
import logging
from typing import Tuple
from telegram.ext import Application
from sqlalchemy.orm import Session # <-- Adicionado 'Session' para a anota√ß√£o de tipo
from database.session import SessionLocal
from database.models import User, Trade, PendingSignal, SignalForApproval
from services.bybit_service import place_order, get_account_info
from services.notification_service import send_notification
from utils.security import decrypt_data
from utils.config import ADMIN_ID
from bot.keyboards import signal_approval_keyboard

logger = logging.getLogger(__name__)

def _avaliar_sinal(signal_data: dict, user_settings: User) -> Tuple[bool, str]:
    """
    Fun√ß√£o interna para aplicar todos os filtros configurados pelo usu√°rio.
    Retorna (True, "Motivo") se aprovado, ou (False, "Motivo") se rejeitado.
    """
    # Filtro 1: Confian√ßa M√≠nima
    min_confidence = user_settings.min_confidence
    signal_confidence = signal_data.get('confidence')
    if signal_confidence is not None and signal_confidence < min_confidence:
        motivo = f"Confian√ßa ({signal_confidence:.2f}%) √© menor que o seu m√≠nimo ({min_confidence:.2f}%)"
        return False, motivo
    return True, "Sinal aprovado pelos seus crit√©rios."


async def process_new_signal(signal_data: dict, application: Application, source_name: str):
    """
    Roteador de sinais: verifica o modo de aprova√ß√£o do usu√°rio e decide se
    abre a ordem automaticamente ou se envia para aprova√ß√£o manual.
    """
    signal_type = signal_data.get("type")
    symbol = signal_data.get("coin")
    db = SessionLocal()
    try:
        if signal_type == 'CANCELLED':
            pending = db.query(PendingSignal).filter_by(symbol=symbol, user_telegram_id=ADMIN_ID).first()
            if pending:
                db.delete(pending)
                db.commit()
                await send_notification(application, f"‚ö†Ô∏è <b>Monitoramento Cancelado</b>\nO sinal limite para <b>{symbol}</b> foi cancelado pela fonte '{source_name}'.")
            return

        admin_user = db.query(User).filter_by(telegram_id=ADMIN_ID).first()
        if not admin_user:
            logger.error("Admin n√£o encontrado.")
            return

        aprovado, motivo = _avaliar_sinal(signal_data, admin_user)
        if not aprovado:
            rejection_msg = f"‚ö†Ô∏è <b>Sinal para {symbol} Ignorado</b>\n<b>Fonte:</b> {source_name}\n<b>Motivo:</b> {motivo}"
            await send_notification(application, rejection_msg)
            return

        if admin_user.approval_mode == 'AUTOMATIC':
            logger.info(f"Modo AUTOM√ÅTICO. Tentando abrir ordem para {symbol}...")
            await _execute_trade(signal_data, admin_user, application, db, source_name)
        
        elif admin_user.approval_mode == 'MANUAL':
            logger.info(f"Modo MANUAL. Enviando sinal para aprova√ß√£o: {symbol}")
            
            new_signal_for_approval = SignalForApproval(
                user_telegram_id=ADMIN_ID,
                symbol=symbol,
                source_name=source_name,
                signal_data=signal_data
            )
            db.add(new_signal_for_approval)
            db.commit()

            signal_details = (
                f"<b>Sinal Recebido de: {source_name}</b>\n\n"
                f"<b>Moeda:</b> {signal_data['coin']}\n"
                f"<b>Tipo:</b> {signal_data['order_type']}\n"
                f"<b>Entrada:</b> {signal_data['entries'][0]}\n"
                f"<b>Stop:</b> {signal_data['stop_loss']}\n"
                f"<b>Alvo 1:</b> {signal_data['targets'][0]}\n\n"
                f"O sinal passou nos seus filtros. Voc√™ aprova a entrada?"
            )
            
            sent_message = await application.bot.send_message(
                chat_id=ADMIN_ID,
                text=signal_details,
                parse_mode='HTML',
                reply_markup=signal_approval_keyboard(new_signal_for_approval.id)
            )
            
            new_signal_for_approval.approval_message_id = sent_message.message_id
            db.commit()
    finally:
        db.close()

async def _execute_trade(signal_data: dict, user: User, application: Application, db: Session, source_name: str):
    """Fun√ß√£o interna que cont√©m a l√≥gica para abrir uma posi√ß√£o na Bybit."""
    api_key = decrypt_data(user.api_key_encrypted)
    api_secret = decrypt_data(user.api_secret_encrypted)
    
    # --- AWAIT ADICIONADO ---
    account_info = await get_account_info(api_key, api_secret)
    if not account_info.get("success"):
        await send_notification(application, f"‚ùå Falha ao buscar saldo da Bybit para operar {signal_data['coin']}.")
        return
    
    balances = account_info.get("data", [])
    if not balances:
        await send_notification(application, f"‚ùå Falha: Nenhuma informa√ß√£o de saldo recebida da Bybit para operar {signal_data['coin']}.")
        return

    # --- CORRE√á√ÉO: Pega o saldo total do primeiro item da lista ---
    balance = float(balances[0].get('totalEquity', 0))
    
    # --- AWAIT ADICIONADO ---
    result = await place_order(api_key, api_secret, signal_data, user, balance)
    
    if result.get("success"):
        order_data = result['data']
        order_id = order_data['orderId']

        # Salva o trade bem-sucedido no banco de dados
        new_trade = Trade(
            user_telegram_id=user.telegram_id,
            order_id=order_id,
            symbol=signal_data['coin'],
            side=signal_data['order_type'],
            qty=float(order_data.get('qty', 0)),
            entry_price=signal_data['entries'][0],
            stop_loss=signal_data['stop_loss'],
            current_stop_loss=signal_data['stop_loss'],
            initial_targets=signal_data['targets'],
            status='ACTIVE',
            remaining_qty=float(order_data.get('qty', 0))
        )
        db.add(new_trade)
        db.commit()
        logger.info(f"Trade {order_id} salvo no banco de dados para rastreamento.")

        await send_notification(application, f"üìà <b>Ordem Aberta com Sucesso!</b>\n<b>Moeda:</b> {signal_data['coin']}\n<b>ID:</b> {order_id}")
    else:
        error_msg = result.get('error')
        await send_notification(application, f"‚ùå <b>Falha ao Abrir Ordem</b>\n<b>Moeda:</b> {signal_data['coin']}\n<b>Motivo:</b> {error_msg}")

========================================
# Arquivo: utils/__init__.py
========================================



========================================
# Arquivo: utils/config.py
========================================

import os
from dotenv import load_dotenv

load_dotenv()

TELEGRAM_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
ENCRYPTION_KEY = os.getenv('ENCRYPTION_KEY')

API_ID = os.getenv('API_ID')
API_HASH = os.getenv('API_HASH')
ADMIN_ID = int(os.getenv('ADMIN_TELEGRAM_ID', 0)) # Converte para int

========================================
# Arquivo: utils/security.py
========================================

from cryptography.fernet import Fernet
from .config import ENCRYPTION_KEY

# Inicializa o 'cofre' com a sua chave
cipher_suite = Fernet(ENCRYPTION_KEY.encode())

def encrypt_data(data: str) -> str:
    """Criptografa um texto e retorna a vers√£o em string."""
    if not data:
        return None
    encrypted_bytes = cipher_suite.encrypt(data.encode())
    return encrypted_bytes.decode()

def decrypt_data(encrypted_data: str) -> str:
    """Descriptografa um texto e retorna a vers√£o original."""
    if not encrypted_data:
        return None
    decrypted_bytes = cipher_suite.decrypt(encrypted_data.encode())
    return decrypted_bytes.decode()

========================================
# Arquivo: scripts/create_invite.py
========================================

import sys
from database.session import SessionLocal, init_db
from database.models import InviteCode

def create_invite_code(code: str):
    db = SessionLocal()
    try:
        existing_code = db.query(InviteCode).filter(InviteCode.code == code).first()
        if existing_code:
            print(f"C√≥digo '{code}' j√° existe.")
            return

        new_code = InviteCode(code=code)
        db.add(new_code)
        db.commit()
        print(f"C√≥digo de convite '{code}' criado com sucesso!")
    finally:
        db.close()

if __name__ == "__main__":
    init_db()
    # Agora ele l√™ o c√≥digo a partir do seu comando no terminal
    if len(sys.argv) > 1:
        code_to_create = sys.argv[1]
        create_invite_code(code_to_create)
    else:
        print("Erro: Por favor, forne√ßa um c√≥digo para criar. Exemplo: python create_invite.py MEU-CODIGO-NOVO")

========================================
# Arquivo: scripts/generate_session.py
========================================

import asyncio
from telethon.sync import TelegramClient
from dotenv import load_dotenv
import os

# Carrega as vari√°veis de ambiente (API_ID, API_HASH)
load_dotenv()
API_ID = os.getenv('API_ID')
API_HASH = os.getenv('API_HASH')

# --- CORRE√á√ÉO PRINCIPAL ---
# Define o caminho completo para salvar o arquivo dentro do volume persistente
SESSION_NAME = '/data/tradeflow_user'

async def main():
    print(f"Gerando o arquivo de sess√£o em '{SESSION_NAME}.session'...")
    # Usa 'with' para garantir que o cliente se desconecte corretamente
    async with TelegramClient(SESSION_NAME, API_ID, API_HASH) as client:
        me = await client.get_me()
        print(f"Login bem-sucedido como: {me.first_name}")
        print("Arquivo de sess√£o foi criado/atualizado com sucesso no local correto.")

if __name__ == "__main__":
    asyncio.run(main())

========================================
# Arquivo: scripts/test_bybit_connection.py
========================================

import os
import logging
from dotenv import load_dotenv
from pybit.unified_trading import HTTP

# Configura o logging para vermos mais detalhes em caso de erro
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def test_connection():
    """
    Script de teste isolado para validar a conex√£o e as credenciais da Bybit.
    """
    # 1. Carrega as credenciais do seu arquivo .env
    load_dotenv()
    api_key = os.getenv("BYBIT_API_KEY")
    api_secret = os.getenv("BYBIT_API_SECRET")

    if not api_key or not api_secret:
        print("\n‚ùå ERRO: Verifique se BYBIT_API_KEY e BYBIT_API_SECRET est√£o no seu arquivo .env")
        return

    print("\n--- INICIANDO TESTE DE CONEX√ÉO COM A BYBIT ---")
    print(f"Usando API Key que termina em: ...{api_key[-4:]}")

    try:
        # 2. Tenta criar a sess√£o e buscar o saldo (exatamente como o bot faz)
        session = HTTP(
            testnet=False, # Conectando na conta REAL
            api_key=api_key,
            api_secret=api_secret
        )
        
        print("\nEtapa 1: Conectando e buscando saldo da Carteira Unificada...")
        response = session.get_wallet_balance(accountType="UNIFIED")

        # 3. Analisa a resposta da Bybit
        if response.get('retCode') == 0:
            print("\n‚úÖ SUCESSO! Conex√£o bem-sucedida e permiss√µes corretas.")
            balance = response['result']['list'][0]['totalEquity']
            print(f"   - Saldo Total da Conta Unificada: {balance} USDT")
        else:
            print("\n‚ùå FALHA! A Bybit retornou um erro.")
            print(f"   - C√≥digo do Erro: {response.get('retCode')}")
            print(f"   - Mensagem da API: {response.get('retMsg')}")

    except Exception as e:
        print("\n‚ùå FALHA CR√çTICA! Ocorreu uma exce√ß√£o ao tentar conectar.")
        print("   Isso geralmente indica um problema de rede (bloqueio de IP) ou de configura√ß√£o do ambiente.")
        print(f"\n   Detalhes do Erro:\n   {e}")

    print("\n--- TESTE FINALIZADO ---")

if __name__ == "__main__":
    test_connection()

========================================
# Arquivo: scripts/test_trade.py
========================================

import os
from dotenv import load_dotenv
from services.bybit_service import get_account_info
import json

load_dotenv()

BYBIT_API_KEY = os.getenv("BYBIT_API_KEY")
BYBIT_API_SECRET = os.getenv("BYBIT_API_SECRET")

def run_auth_test():
    if not BYBIT_API_KEY or not BYBIT_API_SECRET:
        print("‚ùå Por favor, defina BYBIT_API_KEY e BYBIT_API_SECRET no seu arquivo .env")
        return

    # --- LINHAS DE DIAGN√ìSTICO ADICIONADAS ---
    print("="*40)
    print("VERIFICA√á√ÉO DAS CHAVES CARREGADAS PELO SCRIPT:")
    print(f"API Key lida....: {BYBIT_API_KEY[:4]}...{BYBIT_API_KEY[-4:]}")
    print(f"API Secret lida..: {BYBIT_API_SECRET[:4]}...{BYBIT_API_SECRET[-4:]}")
    print("="*40)
    # ---------------------------------------------

    print("\n‚ñ∂Ô∏è  Tentando autenticar e buscar o saldo da conta de testes...")
    
    result = get_account_info(BYBIT_API_KEY, BYBIT_API_SECRET)
    
    print("\n" + "="*30)
    if result.get("success"):
        print("‚úÖ Autentica√ß√£o bem-sucedida!")
        print(json.dumps(result.get("data"), indent=2))
    else:
        print("‚ùå Falha na autentica√ß√£o.")
        print(f"Motivo: {result.get('error')}")
    print("="*30)

if __name__ == "__main__":
    run_auth_test()

========================================
# Arquivo: bot/__init__.py
========================================



========================================
# Arquivo: bot/handlers.py
========================================

import logging
import asyncio
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler
from database.session import SessionLocal
from database.models import User, InviteCode, MonitoredTarget, Trade, SignalForApproval
from .keyboards import main_menu_keyboard, confirm_remove_keyboard, admin_menu_keyboard, dashboard_menu_keyboard, settings_menu_keyboard, view_targets_keyboard, bot_config_keyboard
from utils.security import encrypt_data, decrypt_data
from services.bybit_service import get_open_positions, get_account_info, close_partial_position
from utils.config import ADMIN_ID
from core.report_service import generate_performance_report
from database.crud import get_user_by_id
from core.trade_manager import _execute_trade

# Estados para as conversas
(WAITING_CODE, WAITING_API_KEY, WAITING_API_SECRET, CONFIRM_REMOVE_API) = range(4)
(ASKING_RISK_PERCENT, ASKING_MAX_LEVERAGE, ASKING_MIN_CONFIDENCE) = range(10, 13)

logger = logging.getLogger(__name__)

# --- FLUXO DE USU√ÅRIO (START, CADASTRO, MENUS) ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    telegram_user = update.effective_user
    user_in_db = get_user_by_id(telegram_user.id)
    if user_in_db:
        await update.message.reply_text(
            "Menu Principal:",
            reply_markup=main_menu_keyboard(telegram_id=telegram_user.id)
        )
        return ConversationHandler.END
    else:
        await update.message.reply_text(
            f"Ol√°, {telegram_user.first_name}! Para usar o TradeFlow, insira seu c√≥digo de convite."
        )
        return WAITING_CODE

async def receive_invite_code(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    code_text = update.message.text
    telegram_user = update.effective_user
    db = SessionLocal()
    try:
        invite_code = db.query(InviteCode).filter(InviteCode.code == code_text, InviteCode.is_used == False).first()
        if invite_code:
            new_user = User(telegram_id=telegram_user.id, first_name=telegram_user.first_name)
            db.add(new_user)
            invite_code.is_used = True
            db.commit()
            await update.message.reply_text(
                "‚úÖ Cadastro realizado com sucesso! O pr√≥ximo passo √© configurar sua API.",
                reply_markup=main_menu_keyboard(telegram_id=telegram_user.id)
            )
            return ConversationHandler.END
        else:
            await update.message.reply_text("‚ùå C√≥digo de convite inv√°lido ou j√° utilizado. Tente novamente.")
            return WAITING_CODE
    finally:
        db.close()

async def back_to_main_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        "Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=update.effective_user.id)
    )

# --- FLUXO DE CONFIGURA√á√ÉO DE API ---
async def config_api(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Inicia o fluxo de configura√ß√£o de API com um tutorial melhorado."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['entry_message_id'] = query.message.message_id
    
    tutorial_text = (
        "üîë <b>Como Criar suas Chaves de API na Bybit</b> üîë\n\n"
        "Siga estes passos com aten√ß√£o para conectar sua conta:\n\n"
        "1Ô∏è‚É£  Fa√ßa login em <b>Bybit.com</b> e v√° para <i>Perfil > API</i>.\n\n"
        "2Ô∏è‚É£  Clique em <b>'Criar Nova Chave'</b> e selecione <i>'Chaves Geradas pelo Sistema'</i>.\n\n"
        "3Ô∏è‚É£  D√™ um nome para sua chave (ex: `TradeFlowBot`) e selecione as permiss√µes de <b>'Leitura e Escrita'</b>.\n\n"
        "4Ô∏è‚É£  Nas permiss√µes, marque <b>APENAS</b> as seguintes caixas:\n"
        "   - <b>Contrato</b> (`Contract`): ‚úÖ `Ordens` e ‚úÖ `Posi√ß√µes`\n"
        "   - <b>Trading Unificado</b> (`UTA`): ‚úÖ `Trade`\n\n"
        "5Ô∏è‚É£  üõ°Ô∏è <b>MUITO IMPORTANTE:</b> Por seguran√ßa, <b>N√ÉO</b> marque a permiss√£o de <i>'Saque' (Withdraw)</i>.\n\n"
        # --- NOVA LINHA DE AVISO ---
        "‚ö†Ô∏è <b>Aten√ß√£o:</b> Este bot opera exclusivamente com pares de trade terminados em **USDT**.\n\n"
        "6Ô∏è‚É£  Conclua a verifica√ß√£o de seguran√ßa e copie sua <b>API Key</b> e <b>API Secret</b>.\n\n"
        "-------------------------------------\n"
        "Pronto! Agora, por favor, envie sua <b>API Key</b>."
    )
    
    await query.edit_message_text(
        text=tutorial_text,
        parse_mode='HTML'
    )
    return WAITING_API_KEY

async def receive_api_key(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe a API Key, apaga a mensagem do usu√°rio e pede a API Secret."""
    # Apaga a mensagem do usu√°rio que cont√©m a chave
    await context.bot.delete_message(
        chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    api_key = update.message.text
    context.user_data['api_key'] = api_key
    
    # Envia a pr√≥xima pergunta e guarda a mensagem para apagar depois
    prompt_message = await update.message.reply_text(
        "Chave API recebida com seguran√ßa. Agora, por favor, envie sua *API Secret*.",
        parse_mode='Markdown'
    )
    # Guarda o ID da mensagem do bot para o pr√≥ximo passo
    context.user_data['prompt_message_id'] = prompt_message.message_id
    
    return WAITING_API_SECRET

async def receive_api_secret(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe a API Secret, apaga as mensagens, criptografa e salva no banco."""
    # Apaga a mensagem do usu√°rio que cont√©m o segredo
    await context.bot.delete_message(
        chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    # Apaga a pergunta anterior do bot ("...envie sua API Secret")
    prompt_message_id = context.user_data.get('prompt_message_id')
    if prompt_message_id:
        await context.bot.delete_message(
            chat_id=update.effective_chat.id,
            message_id=prompt_message_id
        )

    api_secret = update.message.text
    api_key = context.user_data.get('api_key')
    telegram_id = update.effective_user.id

    # Criptografa e salva as chaves no banco (l√≥gica existente)
    encrypted_key = encrypt_data(api_key)
    encrypted_secret = encrypt_data(api_secret)

    db = SessionLocal()
    try:
        user_to_update = db.query(User).filter(User.telegram_id == telegram_id).first()
        if user_to_update:
            user_to_update.api_key_encrypted = encrypted_key
            user_to_update.api_secret_encrypted = encrypted_secret
            db.commit()
            
            # Edita a mensagem original do menu para a confirma√ß√£o final
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=context.user_data['entry_message_id'], # ID da mensagem do menu
                text="‚úÖ Suas chaves de API foram salvas com sucesso!",
            )
            # Envia um novo menu principal
            await context.bot.send_message(
                chat_id=telegram_id,
                text="Menu Principal:",
                reply_markup=main_menu_keyboard(telegram_id=telegram_id)
            )
        else:
            await update.message.reply_text("Ocorreu um erro. Usu√°rio n√£o encontrado.")
    finally:
        db.close()
        context.user_data.clear()

    return ConversationHandler.END

# --- FLUXO DE REMO√á√ÉO DE API ---
async def remove_api_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        text="‚ö†Ô∏è Voc√™ tem certeza que deseja remover suas chaves de API?",
        reply_markup=confirm_remove_keyboard()
    )
    return CONFIRM_REMOVE_API

async def remove_api_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    telegram_id = update.effective_user.id

    if query.data == 'remove_api_confirm':
        db = SessionLocal()
        try:
            user_to_update = db.query(User).filter(User.telegram_id == telegram_id).first()
            if user_to_update:
                user_to_update.api_key_encrypted = None
                user_to_update.api_secret_encrypted = None
                db.commit()
            await query.edit_message_text("‚úÖ Suas chaves de API foram removidas.")
        finally:
            db.close()
    else: # Cancelou
        await query.edit_message_text("Opera√ß√£o cancelada.")

    # Envia um novo menu principal atualizado
    await context.bot.send_message(
        chat_id=telegram_id,
        text="Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=telegram_id)
    )
    return ConversationHandler.END

# --- PAIN√âIS DO USU√ÅRIO ---
async def my_positions_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("Buscando suas posi√ß√µes gerenciadas...")
    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        active_trades = db.query(Trade).filter(Trade.user_telegram_id == user_id, ~Trade.status.like('%CLOSED%')).all()
        message = "<b>üìä Suas Posi√ß√µes Ativas (Gerenciadas pelo Bot)</b>\n\n"
        keyboard = []
        if active_trades:
            for trade in active_trades:
                side_emoji = "üîº" if trade.side == 'LONG' else "üîΩ"
                message += f"- {side_emoji} {trade.symbol} ({trade.qty} unid.)\n  Entrada: ${trade.entry_price:,.4f} | Status: {trade.status}\n\n"
                keyboard.append([InlineKeyboardButton(f"Fechar {trade.symbol} ‚ùå", callback_data=f"manual_close_{trade.id}")])
        else:
            message += "Nenhuma posi√ß√£o sendo gerenciada no momento."
        
        keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data='back_to_main_menu')])
        await query.edit_message_text(message, parse_mode='HTML', reply_markup=InlineKeyboardMarkup(keyboard))
    finally:
        db.close()

async def user_dashboard_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o painel com saldo detalhado por moeda, posi√ß√µes e menus."""
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("Buscando informa√ß√µes do painel...")

    user_id = update.effective_user.id
    db = SessionLocal()
    
    try:
        user = get_user_by_id(user_id)
        if not user or not user.api_key_encrypted:
            # ... (c√≥digo existente para usu√°rio sem API)
            return

        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        account_info = await get_account_info(api_key, api_secret)
        positions_info = await get_open_positions(api_key, api_secret)
        
        message = "<b>‚ÑπÔ∏è Seu Painel de Controle</b>\n\n"

        # --- L√ìGICA DE SALDO ATUALIZADA ---
        message += "<b>Saldo em Conta (Bybit):</b>\n"
        if account_info.get("success"):
            balances = account_info.get("data", [])
            
            if balances:
                total_balance_info = balances[0]
                total_equity = float(total_balance_info.get('totalEquity', '0'))
                message += f"- Saldo Total (Equivalente): ${total_equity:,.2f} USD\n"

                # Loop para moedas individuais com saldo significativo
                for coin_balance in balances:
                    coin_name = coin_balance.get('coin')
                    if coin_name:
                        wallet_balance = float(coin_balance.get('walletBalance', '0'))
                        usd_value = float(coin_balance.get('usdValue', '0'))
                        
                        # Exibe se o valor em USD for maior que 0.01
                        if usd_value > 0.01:
                            balance_str = f"{wallet_balance:.8f}".rstrip('0').rstrip('.')
                            message += f"- {coin_name}: {balance_str} (~${usd_value:,.2f})\n"
            else:
                message += "- Nenhum saldo encontrado.\n"
        else:
            message += f"- Erro ao buscar saldo: {account_info.get('error')}\n"
        message += "\n"

        # Se√ß√£o de Posi√ß√µes Abertas (sem altera√ß√£o)
        message += "<b>Posi√ß√µes Abertas na Corretora:</b>\n"
        if positions_info.get("success") and positions_info.get("data"):
            for pos in positions_info["data"]:
                try:
                    entry_price = float(pos.get('avgPrice', '0'))
                    size = float(pos.get('size', '0'))
                    pnl = float(pos.get('unrealisedPnl', '0'))
                    pnl_percent = (pnl / (entry_price * size)) * 100 if entry_price > 0 and size > 0 else 0
                    side_emoji = "üîº" if pos['side'] == 'Buy' else "üîΩ"
                    message += f"- {side_emoji} {pos['symbol']}: {pos['size']} | P/L: ${pnl:,.2f} ({pnl_percent:.2f}%)\n"
                except (ValueError, TypeError, ZeroDivisionError):
                    message += f"- {pos.get('symbol', '???')}: Dados de P/L inv√°lidos.\n"
        else:
            message += "- Nenhuma posi√ß√£o aberta no momento.\n"

        # Rodap√© com aviso sobre USDT (sem altera√ß√£o)
        message += "\n\n<i>*Este bot opera exclusivamente com pares USDT.</i>"

        await query.edit_message_text(
            message, 
            parse_mode='HTML', 
            reply_markup=dashboard_menu_keyboard()
        )

    except Exception as e:
        logger.error(f"Erro ao montar o painel do usu√°rio: {e}", exc_info=True)
        await query.edit_message_text("Ocorreu um erro ao buscar os dados do seu painel.")
    finally:
        db.close()

# --- CANCELAMENTO ---
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancela a opera√ß√£o atual."""
    await update.message.reply_text("Opera√ß√£o cancelada.")
    return ConversationHandler.END

# --- FLUXO DE ADMINISTRA√á√ÉO ---
async def admin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra o menu de administrador, se o usu√°rio for o admin."""
    user_id = update.effective_user.id
    if user_id != ADMIN_ID:
        await update.message.reply_text("Voc√™ n√£o tem permiss√£o para usar este comando.")
        return

    await update.message.reply_text(
        "Bem-vindo ao painel de administra√ß√£o.",
        reply_markup=admin_menu_keyboard()
    )


async def admin_view_targets_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Busca e exibe a lista de todos os canais e t√≥picos sendo monitorados."""
    query = update.callback_query
    await query.answer()
    
    db = SessionLocal()
    try:
        targets = db.query(MonitoredTarget).all()
        
        message = "<b>üëÅÔ∏è Alvos Atualmente Monitorados</b>\n\n"
        
        if targets:
            for target in targets:
                if target.topic_name:
                    message += f"- <b>Grupo:</b> {target.channel_name}\n  - <b>T√≥pico:</b> {target.topic_name}\n"
                else:
                    message += f"- <b>Canal:</b> {target.channel_name}\n"
        else:
            message += "Nenhum alvo sendo monitorado no momento."
            
        await query.edit_message_text(
            text=message,
            parse_mode='HTML',
            reply_markup=view_targets_keyboard()
        )
    finally:
        db.close()

async def back_to_admin_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usu√°rio para o menu de administra√ß√£o principal."""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        "Bem-vindo ao painel de administra√ß√£o.",
        reply_markup=admin_menu_keyboard()
    )

async def list_channels_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Coloca um pedido na fila para listar os grupos e canais do usu√°rio."""
    query = update.callback_query
    await query.answer()
    
    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue:
        await query.edit_message_text("Erro: Fila de comunica√ß√£o n√£o encontrada.")
        return
    
    request_data = {
        "action": "list_channels",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
    }
    
    await comm_queue.put(request_data)
    
    # --- MENSAGEM MODIFICADA ---
    await query.edit_message_text("Buscando sua lista de canais... Se voc√™ tiver muitos grupos, isso pode levar at√© um minuto. Por favor, aguarde.")
    
async def select_channel_to_monitor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Coloca um pedido na fila para listar t√≥picos (ou gerenciar um canal plano)."""
    query = update.callback_query
    await query.answer()
    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue: return

    user_id = update.effective_user.id
    if user_id != ADMIN_ID: return

    channel_id = int(query.data.split('_')[-1])
    
    # Encontra o nome do canal a partir do bot√£o clicado
    channel_name = ""
    for row in query.message.reply_markup.inline_keyboard:
        for button in row:
            if button.callback_data == query.data:
                channel_name = button.text.replace(" ‚úÖ", "")
                break

    request_data = {
        "action": "list_topics",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
        "channel_id": channel_id,
        "channel_name": channel_name # --- Enviando o nome do canal ---
    }
    
    await comm_queue.put(request_data)
    await query.edit_message_text("Processando...")

async def select_topic_to_monitor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Salva/remove o t√≥pico e pede para a fila recarregar o menu de t√≥picos."""
    query = update.callback_query
    await query.answer() # Responde ao clique imediatamente para o √≠cone de 'carregando' sumir

    comm_queue = context.application.bot_data.get('comm_queue')
    if not comm_queue:
        logger.error("Fila de comunica√ß√£o n√£o encontrada no contexto do bot.")
        return

    user_id = update.effective_user.id
    if user_id != ADMIN_ID: return

    # Extrai os IDs do callback_data
    _, _, channel_id_str, topic_id_str = query.data.split('_')
    channel_id = int(channel_id_str)
    topic_id = int(topic_id_str)
    
    db = SessionLocal()
    try:
        existing_target = db.query(MonitoredTarget).filter_by(channel_id=channel_id, topic_id=topic_id).first()
        
        if existing_target:
            # Se j√° existe, remove da lista
            db.delete(existing_target)
        else:
            # Se n√£o existe, adiciona na lista
            topic_name = ""
            for row in query.message.reply_markup.inline_keyboard:
                for button in row:
                    if button.callback_data == query.data:
                        topic_name = button.text.replace(" ‚úÖ", "")
                        break
            new_target = MonitoredTarget(channel_id=channel_id, topic_id=topic_id, topic_name=topic_name)
            db.add(new_target)
        
        db.commit()
    finally:
        db.close()

    # --- L√ìGICA DE RECARREGAMENTO ---
    # Cria um novo "pedido" para a fila, para listar os t√≥picos do mesmo canal novamente.
    # O processador da fila vai receber isso e redesenhar o menu.
    request_data = {
        "action": "list_topics",
        "chat_id": query.message.chat_id,
        "message_id": query.message.message_id,
        "channel_id": channel_id,
        "channel_name": "" # N√£o √© necess√°rio aqui, pois estamos apenas listando t√≥picos
    }
    await comm_queue.put(request_data)

async def back_to_channels_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usu√°rio para a lista de canais/grupos."""
    # Simplesmente chama a fun√ß√£o que j√° lista os canais
    await list_channels_handler(update, context)

    async def my_dashboard_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Exibe um painel completo com informa√ß√µes da conta, posi√ß√µes e monitoramentos."""
        query = update.callback_query
        await query.answer()
        await query.edit_message_text("Buscando informa√ß√µes do seu painel, aguarde...")

        user_id = update.effective_user.id
        db = SessionLocal()
        
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            if not user or not user.api_key_encrypted:
                await query.edit_message_text("Voc√™ precisa configurar suas chaves de API primeiro.", reply_markup=main_menu_keyboard(user_id))
                return

            api_key = decrypt_data(user.api_key_encrypted)
            api_secret = decrypt_data(user.api_secret_encrypted)

            # 1. Buscar Saldo da Conta
            account_info = get_account_info(api_key, api_secret)
            
            # 2. Buscar Posi√ß√µes Abertas na Bybit
            positions_info = get_open_positions(api_key, api_secret)
            
            # 3. Buscar Alvos Monitorados no nosso DB
            monitored_targets = db.query(MonitoredTarget).all()

            # --- Montagem da Mensagem ---
            message = "<b>Seu Painel de Controle</b>\n\n"

            # Se√ß√£o de Saldo
            if account_info.get("success"):
                balance = float(account_info['data']['totalEquity'])
                message += f"<b>Conta Bybit:</b>\n- Saldo Total: ${balance:,.2f}\n\n"
            else:
                message += "<b>Conta Bybit:</b>\n- Erro ao buscar saldo.\n\n"

            # Se√ß√£o de Posi√ß√µes Abertas
            message += "<b>Posi√ß√µes Abertas:</b>\n"
            if positions_info.get("success") and positions_info.get("data"):
                for pos in positions_info["data"]:
                    pnl_percent = float(pos.get('unrealisedPnl', '0')) / (float(pos.get('avgPrice', '1')) * float(pos.get('size', '1'))) * 100 if pos.get('avgPrice') and pos.get('size') else 0
                    message += f"- {pos['symbol']} ({pos['side']}): {pos['size']} | P/L: ${float(pos.get('unrealisedPnl', '0')):,.2f} ({pnl_percent:.2f}%)\n"
            else:
                message += "- Nenhuma posi√ß√£o aberta no momento.\n\n"

            # Se√ß√£o de Monitoramentos
            message += "<b>Alvos Monitorados:</b>\n"
            if monitored_targets:
                for target in monitored_targets:
                    if target.topic_id:
                        message += f"- {target.channel_name or 'Grupo'} | T√≥pico: {target.topic_name}\n"
                    else:
                        message += f"- Canal/Grupo: {target.channel_name}\n"
            else:
                message += "- Nenhum alvo sendo monitorado."

            await query.edit_message_text(message, parse_mode='HTML')

        except Exception as e:
            logger.error(f"Erro ao montar o painel: {e}")
            await query.edit_message_text("Ocorreu um erro ao buscar os dados do seu painel.")
        finally:
            db.close()

async def my_positions_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe as posi√ß√µes ativas com bot√µes para gerenciamento manual."""
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("Buscando suas posi√ß√µes gerenciadas...")

    user_id = update.effective_user.id
    db = SessionLocal()
    try:
        # Busca os trades que o bot abriu e que n√£o est√£o fechados
        active_trades = db.query(Trade).filter(
            Trade.user_telegram_id == user_id, 
            ~Trade.status.like('%CLOSED%')
        ).all()
        
        message = "<b>üìä Suas Posi√ß√µes Ativas (Gerenciadas pelo Bot)</b>\n\n"
        keyboard = [] # Vamos construir o teclado dinamicamente

        if active_trades:
            for trade in active_trades:
                side_emoji = "üîº" if trade.side == 'LONG' else "üîΩ"
                message += f"- {side_emoji} {trade.symbol} ({trade.qty} unid.)\n"
                message += f"  Entrada: ${trade.entry_price:,.4f} | Status: {trade.status}\n\n"
                
                # Adiciona um bot√£o para cada trade, passando o ID do trade no callback
                keyboard.append([
                    InlineKeyboardButton(f"Fechar {trade.symbol} ‚ùå", callback_data=f"manual_close_{trade.id}")
                ])
        else:
            message += "Nenhuma posi√ß√£o sendo gerenciada no momento."
        
        # Adiciona o bot√£o de voltar ao menu principal
        keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data='back_to_main_menu')])
        
        reply_markup=main_menu_keyboard(telegram_id=user_id)
        await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
    finally:
        db.close()

async def back_to_main_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Retorna o usu√°rio para o menu principal."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    # Simplesmente edita a mensagem para mostrar o menu principal correto
    await query.edit_message_text(
        "Menu Principal:",
        reply_markup=main_menu_keyboard(telegram_id=user_id)
    )

async def user_settings_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de configura√ß√µes de trade com os valores atuais do usu√°rio."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    db = SessionLocal()
    try:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        if user:
            await query.edit_message_text(
                "<b>‚öôÔ∏è Configura√ß√µes de Trade</b>\n\n"
                "Aqui voc√™ pode definir seus par√¢metros de risco e automa√ß√£o.",
                parse_mode='HTML',
                reply_markup=settings_menu_keyboard(user)
            )
    finally:
        db.close()

async def ask_risk_percent(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usu√°rio qual o novo percentual de risco."""
    query = update.callback_query
    await query.answer()
    
    # Guarda o ID da mensagem para podermos edit√°-la ou apag√°-la depois
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Por favor, envie o novo percentual de risco por trade.\n"
        "Envie apenas o n√∫mero (ex: `1.5` para 1.5%)."
    )
    return ASKING_RISK_PERCENT

async def receive_risk_percent(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva o novo percentual de risco."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    try:
        risk_value = float(update.message.text.replace(',', '.'))
        if not (0.1 <= risk_value <= 100):
            raise ValueError("Valor fora do range permitido")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.risk_per_trade_percent = risk_value
            db.commit()
            
            # Edita a mensagem original para mostrar o menu de configura√ß√µes atualizado
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"‚úÖ Risco por trade atualizado para {risk_value:.2f}%.\n\n"
                     "Selecione outra op√ß√£o para editar ou volte.",
                reply_markup=settings_menu_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="‚ùå Valor inv√°lido. Por favor, tente novamente com um n√∫mero (ex: 1.5)."
        )
        # Permite que o usu√°rio tente novamente sem sair da conversa
        return ASKING_RISK_PERCENT
    finally:
        # Apaga a mensagem do usu√°rio com o n√∫mero
        await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    return ConversationHandler.END # Finaliza a conversa

async def ask_max_leverage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usu√°rio qual a nova alavancagem m√°xima."""
    query = update.callback_query
    await query.answer()
    
    context.user_data['settings_message_id'] = query.message.message_id
    
    await query.edit_message_text(
        "Qual a alavancagem m√°xima que o bot deve usar?\n"
        "Envie apenas o n√∫mero (ex: `10` para 10x)."
    )
    return ASKING_MAX_LEVERAGE

async def receive_max_leverage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva a nova alavancagem m√°xima."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')

    try:
        # Tenta converter o texto para um n√∫mero inteiro
        leverage_value = int(update.message.text)
        # Limites da Bybit, por seguran√ßa
        if not (1 <= leverage_value <= 125):
            raise ValueError("Alavancagem fora do limite (1-125)")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.max_leverage = leverage_value
            db.commit()
            
            # Edita a mensagem original para mostrar o menu de configura√ß√µes atualizado
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"‚úÖ Alavancagem m√°xima atualizada para {leverage_value}x.\n\n"
                     "Selecione outra op√ß√£o para editar ou volte.",
                reply_markup=settings_menu_keyboard(user)
            )
        finally:
            db.close()

    except (ValueError, TypeError):
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="‚ùå Valor inv√°lido. Por favor, tente novamente com um n√∫mero inteiro (ex: 10)."
        )
        return ASKING_MAX_LEVERAGE
    finally:
        # Apaga a mensagem do usu√°rio com o n√∫mero
        await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    return ConversationHandler.END

async def ask_min_confidence(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Pergunta ao usu√°rio qual o novo valor de confian√ßa m√≠nima."""
    query = update.callback_query
    await query.answer()
    context.user_data['settings_message_id'] = query.message.message_id
    await query.edit_message_text("Envie o valor da confian√ßa m√≠nima da IA (ex: 75 para 75%).\nSinais com confian√ßa abaixo disso ser√£o ignorados.")
    return ASKING_MIN_CONFIDENCE

async def receive_min_confidence(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Recebe, valida e salva o novo valor de confian√ßa."""
    user_id = update.effective_user.id
    message_id_to_edit = context.user_data.get('settings_message_id')
    
    # Apaga a mensagem do usu√°rio (seja ela v√°lida ou n√£o) para manter o chat limpo
    await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)

    try:
        confidence_value = float(update.message.text.replace(',', '.'))
        if not (0 <= confidence_value <= 100):
            raise ValueError("Valor fora do range permitido (0-100)")

        db = SessionLocal()
        try:
            user = db.query(User).filter_by(telegram_id=user_id).first()
            user.min_confidence = confidence_value
            db.commit()
            
            # Edita a mensagem do bot para mostrar o menu de configura√ß√µes atualizado
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id_to_edit,
                text=f"‚úÖ Confian√ßa m√≠nima atualizada para {confidence_value:.2f}%.\n\n"
                     "Selecione outra op√ß√£o para editar ou volte.",
                reply_markup=settings_menu_keyboard(user)
            )
        finally:
            db.close()

        return ConversationHandler.END # Finaliza a conversa APENAS se deu tudo certo

    except (ValueError, TypeError):
        # --- L√ìGICA DE TRATAMENTO DE ERRO ---
        logger.warning(f"Usu√°rio {user_id} enviou um valor inv√°lido para confian√ßa: {update.message.text}")
        
        # Edita a mensagem do bot para avisar do erro e pedir para tentar de novo
        await context.bot.edit_message_text(
            chat_id=update.effective_chat.id,
            message_id=message_id_to_edit,
            text="‚ùå <b>Valor inv√°lido.</b>\nPor favor, envie apenas um n√∫mero entre 0 e 100 (ex: 75).",
            parse_mode='HTML'
        )
        
        # Mant√©m o usu√°rio na mesma etapa para que ele possa tentar de novo
        return ASKING_MIN_CONFIDENCE
    
async def report_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Envia o relat√≥rio de performance para o usu√°rio."""
    user_id = update.effective_user.id
    
    # Gera a mensagem do relat√≥rio chamando nossa nova fun√ß√£o
    report_text = generate_performance_report(user_id)
    
    await update.message.reply_text(
        text=report_text,
        parse_mode='HTML'
    )

async def manual_close_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Lida com o fechamento manual de uma posi√ß√£o pelo usu√°rio."""
    query = update.callback_query
    await query.answer("Processando fechamento...")

    # Extrai o ID do trade do callback_data (ex: "manual_close_12")
    trade_id = int(query.data.split('_')[-1])
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        # Busca o trade espec√≠fico no banco de dados
        trade_to_close = db.query(Trade).filter_by(id=trade_id, user_telegram_id=user_id).first()

        if not trade_to_close:
            await query.edit_message_text("Erro: Trade n√£o encontrado ou j√° fechado.")
            return

        # Pega as credenciais do usu√°rio
        user = db.query(User).filter_by(telegram_id=user_id).first()
        api_key = decrypt_data(user.api_key_encrypted)
        api_secret = decrypt_data(user.api_secret_encrypted)

        # Chama a fun√ß√£o para fechar a quantidade restante da posi√ß√£o
        close_result = close_partial_position(
            api_key, 
            api_secret, 
            trade_to_close.symbol, 
            trade_to_close.remaining_qty, 
            trade_to_close.side
        )

        if close_result.get("success"):
            trade_to_close.status = 'CLOSED_MANUAL'
            db.commit()
            await query.edit_message_text(f"‚úÖ Posi√ß√£o para {trade_to_close.symbol} fechada manualmente com sucesso!")
            # Opcional: Recarregar o menu de posi√ß√µes para mostrar a lista atualizada
            await my_positions_handler(update, context)
        else:
            error_msg = close_result.get('error')
            await context.bot.send_message(
                chat_id=user_id,
                text=f"‚ùå Erro ao fechar a posi√ß√£o para {trade_to_close.symbol}: {error_msg}"
            )
    finally:
        db.close()

async def bot_config_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Exibe o menu de configura√ß√£o do bot com o modo de aprova√ß√£o atual."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    
    db = SessionLocal()
    try:
        user = get_user_by_id(user_id)
        if user:
            await query.edit_message_text(
                "<b>ü§ñ Configura√ß√£o do Bot</b>\n\n"
                "Ajuste o comportamento geral do bot.",
                parse_mode='HTML',
                reply_markup=bot_config_keyboard(user)
            )
    finally:
        db.close()

async def toggle_approval_mode_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Alterna o modo de aprova√ß√£o de ordens entre Manual e Autom√°tico."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id

    db = SessionLocal()
    try:
        user = get_user_by_id(user_id)
        if user:
            # L√≥gica para alternar o modo
            if user.approval_mode == 'AUTOMATIC':
                user.approval_mode = 'MANUAL'
            else:
                user.approval_mode = 'AUTOMATIC'
            
            db.commit()
            
            # Edita a mensagem para refletir a mudan√ßa, redesenhando o teclado
            await query.edit_message_text(
                "<b>ü§ñ Configura√ß√£o do Bot</b>\n\n"
                "Ajuste o comportamento geral do bot.",
                parse_mode='HTML',
                reply_markup=bot_config_keyboard(user)
            )
    finally:
        db.close()

async def handle_signal_approval(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Lida com a decis√£o do usu√°rio (Aprovar/Rejeitar) para um sinal manual.
    """
    query = update.callback_query
    await query.answer()

    action, signal_id_str = query.data.split('_', 1)[-1].rsplit('_', 1)
    signal_id = int(signal_id_str)
    
    db = SessionLocal()
    try:
        # Busca o sinal que est√° aguardando aprova√ß√£o no banco de dados
        signal_to_process = db.query(SignalForApproval).filter_by(id=signal_id).first()

        if not signal_to_process:
            await query.edit_message_text("Este sinal j√° foi processado ou expirou.")
            return

        if action == 'approve':
            await query.edit_message_text("‚úÖ **Entrada Aprovada!** Processando ordem...")
            
            user = get_user_by_id(signal_to_process.user_telegram_id)
            signal_data = signal_to_process.signal_data
            source_name = signal_to_process.source_name
            
            # Chama a fun√ß√£o que executa o trade (que j√° criamos)
            await _execute_trade(signal_data, user, context.application, db, source_name)
            
        elif action == 'reject':
            await query.edit_message_text("‚ùå **Entrada Rejeitada.** O sinal foi descartado.")
        
        # Remove o sinal da tabela de aprova√ß√£o em ambos os casos
        db.delete(signal_to_process)
        db.commit()
    
    finally:
        db.close()


========================================
# Arquivo: bot/keyboards.py
========================================

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from database.crud import get_user_by_id

def main_menu_keyboard(telegram_id: int):
    """
    Retorna o teclado do menu principal de forma inteligente,
    verificando o status do usu√°rio diretamente no banco de dados.
    """
    user = get_user_by_id(telegram_id)
    has_api_keys = user and user.api_key_encrypted is not None

    keyboard = []
    if has_api_keys:
        keyboard.append([InlineKeyboardButton("üìä Minhas Posi√ß√µes", callback_data='user_positions')])
        keyboard.append([InlineKeyboardButton("‚öôÔ∏è Configura√ß√µes de Trade", callback_data='user_settings')])
        # --- NOVO BOT√ÉO ---
        keyboard.append([InlineKeyboardButton("ü§ñ Configura√ß√£o do Bot", callback_data='bot_config')])
        keyboard.append([InlineKeyboardButton("‚ÑπÔ∏è Meu Painel", callback_data='user_dashboard')])
    else:
        keyboard.append([InlineKeyboardButton("‚öôÔ∏è Configurar API Bybit", callback_data='config_api')])

    return InlineKeyboardMarkup(keyboard)

def dashboard_menu_keyboard():
    """Retorna o teclado para o painel do usu√°rio, com a op√ß√£o de remover a API."""
    keyboard = [
        [InlineKeyboardButton("üóëÔ∏è Remover API", callback_data='remove_api_prompt')],
        [InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def admin_menu_keyboard():
    """Retorna o teclado do menu de administrador."""
    keyboard = [
        [InlineKeyboardButton("üì° Listar Grupos/Canais", callback_data='admin_list_channels')],
        # --- NOVO BOT√ÉO ---
        [InlineKeyboardButton("üëÅÔ∏è Ver Alvos Ativos", callback_data='admin_view_targets')]
    ]
    return InlineKeyboardMarkup(keyboard)

def view_targets_keyboard():
    """Retorna o teclado para a tela de visualiza√ß√£o de alvos, com um bot√£o de voltar."""
    keyboard = [
        [InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu Admin", callback_data='back_to_admin_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def confirm_remove_keyboard():
    """Retorna o teclado de confirma√ß√£o para remover a API."""
    keyboard = [
        [InlineKeyboardButton("‚úÖ Sim, remover", callback_data='remove_api_confirm')],
        [InlineKeyboardButton("‚ùå N√£o, cancelar", callback_data='remove_api_cancel')],
    ]
    return InlineKeyboardMarkup(keyboard)

def settings_menu_keyboard(user_settings):
    """
    Retorna o teclado do menu de configura√ß√µes, mostrando os valores atuais.
    'user_settings' √© o objeto User vindo do banco de dados.
    """
    # Pega os valores do objeto do usu√°rio
    risk_percent = user_settings.risk_per_trade_percent
    max_leverage = user_settings.max_leverage
    min_confidence = user_settings.min_confidence # <-- ESTA LINHA FALTAVA

    keyboard = [
        [InlineKeyboardButton(f"Risco por Trade: {risk_percent:.2f}%", callback_data='set_risk_percent')],
        [InlineKeyboardButton(f"Alavancagem M√°xima: {max_leverage}x", callback_data='set_max_leverage')],
        [InlineKeyboardButton(f"Confian√ßa M√≠nima (IA): {min_confidence:.2f}%", callback_data='set_min_confidence')],
        [InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def bot_config_keyboard(user_settings):
    """
    Retorna o teclado para o menu de configura√ß√£o do bot, mostrando o modo de aprova√ß√£o.
    """
    mode = user_settings.approval_mode
    
    # Define o texto e o emoji com base no modo atual
    if mode == 'AUTOMATIC':
        button_text = "Modo de Aprova√ß√£o: Autom√°tico ‚ö°"
    else:
        button_text = "Modo de Aprova√ß√£o: Manual üëã"

    keyboard = [
        # Bot√£o que vai alternar o modo
        [InlineKeyboardButton(button_text, callback_data='toggle_approval_mode')],
        [InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data='back_to_main_menu')]
    ]
    return InlineKeyboardMarkup(keyboard)

def signal_approval_keyboard(signal_for_approval_id: int):
    """
    Retorna o teclado com os bot√µes de Aprovar/Rejeitar para um sinal manual.
    """
    keyboard = [
        [
            InlineKeyboardButton("‚úÖ Aprovar Entrada", callback_data=f'approve_signal_{signal_for_approval_id}'),
            InlineKeyboardButton("‚ùå Rejeitar", callback_data=f'reject_signal_{signal_for_approval_id}')
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

========================================
# Arquivo: services/__init__.py
========================================



========================================
# Arquivo: services/bybit_service.py
========================================

import logging
import asyncio
from typing import Dict
from pybit.unified_trading import HTTP
from database.models import User

logger = logging.getLogger(__name__)

# Fun√ß√£o auxiliar s√≠ncrona, n√£o precisa de 'async'
def get_session(api_key: str, api_secret: str) -> HTTP:
    """Cria e retorna uma sess√£o HTTP para ser usada em threads."""
    return HTTP(
        testnet=False,
        api_key=api_key,
        api_secret=api_secret
    )

async def get_account_info(api_key: str, api_secret: str) -> dict:
    """Busca informa√ß√µes da conta de forma ass√≠ncrona."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.get_wallet_balance(accountType="UNIFIED")
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']['list']}
            return {"success": False, "data": [], "error": response.get('retMsg', 'Erro desconhecido')}
        except Exception as e:
            logger.error(f"Exce√ß√£o em get_account_info: {e}", exc_info=True)
            return {"success": False, "data": [], "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def place_order(api_key: str, api_secret: str, signal_data: dict, user_settings: User, balance: float) -> dict:
    """Abre uma nova posi√ß√£o de forma ass√≠ncrona."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            symbol = signal_data['coin']
            side = "Buy" if signal_data['order_type'] == 'LONG' else "Sell"
            leverage = str(user_settings.max_leverage)
            entry_price = signal_data['entries'][0]
            stop_loss_price = float(signal_data['stop_loss'])
            take_profit_price = str(signal_data['targets'][0]) if signal_data.get('targets') else None
            
            risk_percent = user_settings.risk_per_trade_percent
            dollar_amount_to_risk = balance * (risk_percent / 100)
            
            stop_loss_distance_percent = abs(entry_price - stop_loss_price) / entry_price
            if stop_loss_distance_percent == 0:
                return {"success": False, "error": "Dist√¢ncia do Stop Loss √© zero."}

            position_size_dollars = dollar_amount_to_risk / stop_loss_distance_percent
            qty = round(position_size_dollars / entry_price, 3) 
            
            logger.info(f"Calculando ordem para {symbol}: Side={side}, Qty={qty}, Leverage={leverage}")

            session.set_leverage(category="linear", symbol=symbol, buyLeverage=leverage, sellLeverage=leverage)

            response = session.place_order(
                category="linear", symbol=symbol, side=side, orderType="Market",
                qty=str(qty), takeProfit=take_profit_price, stopLoss=str(stop_loss_price), isLeverage=1
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"Exce√ß√£o ao abrir ordem: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)
    
async def get_market_price(symbol: str) -> dict:
    """Busca o pre√ßo de mercado atual de forma ass√≠ncrona."""
    def _sync_call():
        try:
            session = HTTP(testnet=False)
            response = session.get_tickers(category="linear", symbol=symbol)
            if response.get('retCode') == 0 and response['result']['list']:
                price = float(response['result']['list'][0]['lastPrice'])
                return {"success": True, "price": price}
            else:
                return {"success": False, "error": response.get('retMsg', 'Pre√ßo n√£o encontrado')}
        except Exception as e:
            logger.error(f"Exce√ß√£o ao buscar pre√ßo de mercado para {symbol}: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def close_partial_position(api_key: str, api_secret: str, symbol: str, qty_to_close: float, side: str) -> dict:
    """Fecha uma parte de uma posi√ß√£o aberta de forma ass√≠ncrona."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            close_side = "Sell" if side == 'LONG' else "Buy"
            
            response = session.place_order(
                category="linear", symbol=symbol, side=close_side,
                orderType="Market", qty=str(qty_to_close), reduceOnly=True
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"Exce√ß√£o ao fechar posi√ß√£o parcial: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def modify_position_stop_loss(api_key: str, api_secret: str, symbol: str, new_stop_loss: float) -> dict:
    """Modifica o Stop Loss de uma posi√ß√£o aberta de forma ass√≠ncrona."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.set_trading_stop(
                category="linear", symbol=symbol, stopLoss=str(new_stop_loss)
            )
            if response.get('retCode') == 0:
                return {"success": True, "data": response['result']}
            else:
                return {"success": False, "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"Exce√ß√£o ao modificar Stop Loss: {e}", exc_info=True)
            return {"success": False, "error": str(e)}
    return await asyncio.to_thread(_sync_call)

async def get_open_positions(api_key: str, api_secret: str) -> dict:
    """Busca todas as posi√ß√µes abertas de forma ass√≠ncrona."""
    def _sync_call():
        try:
            session = get_session(api_key, api_secret)
            response = session.get_positions(category="linear", settleCoin="USDT")
            if response.get('retCode') == 0:
                open_positions = [p for p in response['result']['list'] if float(p['size']) > 0]
                return {"success": True, "data": open_positions}
            else:
                return {"success": False, "data": [], "error": response.get('retMsg')}
        except Exception as e:
            logger.error(f"Exce√ß√£o ao buscar posi√ß√µes abertas: {e}", exc_info=True)
            return {"success": False, "data": [], "error": str(e)}
    return await asyncio.to_thread(_sync_call)

========================================
# Arquivo: services/notification_service.py
========================================

import logging
from telegram.ext import Application
from utils.config import ADMIN_ID

logger = logging.getLogger(__name__)

async def send_notification(application: Application, message: str):
    """
    Envia uma mensagem de notifica√ß√£o para o administrador do bot.
    """
    if not application:
        logger.warning("Tentativa de enviar notifica√ß√£o sem a inst√¢ncia da aplica√ß√£o.")
        return
    try:
        await application.bot.send_message(
            chat_id=ADMIN_ID,
            text=message,
            parse_mode='HTML'
        )
        logger.info(f"Notifica√ß√£o enviada para o admin: {message[:50]}...")
    except Exception as e:
        logger.error(f"Falha ao enviar notifica√ß√£o para o admin: {e}")

========================================
# Arquivo: services/signal_parser.py
========================================

import re
import logging
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)

def parse_signal(message_text: str) -> Optional[Dict[str, Any]]:
    """
    Analisa a mensagem para extrair dados e, crucialmente, o TIPO de sinal
    (Limite, Mercado, Cancelado).
    """
    
    def find_single_value(pattern: str, text: str) -> Optional[str]:
        match = re.search(pattern, text, re.IGNORECASE)
        return match.group(1).strip() if match else None

    def find_multiple_values(pattern: str, text: str) -> List[float]:
        matches = re.findall(pattern, text, re.IGNORECASE)
        return [float(v) for v in matches]

    # --- Etapa 1: An√°lise de Tipo/Status ---
    text_lower = message_text.lower()
    signal_type = None
    if 'sinal cancelado' in text_lower:
        signal_type = 'CANCELLED'
    elif 'ordem limite' in text_lower:
        signal_type = 'LIMIT'
    elif 'ordem √† mercado' in text_lower or 'sinal entrou no pre√ßo' in text_lower:
        signal_type = 'MARKET'

    # --- Etapa 2: Extra√ß√£o dos Dados ---
    coin = find_single_value(r'.*Moeda:\s*(\w+)', message_text)
    
    # Para um cancelamento, tentamos extrair a moeda da linha de cancelamento se n√£o encontrarmos no formato padr√£o
    if signal_type == 'CANCELLED' and not coin:
        coin = find_single_value(r'(\w+)\s*Sinal Cancelado', message_text)

    order_type = find_single_value(r'Tipo:\s*(LONG|SHORT)', message_text)
    leverage_str = find_single_value(r'Alavancagem:\s*(\d+)x', message_text)
    entry_zone_str = find_single_value(r'Zona de Entrada:\s*([\d\.\s-]+)', message_text)
    stop_loss_str = find_single_value(r'Stop Loss:\s*([\d\.]+)', message_text)
    targets = find_multiple_values(r'T\d+:\s*([\d\.]+)', message_text)
    confidence_str = find_single_value(r'Confian√ßa:\s*([\d\.]+)%', message_text)

    # --- Etapa 3: Valida√ß√£o e Retorno por Tipo ---
    if not coin:
        logger.warning("[Parser] Campo 'Moeda' n√£o encontrado no sinal.")
        return None

    if signal_type == 'CANCELLED':
        # Para um cancelamento, s√≥ precisamos do tipo e da moeda.
        return {"type": signal_type, "coin": f"{coin.upper()}USDT"}

    # Valida√ß√£o para ordens de mercado/limite
    if not order_type or not entry_zone_str or not stop_loss_str:
        logger.warning("[Parser] Sinal n√£o cont√©m todos os campos necess√°rios (Tipo, Entrada, Stop).")
        return None

    entries = [float(val) for val in re.findall(r'([\d\.]+)', entry_zone_str)]
    if not entries:
        logger.warning("[Parser] Nenhum pre√ßo num√©rico encontrado na 'Zona de Entrada'.")
        return None

    # --- Etapa 4: Montagem do Dicion√°rio Final ---
    signal_data = {
        "type": signal_type,
        "coin": f"{coin.upper()}USDT",
        "order_type": order_type.upper(),
        "leverage": int(leverage_str) if leverage_str else 10,
        "entries": entries,
        "stop_loss": float(stop_loss_str),
        "targets": targets,
        "confidence": float(confidence_str) if confidence_str else None
    }
    
    return signal_data

========================================
# Arquivo: services/telethon_service.py
========================================



import logging
import asyncio
import os
import re
from telegram.ext import Application
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telethon.sync import TelegramClient
from telethon import events
from telethon.errors.rpcerrorlist import ChannelForumMissingError
from telethon.tl.functions.channels import GetForumTopicsRequest
from utils.config import API_ID, API_HASH
from database.session import SessionLocal
from database.models import MonitoredTarget
from .signal_parser import parse_signal

logger = logging.getLogger(__name__)

# --- L√ìGICA DE CAMINHO DIN√ÇMICO ---
if os.path.isdir('/data'):
    SESSION_PATH = '/data/tradeflow_user'
else:
    SESSION_PATH = 'tradeflow_user'

# --- DEFINI√á√ÉO √öNICA E CORRETA DO CLIENTE ---
client = TelegramClient(SESSION_PATH, API_ID, API_HASH)
comm_queue = None

# --- Fun√ß√µes de Busca (Helpers) ---

def get_monitored_targets():
    """Busca no DB a lista de todos os alvos (canal/t√≥pico) monitorados."""
    db = SessionLocal()
    try:
        return db.query(MonitoredTarget).all()
    finally:
        db.close()

async def list_channels():
    """Lista todos os canais e supergrupos com logging detalhado."""
    logger.info("[list_channels] Iniciando busca de di√°logos...")
    channels = []
    count = 0
    try:
        async for dialog in client.iter_dialogs():
            count += 1
            # A cada 50 chats processados, ele vai imprimir um log de progresso
            if count % 50 == 0:
                logger.info(f"[list_channels] ... processou {count} di√°logos...")
            
            if dialog.is_channel:
                channels.append((dialog.name, dialog.id))
        
        logger.info(f"[list_channels] Busca de di√°logos finalizada. Total de {count} di√°logos processados.")
    except Exception as e:
        logger.error(f"[list_channels] Erro durante iter_dialogs: {e}", exc_info=True)
        
    return channels

async def list_channel_topics(channel_id: int):
    """Busca os t√≥picos de um canal espec√≠fico."""
    topics = []
    try:
        entity = await client.get_entity(channel_id)
        result = await client(GetForumTopicsRequest(
            channel=entity, offset_date=0, offset_id=0, offset_topic=0, limit=100
        ))
        for topic in result.topics:
            topics.append((topic.title, topic.id))
    except ChannelForumMissingError:
        logger.warning(f"Canal {channel_id} n√£o possui t√≥picos (n√£o √© um f√≥rum).")
    except Exception as e:
        logger.error(f"Exce√ß√£o em list_channel_topics para o canal {channel_id}: {e}", exc_info=True)
    return topics

# --- Listener de Sinais ---
# Um padr√£o regex para pr√©-filtrar mensagens. Ele s√≥ aciona o handler
# se a mensagem contiver o emoji de diamante e a palavra "Moeda".
# Isso reduz drasticamente o n√∫mero de eventos que o bot precisa processar.
SIGNAL_PATTERN = re.compile(r'üíé\s*Moeda:', re.IGNORECASE)

@client.on(events.NewMessage(pattern=SIGNAL_PATTERN))
@client.on(events.MessageEdited(pattern=SIGNAL_PATTERN))
async def signal_listener(event):
    """
    Ouve mensagens que correspondem ao padr√£o e faz uma verifica√ß√£o final
    para garantir que √© um evento de mensagem v√°lido antes de processar.
    """
    global comm_queue
    
    # --- VERIFICA√á√ÉO FINAL E CORRE√á√ÉO ---
    # Garante que o evento √© do tipo que cont√©m uma mensagem de texto (Message).
    # Isso ignora com seguran√ßa outros eventos como status de usu√°rio, enquetes, etc.
    if not isinstance(event, (events.NewMessage.Event, events.MessageEdited.Event)):
        return
        
    if not event or not event.text or not comm_queue:
        return

    # A partir daqui, o c√≥digo est√° seguro, pois sabemos que 'event' √© uma mensagem.
    monitored_targets = get_monitored_targets()
    if not monitored_targets:
        return

    chat_id = event.chat_id
    topic_id = event.reply_to.reply_to_msg_id if event.reply_to else None

    is_target = any(
        (target.channel_id == chat_id and (target.topic_id is None and topic_id is None)) or
        (target.channel_id == chat_id and target.topic_id == topic_id)
        for target in monitored_targets
    )

    if is_target:
        logger.info(f"Potencial sinal detectado no alvo (Canal: {chat_id}). Adicionando √† fila.")
        await comm_queue.put({
            "action": "process_signal",
            "signal_text": event.text
        })

# --- Processador da Fila ---

async def queue_processor(queue: asyncio.Queue, ptb_app: Application):
    """Processa pedidos da fila, agora passando o 'source_name' adiante."""
    global comm_queue
    comm_queue = queue
    from core.trade_manager import process_new_signal

    while True:
        request = await queue.get()
        action = request.get("action")
        logger.info(f"[Queue Processor] ==> Pedido recebido! A√ß√£o: '{action}'")
        
        try:
            if action == "list_channels":
                logger.info("[Queue Processor] ... Entrou no bloco de 'list_channels'.")
                chat_id = request.get("chat_id")
                message_id = request.get("message_id")
                channels = await list_channels()
                db = SessionLocal()
                monitored_channels_ids = {target.channel_id for target in db.query(MonitoredTarget).all()}
                db.close()
                keyboard = []
                if channels:
                    for channel_name, channel_id in channels:
                        suffix = " ‚úÖ" if channel_id in monitored_channels_ids else ""
                        keyboard.append([InlineKeyboardButton(f"{channel_name}{suffix}", callback_data=f"monitor_channel_{channel_id}")])
                if keyboard:
                    await ptb_app.bot.edit_message_text(
                        chat_id=chat_id, message_id=message_id,
                        text="Selecione um grupo/canal (‚úÖ = algum monitoramento ativo):",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    await ptb_app.bot.edit_message_text(chat_id=chat_id, message_id=message_id, text="Nenhum canal ou supergrupo encontrado.")

            # --- L√ìGICA COMPLETA PARA LISTAR T√ìPICOS ---
            elif action == "list_topics":
                logger.info("[Queue Processor] ... Entrou no bloco de 'list_topics'.")
                channel_id = request.get("channel_id")
                chat_id = request.get("chat_id")
                message_id = request.get("message_id")
                channel_name = request.get("channel_name")
                
                topics = await list_channel_topics(channel_id)
                db = SessionLocal()
                
                if topics:
                    monitored_topic_ids = {t.topic_id for t in db.query(MonitoredTarget).filter_by(channel_id=channel_id).all() if t.topic_id}
                    keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è Voltar para Grupos", callback_data="admin_list_channels")]]
                    for name, topic_id in topics:
                        suffix = " ‚úÖ" if topic_id in monitored_topic_ids else ""
                        keyboard.append([InlineKeyboardButton(f"{name}{suffix}", callback_data=f"monitor_topic_{channel_id}_{topic_id}")])
                    
                    await ptb_app.bot.edit_message_text(
                        chat_id=chat_id, message_id=message_id,
                        text="Selecione o t√≥pico para monitorar (‚úÖ = j√° monitorado):",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    # L√≥gica para canais sem t√≥picos (adicionar/remover da lista de monitoramento)
                    existing = db.query(MonitoredTarget).filter_by(channel_id=channel_id, topic_id=None).first()
                    if existing:
                        db.delete(existing)
                        feedback_msg = f"‚ùå Canal '{channel_name}' removido da lista de monitoramento."
                    else:
                        new_target = MonitoredTarget(channel_id=channel_id, channel_name=channel_name)
                        db.add(new_target)
                        feedback_msg = f"‚úÖ Canal '{channel_name}' adicionado √† lista de monitoramento."
                    
                    db.commit()
                    await ptb_app.bot.edit_message_text(chat_id=chat_id, message_id=message_id, text=feedback_msg)
                
                db.close()

            elif action == "process_signal":
                logger.info("[Queue Processor] ... Entrou no bloco de 'process_signal'.")
                signal_text = request.get("signal_text")
                # --- MUDAN√áA: Pega o nome da fonte do pedido ---
                source_name = request.get("source_name", "Fonte Desconhecida")
                
                signal_data = parse_signal(signal_text)
                if signal_data:
                    # Passa o nome da fonte para o processador de trades
                    await process_new_signal(signal_data, ptb_app, source_name)
                else:
                    logger.info("Mensagem da fila n√£o √© um sinal v√°lido.")
            
            else:
                logger.warning(f"[Queue Processor] A√ß√£o desconhecida ou nula recebida: '{action}'")

        except Exception as e:
            logger.error(f"Erro CR√çTICO no processador da fila ao manusear a a√ß√£o '{action}': {e}", exc_info=True)
        finally:
            queue.task_done()
            logger.info(f"[Queue Processor] <== Pedido '{action}' finalizado.")

# --- Fun√ß√£o Principal do Servi√ßo ---

async def start_signal_monitor(queue: asyncio.Queue):
    """Inicia o cliente Telethon, o ouvinte de sinais e o processador da fila."""
    logger.info("Iniciando monitor de sinais com Telethon...")
    
    # Adiciona o ouvinte de mensagens ao cliente
    client.add_event_handler(signal_listener)
    
    # Conecta o cliente Telethon
    await client.start()
    
    # Pega a inst√¢ncia da aplica√ß√£o do bot que foi colocada na fila no main.py
    ptb_app = await queue.get()

    logger.info("‚úÖ Monitor de sinais e processador de fila ativos.")
    
    # Inicia o processador da fila como uma tarefa de fundo
    asyncio.create_task(queue_processor(queue, ptb_app))
    
    await client.run_until_disconnected()

